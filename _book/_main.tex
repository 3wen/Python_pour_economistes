% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
\documentclass[
  12pt,
]{book}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmonofont[Scale=0.7]{Source Code Pro}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage[]{natbib}
\bibliographystyle{apalike}
\usepackage{etex} %vers l'infini et au-dela
%\reserveinserts{28} % (et plus loin encore)

\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} % pour taper les lettres accentuees
\usepackage[english, french]{babel}
\usepackage{amsthm,amssymb,amsbsy,amsmath,amsfonts,amssymb,amscd,mathrsfs}
%Mise en page
\usepackage{geometry} %pour la modification des marges
\usepackage{fancyhdr} %pour modification des pieds de page
\usepackage{lastpage} %numero de la derniËre page
\usepackage{lscape} % Pour pouvoir activer le mode landscape
\usepackage{lmodern}
%Images, figures, etc.
\usepackage{booktabs} %tableaux
\usepackage{float}	%pour forcer le placement des images.
\usepackage{graphicx} %pour afficher des images
\usepackage{longtable} %tables sur plusieurs pages
\usepackage{animate} %transformer des gifs
\usepackage{caption}
%\usepackage{subcaption}
\captionsetup{labelformat=simple}
\usepackage[scriptsize]{subfigure}
\usepackage{multirow} 			%fusionner lignes
\usepackage{tikz}
\usepackage{adjustbox}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{mindmap,trees,shadows,backgrounds}
\usepackage{tabularx}
%Code
\usepackage{verbatim}%insertion de code
\usepackage{listings}
%Polices, format,couleurs
\usepackage{dsfont} % Pour les lettres mathematiques

\usepackage[nottoc]{tocbibind}

\usepackage{hyperref} %pour que les references soient des liens hypertextes
\usepackage{natbib}
\usepackage{bibentry}
%\usepackage{color}
\usepackage{xcolor,colortbl}
\definecolor{light-gray}{gray}{0.85}
\usepackage{ragged2e} % Pour justifier
%Symboles, theoremes
\newcommand{\iid}{\stackrel{\mathrm{iid}}{\sim}}
\newtheorem{theorem}{Theorem}[part]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{hypothese}{Hypoth\`ese}
\newtheorem{corollary}[theorem]{Corollary}
\usepackage{enumerate}%listes
\usepackage[subnum]{cases}% cas numerotes
%\newtheorem{laRemarque}{Remarque}[section]
 \newtheorem{rmarque}{Remarque}[section]
\newtheorem{exmp}{Exemple}[section]
\numberwithin{equation}{section}

\usepackage[official,right]{eurosym} % symbols euro
\usepackage{gensymb} % symbole degre \degre
\usepackage{rotating}
\usepackage{multicol}
% Bibliographie
%\usepackage{bib entry}
%\nobibliography*
%\let\newblock\relax

%\usepackage[notocbib]{apacite}
%\usepackage[style=apa]{biblatex}
%\usepackage[round]{natbib}
%\usepackage[style=authoryear]{biblatex}
%\usepackage[backend=bibtex, style=authoryear-comp]{biblatex}
%\usepackage{biblatex}
\renewcommand*{\bibfont}{\scriptsize} % Pour avoir la biblio en plus petit
%\usepackage{apacite}
%\bibliographystyle{apacite}

%\titlegraphic{
%\centering
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_amu_rvb_blanc.png}\hskip 3em
%%\colorbox{white}{\includegraphics[height=3em]{../../images/logo_feg.png}}
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_feg_blanc.png}\hskip 3em
%%\colorbox{white}{\includegraphics[height=3em]{../../images/logo_amse.png}}
%\includegraphics[height=2em]{/Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/template/assets/images/logo_amse.png}
%}

\justifying %on justifie le texte du document


% Pour les codes Python
\lstset{
language=Python,
basicstyle=\small\ttfamily,
commentstyle=\ttfamily\color{gray},
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=4,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
title=\lstname,
escapeinside={},
keywordstyle={},
morekeywords={},
literate=%
         {á}{{\'a}}1
         {à}{{\`a}}1
         {^a}{{\^a}}1
         {í}{{\'i}}1
         {ï}{{\"\i}}1
         {é}{{\'e}}1
         {è}{{\`e}}1
         {ê}{{\^e}}1
         {ë}{{\"e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ù}{{\`u}}1
         {ó}{{\'o}}1
         {ô}{{\^o}}1         
         {ě}{{\v{e}}}1
         {š}{{\v{s}}}1
         {č}{{\v{c}}}1
         {ř}{{\v{r}}}1
         {ž}{{\v{z}}}1
         {ď}{{\v{d}}}1
         {ť}{{\v{t}}}1
         {ň}{{\v{n}}}1                
         {ů}{{\r{u}}}1
         {Á}{{\'A}}1
         {Í}{{\'I}}1
         {É}{{\'E}}1
         {Ý}{{\'Y}}1
         {Ú}{{\'U}}1
         {Ó}{{\'O}}1
         {Ě}{{\v{E}}}1
         {É}{{\'E}}1
         {È}{{\`E}}1
         {Ê}{{\^E}}1
         {Š}{{\v{S}}}1
         {Č}{{\v{C}}}1
         {Ř}{{\v{R}}}1
         {Ž}{{\v{Z}}}1
         {Ď}{{\v{D}}}1
         {Ť}{{\v{T}}}1
         {Ň}{{\v{N}}}1                
         {Ů}{{\r{U}}}1 
}




%\graphicspath{{../images}}


\usepackage{array,dcolumn}
\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}m{#1}}




\definecolor{vert}{RGB}{0,157,87}
\definecolor{Lime}{RGB}{191,255,0}
\definecolor{limegreen}{RGB}{50,205,50}
\definecolor{vertsombre}{RGB}{27,68,21}
\definecolor{vertclair}{HTML}{06D6A0}

%
\definecolor{Camel}{RGB}{193,154,107}
\definecolor{rouge}{HTML}{EF476F}
\definecolor{orange}{RGB}{199,118,34}
%
\definecolor{ProcessYellow}{RGB}{255, 239, 0}
\definecolor{jauneAMSE}{RGB}{240, 171, 0}
\definecolor{jaune}{HTML}{FFD166}


%
\definecolor{bleu}{HTML}{118AB2}
\definecolor{LBlue}{RGB}{173, 216, 230}
\definecolor{bleusombre}{RGB}{18, 37, 67}
\definecolor{bleufonce}{RGB}{91,112,170}
\definecolor{bleuAMSE}{RGB}{0,101,189}
%
\definecolor{DPurple}{RGB}{48,25,52}
\definecolor{Indigo}{RGB}{75, 0, 130}
\definecolor{Periwinkle}{RGB}{204, 204, 255}
\definecolor{ElectricViolet}{RGB}{143, 0, 255}
\definecolor{AfricanViolet}{RGB}{178, 132, 190}
\definecolor{ChineseViolet}{RGB}{133, 96, 136}
\definecolor{Grape}{RGB}{111, 45, 168}
\definecolor{RussianViolet}{RGB}{50, 23, 77}
\definecolor{EnglishViolet}{RGB}{86, 60, 92}
%

\definecolor{bottomcolour}{rgb}{0.32,0.3,0.38}
\definecolor{middlecolour}{rgb}{0.08,0.08,0.16}



%\hypersetup{
%    colorlinks = true,
%    linkcolor = ProcessYellow
%}




\newcommand*\grasO[1]{\textbf{\textcolor{Camel}{#1}}} 
\newcommand*\grasR[1]{\textbf{\textcolor{rouge}{#1}}}
\newcommand*\grasV[1]{\textbf{\textcolor{vertclair}{#1}}} 
\newcommand*\grasB[1]{\textbf{\textcolor{bleu}{#1}}} 
\newcommand*\grasJ[1]{\textbf{\textcolor{jaune}{#1}}} 
\newcommand*\grasP[1]{\textbf{\textcolor{AfricanViolet}{#1}}} 

\definecolor{rcp26}{RGB}{39, 55, 122}
\definecolor{rcp45}{RGB}{112, 159, 200}
\definecolor{rcp60}{RGB}{222, 99, 43}
\definecolor{rcp85}{RGB}{205, 16, 32}

\newcommand*\grasRCPa[1]{\textbf{\textcolor{rcp26}{#1}}}
\newcommand*\grasRCPb[1]{\textbf{\textcolor{rcp45}{#1}}} 
\newcommand*\grasRCPc[1]{\textbf{\textcolor{rcp60}{#1}}} 
\newcommand*\grasRCPd[1]{\textbf{\textcolor{rcp85}{#1}}}

\usepackage{tcolorbox}

\makeatletter
\let\@@magyar@captionfix\relax
\makeatother


\definecolor{deepblue}{RGB}{0,110,160}



\usepackage{xparse}
\NewDocumentCommand\afun{v}{%
\texttt{#1}\index[fonctions]{#1@\ifun{#1}}%
}
\NewDocumentCommand\afunDeux{v}{%
\index[fonctions]{#1@\ifun{#1}}%
}


\NewDocumentCommand{\ifun}{v}{\texttt{#1}}


 \newcounter{countremarque}


\newenvironment{remarque}{%
 \refstepcounter{countremarque}
    \begin{tcolorbox}[width=\linewidth, colback=blue!3, boxrule=0.5pt,arc=0pt,title = Remarque \thecountremarque]
    }%
    {
    \end{tcolorbox}
    }
\numberwithin{countremarque}{section}


\newcounter{exercices}[section]

\definecolor{shadecolorex}{HTML}{CFE3D1}
\makeatletter
\newenvironment{exframe}{%
 \def\at@end@of@exframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@exframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolorex}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@exframe}
\makeatother




\hypersetup{
bookmarks=true,
pdfauthor={Ewen Gallic},
unicode=false,
pdftoolbar=true,
pdfmenubar=true,
pdffitwindow=false
pdfnewwindow=true,
colorlinks=true,
linkcolor=bleuAMSE,
citecolor=bleuAMSE,
filecolor=bleuAMSE,
urlcolor=bleuAMSE,}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Python pour les économistes},
  pdfauthor={Ewen Gallic},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Python pour les économistes}
\author{Ewen Gallic}
\date{Octobre 2018 - Dernière modification : Mai 2025}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{3}
\tableofcontents
}
\listoffigures
\listoftables
\chapter*{Propos liminaires}\label{propos-liminaires}
\addcontentsline{toc}{chapter}{Propos liminaires}

Ces notes de cours ont été réalisées dans le cadre d'un enseignement d'introduction à Python adressé à des étudiants du parcours Économétrie et Big Data de \href{https://www.amse-aixmarseille.fr/}{l'École d'Economie d'Aix-Marseille / Aix-Marseille School of Economics (AMSE)} d'Aix-Marseille Université.

\section{Objectifs}\label{objectifs}

Cet ouvrage a pour but l'initiation au langage de programmation Python, afin d'être capable de s'en servir de manière efficace et autonome. Le lecteur peut exécuter tous les exemples fournis (et est vivement encouragé à le faire). Des exercices viennent clore certains chapitres, pour mieux s'approprier les notions couvertes au fur et à mesure de la lecture.

Bien évidemment, Python étant un langage très vaste, ces notes ne sauraient et n'ont pas pour vocation à être exhaustives de l'utilisation de ce langage informatique.

\section{À qui s'adressent ces notes ?}\label{uxe0-qui-sadressent-ces-notes}

Dans un premier temps, cet ouvrage s'adresse aux débutants qui souhaientent apprendre les bases en Python. Il est à destination des étudiants de l'AMSE mais pourrait intéresser des individus ayant une approche de la donnée à travers la discipline économique désirant découvrir Python.

Merci à Adrien Pacifico pour ses commentaires instructifs. Merci à Josue Bock pour les coquilles repérées.

\chapter{Introduction}\label{introduction}

Ce document est construit principalement à l'aide de différentes références, parmi lesquelles :

\begin{itemize}
\tightlist
\item
  des livres : \citet{briggs_2013_python}, \citet{grus_2015_data}, \citet{vanderplas2016python}, \citet{mckinney_2017_python} ;
\item
  des (excellents) notebooks : \citet{navaro_python}.
\end{itemize}

\section{Historique}\label{historique}

Python est un langage de programmation multi plates-formes, écrit en \texttt{C}, placé sous une licence libre. Il s'agit d'un langage interprété, c'est-à-dire qu'il nécessite un interprète pour exécuter les commandes, et n'a pas de phase de compilation. Sa première version publique date de 1991. L'auteur principal, \href{https://en.wikipedia.org/wiki/Guido_van_Rossum}{Guido van Rossum} avait commencé à travailler sur ce langage de programmation durant la fin des années 1980. Le nom accordé au langage Python provient de l'intérêt de son créateur principal pour une série télévisée britannique diffusée sur la BBC intitulée ``\emph{Monty Python's Flying Circus}''.

La popularité de Python a connu une croissance forte ces dernières années, comme le confirment les résultats de sondages proposés par \href{https://stackoverflow.com/}{Stack Overflow} depuis 2011. Stack Overflow propose à ses utilisateurs de répondre à une enquête dans laquelle de nombreuses questions leur sont proposées, afin de décrire leur expérience en tant que développeur. \href{https://insights.stackoverflow.com/survey/2018\#technology}{Les résultats de l'enquête de 2018} montrent une nouvelle avancée de l'utilisation de Python par les développeurs. En effet, comme le montre la Figure~\ref{fig:intro-stack-langages}, 38.8\% des répondants indiquent développer en Python, soit 6.8 points de pourcentage de plus qu'un an auparavant, ce qui fait de ce langage de programmation celui dont la croissance a été la plus importante entre 2017 et 2018.

\begin{figure}

{\centering \includegraphics{_main_files/figure-latex/intro-stack-langages-1} 

}

\caption{Langages de programmation, de scripting et de balisage.}\label{fig:intro-stack-langages}
\end{figure}

\section{Versions}\label{versions}

Ces notes de cours visent à fournir une introduction à Python, dans sa version 3.x. En ce sens, les exemples fournis corresponderont à cette version, non pas aux précédentes.

Comparativement à la version 2.7, la version 3.0 a apporté des modifications profondes. Il faut noter que Python 2.7 prendra ``\href{https://pythonclock.org/}{sa retraite}'' le premier janvier 2020. Passée cette date, le support ne sera plus assuré.

\section{Espace de travail}\label{espace-de-travail}

Il existe de nombreux environnements dans lesquels programmer en Python. Nous allons en présenter succinctement quelques uns.

Il est supposé ici que vous vous avez installé \href{https://www.anaconda.com/}{Anaconda} sur votre poste. Anaconda est une distribution gratuite et open source des langages de programmation Python et R pour les applications en \emph{data science} et apprentissage automatique. Par ailleurs, lorsqu'il est fait mention du terminal dans les notes, il est supposé que le système d'exploitation de votre machine est soit Linux, soit Mac OS.

\subsection{Python dans un terminal}\label{python-dans-un-terminal}

Il est possible d'appeler Python depuis un terminal, en exécutant la commande suivante (sous Windows : dans le menu démarrer, lancer le logiciel ``Python 3.6'') :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{python}
\end{Highlighting}
\end{Shaded}

Ce qui donne le rendu visible sur la Figure~\ref{fig:intro-python-terminal} :

\begin{figure}[H]

{\centering \includegraphics[width=0.7\linewidth]{figs/python_terminal} 

}

\caption{Python dans un terminal.}\label{fig:intro-python-terminal}
\end{figure}

On note la présence des caractères \texttt{\textgreater{}\textgreater{}\textgreater{}} (\emph{prompt}), qui invitent l'utilisateur à inscrie une commande. Les expressions sont évaluées une fois qu'elle sont soumises (à l'aide de la touche \texttt{ENTREE}) et le résultat est donné, lorsqu'il n'y a pas d'erreur dans le code.

Par exemple, lorsque l'on évalue \texttt{2+1} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textgreater{}\textgreater{}\textgreater{} 2+1}
\NormalTok{3}
\NormalTok{\textgreater{}\textgreater{}\textgreater{}}
\end{Highlighting}
\end{Shaded}

On note la présence du \emph{prompt} à la fin, indiquant que Python est prêt à recevoir de nouvelles instructions.

\subsection{IPython}\label{ipython}

Il existe un environnement un peu plus chaleureux que Python dans le terminal : IPython. Il s'agit également d'un terminal interactif, mais avec davantages de fonctionnalités, notamment la coloration syntaxique ou l'auto-complétion (en utilisant la touche de tabulation).

Pour lancer IPython, on peut ouvrir un terminal et taper (puis valider) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ipython}
\end{Highlighting}
\end{Shaded}

On peut également lancer IPython depuis la fenêtre d'accueil d'Anaconda, en cliquant sur le bouton \texttt{Launch} de l'application \texttt{qtconsole}, visible sur la Figure~\ref{fig:intro-anaconda-navigator}.

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/anaconda_navigator} 

}

\caption{Fenêtre d'accueil d'Anaconda.}\label{fig:intro-anaconda-navigator}
\end{figure}

La console IPython, une fois lancée, ressemble à ceci :

\begin{figure}[H]

{\centering \includegraphics[width=0.7\linewidth]{figs/ipython} 

}

\caption{Console IPython.}\label{fig:unnamed-chunk-5}
\end{figure}

Soumettons une instruction simple pour évaluation à Python :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le résultat donne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{In [1]: print("Hello World")}
\NormalTok{Hello World}

\NormalTok{In [2]:}
\end{Highlighting}
\end{Shaded}

Plusieurs choses sont à noter. Premièrement, on note qu'à la fin de l'exécution de l'instruction, IPython nous indique qu'il est prêt à recevoir de nouvelles instruction, par la présence du \emph{prompt} \texttt{In\ {[}2{]}:}. Le numéro entre les crochets désigne le numéro de l'instruction. On note qu'il est passé de 1 à 2 après l'exécution. Ensuite, on note que le résultat de l'appel à la fonction \texttt{print()}, avec la chaîne de caractères (délimitée par des guillemets), affiche à l'écran ce qui était contenu entre les parenthèses.

\subsection{Spyder}\label{spyder}

Tandis que lorsqu'on utilise Python via un terminal, il est préférable d'avoir un éditeur de texte ouvert à côté (pour pouvoir sauvegarder les instructions), comme, par exemple, \href{https://www.sublimetext.com/}{Sublime Text} sous Linux ou Mac OS, ou \href{https://notepad-plus-plus.org/}{notepad++} sous Windows.

Une autre alternative consiste à utiliser un environnement de développement (IDE, pour \emph{Integrated development environment}) unique proposant notamment, à la fois un éditeur et une console. C'est ce que propose \href{https://www.spyder-ide.org/}{Spyder}, avec en outre de nombreuses fonctionnalités supplémentaires, comme la gestion de projet, un explorateur de fichier, un historique des commandes, un débugger, etc.

Pour lancer Spyder, on peut passer par un terminal, en évaluant tout simplement \texttt{Spyder} (ou en lançant le logiciel depuis le menu démarrer sous Windows). Il est également possible de lancer Spyder depuis Anaconda.

L'environnement de développement, comme visible sur la Figure~\ref{fig:intro-spyder}, se décompose en plusieurs fenêtres :

\begin{itemize}
\tightlist
\item
  à gauche : l'éditeur de script ;
\item
  en haut à droite : une fenêtre permettant d'afficher l'aide de Python, l'arborescence du système ou encore les variables créées ;
\item
  en bas à droite : une ou plusieurs consoles.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/spyder} 

}

\caption{Spyder.}\label{fig:intro-spyder}
\end{figure}

\subsection{Jupyter}\label{jupyter}

Il existe une interface graphique par navigateur d'IPython, appelée \href{http://jupyter.org/}{Jupyter Notebook}. Il s'agit d'une application en open-source permettant de créer et partager des documents qui contiennent du code, des équations, des représentations graphiques et du texte. Il est possible de faire figurer et exécuter des codes de langages différents dans les notebook Jupyter.

Pour lancer Jupyter, on peut passer par Anaconda. Après avoir cliqué sur le bouton \texttt{Launch}, de Jupyter Notebook, le navigateur web se lance et propose une arborescence, comme montré sur la Figure~\ref{fig:intro-jupyter}. Sans que l'on s'en rendiez compte, un serveur local web a été lancé ainsi qu'un processus Python (un \emph{kernel}).

Si le navigateur en se lance pas automatiquement, on peut accéder à la page qui aurait dû s'afficher, en se rendant à l'adresse suivante : \url{http://localhost:8890/tree}?.

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/jupyter} 

}

\caption{Jupyter.}\label{fig:intro-jupyter}
\end{figure}

Pour aborder les principales fonctions de Jupyter, nous allons créer un dossier \texttt{jupyter} dans un répertoire de notre choix. Une fois ce dossier créé, y naviguer à travers l'arborescence de Jupyter, dans le navigateur web.

Une fois dans le dossier, créer un nouveau Notebook \texttt{Python\ 3} (en cliquant sur le bouton \texttt{New} en haut à gauche de la fenêtre, puis sur Python 3`).

Un notebook intitulé \texttt{Untitled} vient d'être créé, la page affiche un document vide, comme visible sur la Figure~\ref{fig:intro-jupyter-notebook}.

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/jupyter_notebook} 

}

\caption{Un notebook vide.}\label{fig:intro-jupyter-notebook}
\end{figure}

Si on regarde dans notre explorateur de fichier, dans le dossier \texttt{jupyter} fraîchement créé, un nouveau fichier est apparu : \texttt{Untitled.ipynb}.

\subsubsection{Évaluation d'une instruction}\label{uxe9valuation-dune-instruction}

Retournons dans le navigateur web, sur la page affichant notre \emph{notebook}.

En dessous de la barre des menus, on note la présence d'une zone encadrée, \textbf{une cellule}, commençant, à l'instar de ce que l'on voyait dans la console sur IPython, par \texttt{IN\ {[}{]}:}. À droite, la zone grisée nous invite à soumettre des instructions en Python.

Inscrivons :

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

Pour soumettre l'instruction à évaluation, il existe plusieurs manières (il s'assurer d'avoir cliqué à l'intérieur de la cellule) :

\begin{itemize}
\tightlist
\item
  dans la barre des menus : \texttt{Cell\ \textgreater{}\ Run\ Cells} ;
\item
  dans la barre des raccourcis : bouton \texttt{Run} ;
\item
  avec le clavier : maintenir la touche \texttt{CTRL}et presser sur \texttt{Entree}.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{figs/jupyter_notebook_2} 

}

\caption{Cellule évaluée.}\label{fig:unnamed-chunk-9}
\end{figure}

\subsubsection{Cellules de texte}\label{cellules-de-texte}

Un des intérêts des \emph{notebooks} est qu'il est possible d'ajouter des cellules de texte.

Ajoutons une cellule en-dessous de la première. Pour ce faire, on peut procéder soit :

\begin{itemize}
\tightlist
\item
  par la barre de menu : \texttt{Insert\ \textgreater{}\ Insert\ Cell\ Below} (pour insérer une cellule en-dessous ; si on désire une insertion au-dessus, il suffit de choisir \texttt{Insert\ Cell\ Above}) ;
\item
  en cliquant dans le cadre de la cellule à partir de laquelle on désire faire un ajout (n'importe où, sauf dans la zone grisée de code, de manière à passer en mode \texttt{commande}), puis en appuyant sur la touche \texttt{B} du clavier (\texttt{A} pour une insertion au-dessus).
\end{itemize}

La nouvelle cellule appelle à nouveau à inscrire une instruction en Python. Pour indiquer que le contenu doit être interprété comme du texte, il est nécessaire de le préciser. Encore une fois, plusieurs méthodes permettent de le faire :

\begin{itemize}
\tightlist
\item
  par la barre de menu : \texttt{Cell\ \textgreater{}\ Cell\ Type\ \textgreater{}\ Markdown} ;
\item
  par la barre des raccourcis : dans le menu déroulant où est inscrit \texttt{Code}, en sélectionnant \texttt{Markdown} ;
\item
  en mode commande (après avoir cliqué à l'intérieur du cadre de la cellule, mais pas dans la zone de code), en appuyant sur la touche \texttt{M} du clavier.
\end{itemize}

La cellule est alors prête à recevoir du texte, rédigé en markdown. Pour plus d'informations sur la rédaction en Markdown, se référer à cette \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet}{antisèche} par exemple.

Entrons quelques lignes de texte pour voir très rapidement le fonctionnement des cellules rédigées en Markdown.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\# Un titre de niveau 1}

\NormalTok{Je vais écrire *du texte en italique* et aussi **en gras**.}

\NormalTok{\#\# Un titre de niveau 2}

\NormalTok{Je peux faire des listes :}

\NormalTok{{-} avec un item ;}
\NormalTok{{-} un second ;}
\NormalTok{{-} et un troisième imbriquant une nouvelle liste :}
\NormalTok{    {-} avec un sous{-}item,}
\NormalTok{    {-} et un second ;}
\NormalTok{{-} un quatrième incluant une liste imbriquée numérotée :}
\NormalTok{    1. avec un sous{-}item,}
\NormalTok{    1. et un autre.}

\NormalTok{\#\# Un autre titre de niveau 2}


\NormalTok{Je peux même faire figurer des équation $\textbackslash{}LaTeX$.}
\NormalTok{Comme par exemple $X \textbackslash{}sim \textbackslash{}mathcal\{N\}(0,1)$.}

\NormalTok{Pour en savoir plus sur $\textbackslash{}LaTeX$, on peut se référer à cette :}
\NormalTok{  [page Wikipédia](https://en.wikibooks.org/wiki/LaTeX/Mathematics).}
\end{Highlighting}
\end{Shaded}

Ce qui donne, dans Jupyter :

\begin{figure}[h]

{\centering \includegraphics[width=1\linewidth]{figs/jupyter_notebook_3} 

}

\caption{Cellule textuelle non évaluée.}\label{fig:unnamed-chunk-11}
\end{figure}

Reste alors à l'évaluer, comme s'il s'agissait d'une cellule contenant une instruction Python, pour basculer vers un affichage Markdown (\texttt{CTRL} et \texttt{ENTREE}).

Pour \textbf{éditer le texte} une fois que l'on a basculé en markdown, un simple double-clic dans la zone de texte de la cellule fait l'affaire.

Pour \textbf{changer le type de la cellule pour qu'elle devienne du code} :

\begin{itemize}
\tightlist
\item
  par la barre de menu : \texttt{Cell\ \textgreater{}\ Cell\ Type\ \textgreater{}\ Code} ;
\item
  par la barre des raccourcis : dans le menu déroulant où est inscrit \texttt{Code}, en sélectionnant \texttt{Code} ;
\item
  en mode commande, appuyer sur la touche du clavier \texttt{Y}.
\end{itemize}

\subsubsection{Suppression d'une cellule}\label{suppression-dune-cellule}

Pour supprimer une cellule :

\begin{itemize}
\tightlist
\item
  par la barre de menu : \texttt{Edit\ \textgreater{}\ Delete\ Cells} ;
\item
  par la barre des raccourcis : icône en forme de ciseaux ;
\item
  en mode commande, appuyer deux fois sur la touche du clavier \texttt{D}.
\end{itemize}

\section{Les variables}\label{les-variables}

\subsection{Assignation et suppression}\label{assignation-et-suppression}

Lorsque nous avons évalué les instructions \texttt{2+1} précédemment, le résultat s'est affiché dans la console, mais il n'a pas été enregistré. Dans de nombreux cas, il est utile de conserver le contenu du résultat dans un objet, pour pouvoir le réutiliser par la suite. Pour ce faire, on utilise des \emph{variables}. Pour créer une variable, on utilise le signe d'égalité (\texttt{=}), que l'on fait suivre par ce que l'on veut sauvegarder (du texte, un nombre, plusieurs nombres, etc.) et précéder par le nom que l'on utilisera pour désigner cette variable.

Par exemple, si on souhaite stocker le résultat du calcul \texttt{2+1} dans une variable que l'on nommera \texttt{x}, il faudra écrire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

Pour afficher la valeur de notre variable \texttt{x}, on fait appel à la fonction \texttt{print()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

Pour changer la valeur de la variable, il suffit de faire une nouvelle assignation :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{4}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

Il est également possible de donner plus d'un nom à un même contenu (on réalise une copie de \texttt{x}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{;}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

Si on modifie la copie, l'original ne sera pas affecté :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

Pour \textbf{supprimer} une variable, on utilise l'instruction \texttt{del} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{del}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

L'affichage du contenu de \texttt{y} renvoit une erreur :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## NameError: name 'y' is not defined
\end{lstlisting}

Mais on note que la variable \texttt{x} n'a pas été supprimée :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\subsection{Conventions de nommage}\label{conventions-de-nommage}

Le nom d'une variable peut être composé de caractères alphanumériques ainsi que du trait de soulignement (\texttt{\_}) (il n'y a pas de limite sur la longueur du nom). Il est proscrit de faire commencer le nom de la variable par un nombre. Il est également interdit de faire figurer une espace dans le nom d'une variable.

Pour accroitre la lisibilité du nom des variables, plusieurs méthodes existent. Nous adopterons la suivante :

\begin{itemize}
\tightlist
\item
  toutes les lettres en minuscule ;
\item
  la séparation des termes par un trait de soulignement.
\end{itemize}

Exemple, pour une variable contenant la valeur de l'identifiant d'un utilisateur : \texttt{id\_utilisateur}.

Il faut noter que le nom des variables est \textbf{sensible à la casse} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"toto"}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## toto
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## NameError: name 'X' is not defined
\end{lstlisting}

\section{Les commentaires}\label{les-commentaires}

Pour ajouter des commentaires en python, il existe plusieurs façons.

Une des manières de faire est d'utiliser le symbole dièse (\texttt{\#}) pour effectuer un \textbf{commentaire sur une seule ligne}. Tout ce qui suit le dièse jusqu'à la fin de la ligne ne sera pas évalué par Python. En revanche, ce qui vient avant le dièse le sera.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Un commentaire print("Bonjour")}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{) }\CommentTok{\# Un autre commentaire}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello
\end{lstlisting}

L'introduction d'un \textbf{bloc de commentaires} (des commentaires sur plusieurs lignes) s'effectue quant à elle en entourant ce qui est ) commenter d'un délimiteur : trois guillemets simples ou doubles :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{"""}
\CommentTok{Un commentaire qui commencer sur une ligne}
\CommentTok{et qui continue sur une autre}
\CommentTok{et s\textquotesingle{}arrête à la troisième}
\CommentTok{"""}
\end{Highlighting}
\end{Shaded}

\section{Les modules et les packages}\label{les-modules-et-les-packages}

Certaines fonctions de base en Python sont chargées par défaut. D'autres, nécessitent de charger un \textbf{module}. Ces modules sont des fichiers qui contiennent des \textbf{définitions} ainsi que des \textbf{instructions}.

Lorsque plusieurs modules sont réunis pour offrir un ensemble de fonctions, on parle alors de \emph{\textbf{package}}.

Parmi les \emph{packages} qui seront utilisés dans ces notes, on peut citer :

\begin{itemize}
\tightlist
\item
  \href{http://www.numpy.org/}{NumPy}, un \emph{package} fondamental pour effectuer des calculs scientifiques ;
\item
  \href{https://pandas.pydata.org/}{pandas}, un \emph{package} permettant de manipuler facilement les données et de les analyser ;
\item
  \href{https://matplotlib.org/}{Matplotlib}, un \emph{package} permettant de réaliser des graphiques.
\end{itemize}

Pour charger un module (ou un \emph{package}), on utilise la commande \texttt{import}. Par exemple, pour charger le \emph{package} \texttt{pandas} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas}
\end{Highlighting}
\end{Shaded}

Ce qui permet de faire appel à des fonctions contenues dans le module ou le \emph{package}. Par exemple, ici, on peut faire appel à la fonction \texttt{Series()}, contenue dans le \emph{package} \texttt{pandas}, permettant de créer un tableau de données indexées à une dimension :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ pandas.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    1
## 1    5
## 2    4
## dtype: int64
\end{lstlisting}

Il est possible de donner un alias au module ou au \emph{package} que l'on importe, en le précisant à l'aide de la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ module }\ImportTok{as}\NormalTok{ alias}
\end{Highlighting}
\end{Shaded}

Cette pratique est courante pour abréger les noms des modules que l'on va être amené à utiliser beaucoup. Par exemple, pour \texttt{pandas}, il est coutume d'écourter le nom en \texttt{pd} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{x }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    1
## 1    5
## 2    4
## dtype: int64
\end{lstlisting}

On peut également importer une seule fonction d'un module, et lui attribuer (optionnellement) un alias. Par exemple, avec la fonction \texttt{pyplot} du \emph{package} \texttt{matplotlib}, il est coutume de faire comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib}
\ImportTok{import}\NormalTok{ matplotlib.pyplot  }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy  }\ImportTok{as}\NormalTok{ np}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\FloatTok{0.1}\NormalTok{)}\OperatorTok{;}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(x)}
\NormalTok{plt.plot(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/intro_pyplot} \end{center}

\section{L'aide}\label{laide}

Pour conclure cette introduction, il semble important de mentionner la présence de l'\textbf{aide} et de la \textbf{documentation} en Python.

Pour obtenir des informations sur des fonctions, il est possible de se référer à la \href{https://docs.python.org/3/}{documentation en ligne}. Il est également possible d'obtenir de l'aide à l'intérieur de l'environnement que l'on utilise, en utilisant le point d'interrogation (\texttt{?}).

Par exemple, lorsque l'on utilise IPython (ce qui, rappelons-le, est le cas dans Jupyter), on peut accéder à l'aide à travers différentes syntaxes :

\begin{itemize}
\tightlist
\item
  \texttt{?} : fournit une introduction et un aperçu des fonctionnalités offertes en Python (on la quitte avec la touche \texttt{ESC} par exemple);
\item
  \texttt{object?} : fournit des détails au sujet de \texttt{\textquotesingle{}object\textquotesingle{}} (par exemple \texttt{x?} ou encore \texttt{plt.plot?}) ;
\item
  \texttt{object??} : plus de détails à propos de \texttt{\textquotesingle{}object\textquotesingle{}} ;
\item
  \texttt{\%quickref} : référence courte sur les syntaxes en Python ;
\item
  \texttt{help()} : accès à l'aide de Python.
\end{itemize}

\emph{Note} : la touche de \textbf{tabulation} du clavier permet non seulement une \textbf{autocomplétion}, mais aussi une \textbf{exploration du contenu} d'un objet ou module.

Par ailleurs, lorsqu'il s'agit de trouver de l'aide sur un problème plus complèxe, le bon réflèxe à adopter est de ne pas hésiter à chercher sur un moteur de recherche, dans des mailing-lists et bien évidemment sur les nombreuses questions sur \href{https://stackoverflow.com}{Stack Overflow}.

\chapter{Types de données}\label{types-de-donnuxe9es}

Il existe quelques types de données intégrés dans Python. Nous allons dans cette partie évoquer les chaînes de caractères, les valeurs numériques, les bouléens (\texttt{TRUE}/\texttt{FALSE}), la valeur \texttt{null} et les dates et temps.

\section{Chaînes de caractères}\label{chauxeenes-de-caractuxe8res}

Une chaîne de caractères, ou \emph{string} en anglais, est une collection de caractères comme des lettres, des nombres, des espaces, des signes de ponctuation, etc.

Les chaînes de caractères sont repérées à l'aide de guillemets simples, doubles, ou triples.

Voici un exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Hello World"}
\end{Highlighting}
\end{Shaded}

Pour afficher dans la console le contenu de notre variable \texttt{x} contenant la chaîne de caractères, on fait appel à la fonction \texttt{print()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello World
\end{lstlisting}

Comme indiqué juste avant, des guillemets simples peuvent être utilisés pour créer une chaîne de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=} \StringTok{\textquotesingle{}How are you?\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## How are you?
\end{lstlisting}

Pour faire figurer des apostrophes dans une chaîne de caractères créée à l'aide de guillemets simples, il est nécessaire d'utiliser un caracrère d'échappement : une barre oblique inversée (\texttt{\textbackslash{}}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \StringTok{\textquotesingle{}I}\CharTok{\textbackslash{}\textquotesingle{}}\StringTok{m fine\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## I'm fine
\end{lstlisting}

On peut noter que si la chaîne de caractères est créée à l'aide de guillemets doubles, il n'est pas nécessaire d'avoir recours au caractère d'échappement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \StringTok{"I\textquotesingle{}m }\CharTok{\textbackslash{}"}\StringTok{fine}\CharTok{\textbackslash{}"}\StringTok{"}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## I'm "fine"
\end{lstlisting}

Pour indiquer un retour à la ligne, on utilise la chaîne \texttt{\textbackslash{}n} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Hello, }\CharTok{\textbackslash{}n}\StringTok{World"}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello, 
## World
\end{lstlisting}

Dans le cas de chaînes de caractères sur \textbf{plusieurs lignes}, le fait d'utiliser des guillemets simples ou doubles renverra une erreur (\emph{EOL while scanning trial literal}, \emph{i.e.}, détection d'une erreur de syntaxe, Python s'attendait à quelque chose d'autre à la fin de la ligne). Pour écrire une chaîne de caractères sur plusieurs lignes, Python propose d'utiliser trois fois des guillemets (simples ou doubles) en début et fin de chaîne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"""Hello,}
\StringTok{World"""}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello,
## World
\end{lstlisting}

\begin{remarque}
Le caractère \texttt{\textbackslash{}} (barre oblique inversée, ou \emph{backslash}) est le caractère d'échappement. Il permet d'afficher certains caractères, comme les guillemets dans une chaîne elle-même définie à l'aide de guillemets, ou bien les caractères de contrôle, comme la tabulation, le saut de ligne, etc. Voici quelques exemples courants :

\begin{longtable}[]{@{}cccc@{}}
\toprule\noalign{}
Code & Description & Code & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\textbackslash{}n} & Nouvelle ligne & \texttt{\textbackslash{}r} & Retour à la ligne \\
\texttt{\textbackslash{}t} & Tabulation & \texttt{\textbackslash{}b} & Retour arrière \\
\texttt{\textbackslash{}\textbackslash{}} & Barre oblique inversée & \texttt{\textbackslash{}\textquotesingle{}} & Apostrophe \\
\texttt{\textbackslash{}"} & Apostrophe double & \texttt{\textbackslash{}\textasciigrave{}} & Accent grave \\
\end{longtable}
\end{remarque}

Pour récupérer la \textbf{longueur d'une chaîne de caractères}, Python propose la fonction \texttt{len()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Hello World !"}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 13
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x, }\BuiltInTok{len}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello World ! 13
\end{lstlisting}

\subsection{Concaténation de chaînes}\label{type-chaines-concatenation}

Pour concaténer des chaînes de caractères, c'est-à-dire les mettre bout à bout, Python propose d'utiliser l'opérateur \texttt{+} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello"} \OperatorTok{+} \StringTok{" World"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello World
\end{lstlisting}

L'opérateur \texttt{*} permet quant à lui de répéter plusieurs fois une chaîne :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\DecValTok{3} \OperatorTok{*} \StringTok{"Go Habs Go! "} \OperatorTok{+} \StringTok{"Woo Hoo!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Go Habs Go! Go Habs Go! Go Habs Go! Woo Hoo!
\end{lstlisting}

Lorsque deux littéraux de chaînes sont côte à côte, Python les concatène :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ (}\StringTok{\textquotesingle{}You shall \textquotesingle{}} \StringTok{\textquotesingle{}not \textquotesingle{}} \StringTok{"pass!"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## You shall not pass!
\end{lstlisting}

Il est également possible d'\textbf{ajouter à une chaîne de caractères le contenu d'une variable}, à l'aide de crochets (\texttt{\{\}}) et de la méthode \texttt{format()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"J\textquotesingle{}aime coder en }\SpecialCharTok{\{\}}\StringTok{"}
\NormalTok{langage\_1 }\OperatorTok{=} \StringTok{"R"}
\NormalTok{langage\_2 }\OperatorTok{=} \StringTok{"Python"}
\NormalTok{preference\_1 }\OperatorTok{=}\NormalTok{ x.}\BuiltInTok{format}\NormalTok{(langage\_1)}
\BuiltInTok{print}\NormalTok{(preference\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## J'aime coder en R
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preference\_2 }\OperatorTok{=}\NormalTok{ x.}\BuiltInTok{format}\NormalTok{(langage\_2)}
\BuiltInTok{print}\NormalTok{(preference\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## J'aime coder en Python
\end{lstlisting}

Il est tout à fait possible d'ajouter \textbf{plus d'un contenu de variable} dans une chaîne de caractères, toujours avec les crochets et la méthode \texttt{format()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"J\textquotesingle{}aime coder en }\SpecialCharTok{\{\}}\StringTok{ et en }\SpecialCharTok{\{\}}\StringTok{"}
\NormalTok{preference\_3 }\OperatorTok{=}\NormalTok{ x.}\BuiltInTok{format}\NormalTok{(langage\_1, langage\_2)}
\BuiltInTok{print}\NormalTok{(preference\_3)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## J'aime coder en R et en Python
\end{lstlisting}

\subsection{Indexation et extraction}\label{indexation-et-extraction}

Les chaînes de caractères peuvent être indexées. Attention, \textbf{l'indice du premier caractère commence à 0}.

Pour obtenir le ie caractère d'une chaîne, on utilise des crochets. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Par exemple, pour afficher le premier caractère, puis le cinquième de la chaîne \texttt{Hello} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Hello"}
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## H
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## o
\end{lstlisting}

L'extraction peut s'effectuer en partant par la fin de la chaîne, en faisant précéder la veleur de l'indice par le signe moins (\texttt{-}).

Par exemple, pour afficher l'avant-dernier caractère de notre chaîne \texttt{x} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## l
\end{lstlisting}

L'extraction d'une sous-chaîne en précisant sa position de début et de fin (implicitement ou non) s'effectue avec les crochets également. Il suffit de préciser les deux valeurs d'indices : \texttt{{[}debut:fin{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"You shall not pass!"}

\CommentTok{\# Du quatrième caractère (non inclus) au neuvième (inclus)}
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{4}\NormalTok{:}\DecValTok{9}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## shall
\end{lstlisting}

Lorsque l'on ne précise pas la première valeur, le début de la chaîne est pris par défaut ; lorsque le second n'est pas précisé, la fin de la chaîne est prise par défaut.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Du 4e caractère (non inclus) à la fin de la chaîne}
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{4}\NormalTok{:])}
\CommentTok{\# Du début de la chaîne à l\textquotesingle{}avant dernier caractère (inclus)}
\BuiltInTok{print}\NormalTok{(x[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\CommentTok{\# Du 3e caractère avant la fin (inclus) jusqu\textquotesingle{}à la fin}
\BuiltInTok{print}\NormalTok{(x[}\OperatorTok{{-}}\DecValTok{5}\NormalTok{:])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## shall not pass!
\end{lstlisting}

\begin{lstlisting}
## You shall not pass
\end{lstlisting}

\begin{lstlisting}
## pass!
\end{lstlisting}

Il est possible de rajouter un troisième indice dans les crochets : \textbf{le pas}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Du 4e caractère (non inclus), jusqu\textquotesingle{}à la fin de la chaîne,}
\CommentTok{\# par pas de 3.}
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{4}\NormalTok{::}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## sln s
\end{lstlisting}

Pour obtenir la chaîne en dans le sens opposé :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## !ssap ton llahs uoY
\end{lstlisting}

\subsection{Méthodes disponibles avec les chaînes de caractères}\label{muxe9thodes-disponibles-avec-les-chauxeenes-de-caractuxe8res}

De nombreuses méthodes sont disponibles pour les chaînes de caractères. En ajoutant un point (\texttt{.}) après le nom d'un objet désignant une chaîne de caractères puis en appuyant sur la touche de tabulation, les méthodes disponibles s'affichent dans un menu déroulant.

Par exemple, la méthode \texttt{count()} permet de compter le nombre d'occurrences d'un motif dans la chaîne. Pour compter le nombre d'occurrence de \texttt{in} dans la chaîne suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"le train de tes injures roule sur le rail de mon indifférence"}
\BuiltInTok{print}\NormalTok{(x.count(}\StringTok{"in"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

\begin{remarque}
Une fois l'appel à méthode écrit, en plaçant le curseur à la fin de la ligne et en appuyant sur les touches \texttt{Shift} et \texttt{Tabulation}, on peut afficher des explications.
\end{remarque}

\subsubsection{Conversion en majuscules ou en minuscules}\label{conversion-en-majuscules-ou-en-minuscules}

Les méthodes \texttt{lower()} et \texttt{upper()} permettent de passer une chaîne de caractères en caractères minuscules et majuscules, respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"le train de tes injures roule sur le rail de mon indifférence"}
\BuiltInTok{print}\NormalTok{(x.lower())}
\BuiltInTok{print}\NormalTok{(x.upper())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## le train de tes injures roule sur le rail de mon indifférence
\end{lstlisting}

\begin{lstlisting}
## LE TRAIN DE TES INJURES ROULE SUR LE RAIL DE MON INDIFFÉRENCE
\end{lstlisting}

\subsubsection{Recherche de chaînes de caractères}\label{recherche-de-chauxeenes-de-caractuxe8res}

Quand on souhaite \textbf{retrouver un motif} dans une chaîne de caractères, on peut utiliser la méthode \texttt{find()}. On fournit en paramètres un motif à rechercher. La méthode \texttt{find()} retourne le plus petit indice dans la chaîne où le motif est trouvé. Si le motif n'est pas retrouvé, la valeur retournée est \texttt{-1}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.find(}\StringTok{"in"}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(x.find(}\StringTok{"bonjour"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 6
\end{lstlisting}

\begin{lstlisting}
## -1
\end{lstlisting}

Il est possible d'ajouter en option une indication permettant de \textbf{limiter la recherche sur une sous-chaîne}, en précisant l'indice de début et de fin :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.find(}\StringTok{"in"}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{20}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 16
\end{lstlisting}

Note : on peut omettre l'indice de fin ; en ce cas, la fin de la chaîne est utilisée :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.find(}\StringTok{"in"}\NormalTok{, }\DecValTok{20}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 49
\end{lstlisting}

\begin{remarque}
Si on ne désire pas connaître la position de la sous-chaîne, mais uniquement sa présence ou son absence, on peut utiliser l'opérateur \texttt{in} : \texttt{print("train"\ in\ x)}
\end{remarque}

Pour effectuer une recherche \textbf{sans prêter attention à la casse}, on peut utiliser la méthode \texttt{capitalize()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Mademoiselle Deray, il est interdit de manger de la choucroute ici."}
\BuiltInTok{print}\NormalTok{(x.find(}\StringTok{"deray"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## -1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.capitalize().find(}\StringTok{"deray"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 13
\end{lstlisting}

\subsubsection{Découpage en sous-chaînes}\label{duxe9coupage-en-sous-chauxeenes}

Pour \textbf{découper une chaîne de caractères en sous-chaînes}, en fonction d'un motif servant à la délimitation des sous-chaînes (par exemple une virgule, ou une espace), on utilise la méthode \texttt{split()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.split(}\StringTok{" "}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Mademoiselle', 'Deray,', 'il', 'est', 'interdit', 'de', 'manger', 'de', 'la', 'choucroute', 'ici.']
\end{lstlisting}

En indiquant en paramètres une valeur numérique, on peut limiter le nombre de sous-chaînes retournées :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le nombre de sous{-}chaînes maximum sera de 3}
\BuiltInTok{print}\NormalTok{(x.split(}\StringTok{" "}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Mademoiselle', 'Deray,', 'il', 'est interdit de manger de la choucroute ici.']
\end{lstlisting}

La méthode \texttt{splitlines()} permet également de séparer une chaîne de caractères en fonction d'un motif, ce motif étant un caractère de fin de ligne, comme un saut de ligne ou un retour chariot par exemple.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}"Luke, je suis ton pere !}
\StringTok{{-} Non... ce n\textquotesingle{}est pas vrai ! C\textquotesingle{}est impossible !}
\StringTok{{-} Lis dans ton coeur, tu sauras que c\textquotesingle{}est vrai.}
\StringTok{{-} Noooooooon ! Noooon !"\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(x.splitlines())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['"Luke, je suis ton pere !', "- Non... ce n'est pas vrai ! C'est impossible !", "- Lis dans ton coeur, tu sauras que c'est vrai.", '- Noooooooon ! Noooon !"']
\end{lstlisting}

\subsubsection{Nettoyage, complétion}\label{nettoyage-compluxe9tion}

Pour retirer des caractères blancs (\emph{e.g.}, des espaces, sauts de ligne, quadratins, etc.) présents en début et fin de chaîne, on peut utiliser la méthode \texttt{strip()}, ce qui est parfois très utile pour nettoyer des chaînes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{    Pardon, du sucre ?     }\CharTok{\textbackslash{}n}\StringTok{  }\CharTok{\textbackslash{}n}\StringTok{"}
\BuiltInTok{print}\NormalTok{(x.strip())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Pardon, du sucre ?
\end{lstlisting}

On peut préciser en paramètre quels caractères retirer en début et fin de chaîne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"www.egallic.fr"}
\BuiltInTok{print}\NormalTok{(x.strip(}\StringTok{"wrf."}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## egallic
\end{lstlisting}

Parfois, il est nécessaire de s'assurer d'obtenir une \textbf{chaîne d'une longueur donnée} (lorsque l'on doit fournir un fichier avec des largeurs fixes pour chaque colonne par exemple). La méthode \texttt{rjust()} est alors d'un grand secours. En lui renseignant une longueur de chaîne et un caractère de remplissage, elle retourne la chaîne de caractères avec une complétion éventuelle (si la longueur de la chaîne retournée n'est pas assez longue au regard de la valeur demandée), en répétant le caractère de remplissage autant de fois que nécessaire.

Par exemple, pour avoir une coordonnée de longitude, stockée dans une chaîne de caractères de longueur 7, en rajoutant des espaces si nécessaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{longitude }\OperatorTok{=} \StringTok{"48.11"}
\BuiltInTok{print}\NormalTok{(x.rjust(}\DecValTok{7}\NormalTok{,}\StringTok{" "}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## www.egallic.fr
\end{lstlisting}

\subsubsection{Remplacements}\label{remplacements}

La méthode \texttt{replace()} permet d'effectuer des \textbf{remplacements de motifs} dans une chaîne de caractères.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"Criquette ! Vous, ici ? Dans votre propre salle de bain ? Quelle surprise !"}
\BuiltInTok{print}\NormalTok{(x.replace(}\StringTok{"Criquette"}\NormalTok{, }\StringTok{"Ridge"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Ridge ! Vous, ici ? Dans votre propre salle de bain ? Quelle surprise !
\end{lstlisting}

Cette méthode est très pratique pour \textbf{retirer des espaces} par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.replace(}\StringTok{" "}\NormalTok{, }\StringTok{""}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Criquette!Vous,ici?Dansvotrepropresalledebain?Quellesurprise!
\end{lstlisting}

Voici un tableau répertoriant quelques méthodes disponibles (\href{https://docs.python.org/3/library/stdtypes.html\#string-methods}{liste exhaustive dans la documentation}) :

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1489}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8511}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Méthode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{capitalize()} & Mise en majuscule du premier caractère et en minuscile du reste \\
\texttt{casefold()} & retire les distinctions de casse (utile pour la comparaison de chaînes sans faire attention à la casse) \\
\texttt{count()} & Compte le nombre d'occurrence (sans chevauchement) d'un motif \\
\texttt{encode()} & Encode une chaîne de caractères dans un encodage spécifique \\
\texttt{find()} & Retourne le plus petit indice où une sous-chaîne est trouvée \\
\texttt{lower()} & Retourne la chaîne en ayant passé chaque caractère alphabétique en minuscules \\
\texttt{replace()} & Remplace un motif par un autre \\
\texttt{split()} & Sépare la chaîne en sous-chaînes en fonction d'un motif \\
\texttt{title()} & Retourne la chaîne en ayant passé chaque première lettre de mot par une majuscule \\
\texttt{upper()} & Retourne la chaîne en ayant passé chaque caractère alphabétique en majuscules \\
\end{longtable}

\subsection{Conversion en chaînes de caractères}\label{conversion-chaines-caracteres}

Lorsque l'on veut concaténer une chaîne de caractères avec un nombre, Python retourne une erreur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nb\_followers }\OperatorTok{=} \DecValTok{0}
\NormalTok{message }\OperatorTok{=} \StringTok{"He has "} \OperatorTok{+}\NormalTok{ nb\_followers }\OperatorTok{+} \StringTok{"followers."}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## TypeError: can only concatenate str (not "int") to str
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(message)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## NameError: name 'message' is not defined
\end{lstlisting}

Il est alors nécessaire de convertir au préalable l'objet n'étant pas une chaîne en une chaîne de caractères. Pour ce faire, Python propose la fonction \texttt{str()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"He has "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(nb\_followers) }\OperatorTok{+} \StringTok{" followers."}
\BuiltInTok{print}\NormalTok{(message)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## He has 0 followers.
\end{lstlisting}

\subsection{Exercice}\label{exercice}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer deux variables nommées \texttt{a} et \texttt{b} afin qu'elles contiennent respectivement les chaînes de caractères suivantes : \texttt{23\ à\ 0} et \texttt{C\textquotesingle{}est\ la\ piquette,\ Jack!}.
\item
  Afficher le nombre de caractères de \texttt{a}, puis de \texttt{b}.
\item
  Concaténer \texttt{a} et \texttt{b} dans une seule chaîne de caractères, en ajoutant une virgule comme caractère de séparation.
\item
  Même question en choisissant une séparation permettant un retour à la ligne entre les deux phrases.
\item
  À l'aide de la méthode appropriée, mettre en majuscules \texttt{a} et \texttt{b}.
\item
  À l'aide de la méthode appropriée, mettre en minuscules \texttt{a} et \texttt{b}.
\item
  Extraire le mot \texttt{la} et \texttt{Jack} de la chaîne \texttt{b}, en utilisant les indices.
\item
  Rechercher si la sous-chaîne \texttt{piqu} est présente dans \texttt{b}, puis faire de même avec la sous-chaîne \texttt{mauvais}.
\item
  Retourner la position (indice) du premier caractère \texttt{a} retrouvé dans la chaîne \texttt{b}, puis essayer avec le caractère \texttt{w}.
\item
  Remplacer les occurrences du motif \texttt{a} par le motif \texttt{Z} dans la sous-chaîne \texttt{b}.
\item
  Séparer la chaîne \texttt{b} en utilisant la virgule comme séparateur de sous-chaînes.
\item
  (Bonus) Retirer tous les caractères de ponctuation de la chaîne b, puis utiliser une méthode appropriée pour retirer les caractères blancs en début et fin de chaîne. (Utiliser la librairie \texttt{regex}).
\end{enumerate}
\end{exframe}

\section{Valeurs numériques}\label{valeurs-numuxe9riques}

Il existe quatre catégories de nombres en Python : les entiers, les nombres à virgule flottante et les complèxes.

\subsection{Entiers}\label{entiers}

Les entiers (\texttt{ints}), en Python, sont des nombres entiers signés.

\begin{remarque}
On accède au type d'un objet à l'aide de la fonction \texttt{type()} en Python.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\NormalTok{y }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{2}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'int'>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'int'>
\end{lstlisting}

\subsection{Nombre à virgule flottante}\label{nombre-uxe0-virgule-flottante}

Les nombres à virgule flottante (\texttt{floats}) représentent les nombres réels. Ils sont écrits à l'aide d'un point permettant de distinguer la partie entière de la partie décimale du nombre.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{2.0}
\NormalTok{y }\OperatorTok{=} \FloatTok{48.15162342}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'float'>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'float'>
\end{lstlisting}

Il est également possible d'avoir recours aux notations scientifiques, en utilisant \texttt{E} ou \texttt{e} pour indiquer une puissance de 10. Par exemple, pour écrire \(3,2^{12}\), on procèdera comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{3.2E12}
\NormalTok{y }\OperatorTok{=} \FloatTok{3.2e12}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3200000000000.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3200000000000.0
\end{lstlisting}

Par ailleurs, lorsque le nombre est égal à une fraction de 0, on peut s'affranchir d'écrire le zéro :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.35}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0.35
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\FloatTok{.35}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0.35
\end{lstlisting}

\subsection{Nombres complèxes}\label{nombres-compluxe8xes}

Python permet nativement de manipuler des nombres complèxes, de la forme \(z=a+ib\), où \(a\) et \(b\) sont des nombres à virgule flottante, et tel que \(i^2=(-i)^2=1\). La partie réelle du nombre, \(\mathfrak{R}(z)\), est \(a\) tandis que sa partie imaginaire, \(\mathfrak{I}(z)\), est \(b\).

En python, l'unité imaginaire \(i\) est dénotée par la lettre \texttt{j}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \DecValTok{1}\OperatorTok{+}\OtherTok{3j}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1+3j)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(z))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'complex'>
\end{lstlisting}

Il est également possible d'utiliser la fonction \texttt{complex()}, qui demande deux paramètres (la partie réelle et la partie imaginaire) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \BuiltInTok{complex}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1+3j)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(z))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'complex'>
\end{lstlisting}

Plusieurs méthodes sont disponibles avec les nombres complèxes. Par exemple, pour accéder au conjugué, Python fournit la méthode \texttt{conjugate()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(z.conjugate())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1-3j)
\end{lstlisting}

L'accès à la partie réelle d'un complèxe ou à sa partie imaginaire s'effectue comme suit:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \BuiltInTok{complex}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z.real)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(z.imag)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3.0
\end{lstlisting}

\subsection{Conversions}\label{conversions}

Pour convertir un nombre dans un autre format numérique, Python dispose de quelques fonctions.

\subsubsection{Conversion en entier}\label{conversion-en-entier}

La \textbf{conversion d'un nombre ou d'une chaîne de caractères en entier} s'effectue à l'aide de la fonction \texttt{int()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"3"}
\NormalTok{x\_int }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x\_int))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'int'>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'str'>
\end{lstlisting}

On note que la conversion d'un nombre à virgule flottante tronque le nombre pour ne garder que la partie entière :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{3.6}
\NormalTok{x\_int }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(x\_int)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

\subsubsection{Conversion en nombre à virgule flottante}\label{conversion-en-nombre-uxe0-virgule-flottante}

Pour \textbf{convertir un nombre ou une chaîne de caractères en nombre à virgule flottante} (si possible), Python propose d'utiliser la fonction \texttt{float()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"3.6"}
\NormalTok{x\_float }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x\_float))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'float'>
\end{lstlisting}

Avec un entier à l'origine :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}
\NormalTok{x\_float }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(x\_float)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3.0
\end{lstlisting}

\subsubsection{Conversion en complèxe}\label{conversion-en-compluxe8xe}

La conversion d'un nombre ou d'une chaîne de caractères en nombre complèxe s'effectue avec la fonction \texttt{complex()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"2"}
\NormalTok{x\_complex }\OperatorTok{=} \BuiltInTok{complex}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(x\_complex)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (2+0j)
\end{lstlisting}

Avec un \emph{float} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{2.4}
\NormalTok{x\_complex }\OperatorTok{=} \BuiltInTok{complex}\NormalTok{(x)}
\BuiltInTok{print}\NormalTok{(x\_complex)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (2.4+0j)
\end{lstlisting}

\section{Booléens}\label{booluxe9ens}

Les données de type logique peuvent prendre deux valeurs : \texttt{True} ou \texttt{False}. Elles répondent
à une condition logique. Il faut faire attention à bien respecter la casse.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True False
\end{lstlisting}

\texttt{True} peut être converti automatiquement en 1 ; \texttt{False} en 0. Cela peut s'avérer très pratique, pour faire des comptages de valeurs vraies ou fausses dans les colonnes d'un tableau de données, par exemple.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OperatorTok{=} \VariableTok{True} \OperatorTok{+} \VariableTok{True} \OperatorTok{+} \VariableTok{False} \OperatorTok{+} \VariableTok{True}\OperatorTok{*}\VariableTok{True}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

\section{Objet vide}\label{objet-vide}

L'objet vide, communément appelé \texttt{null}, possède un équivalent en Python : \texttt{None}. Pour l'assigner à une variable, il faut faire attention à la casse :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'NoneType'>
\end{lstlisting}

L'objet \texttt{None} est une variable neutre, au comportement ``null''.

Pour tester si un objet est l'objet \texttt{None}, on procède comme suit (le résultat est un booléen) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}
\NormalTok{y }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{is} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y }\KeywordTok{is} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\section{Dates et temps}\label{dates-et-temps}

Il existe plusieurs moduels pour gérer les dates et le temps en Python. Nous allons explorer une partie du module \texttt{datetime}.

\subsection{Module datetime}\label{module-datetime}

Python possède un module appelé \texttt{datetime} qui offre la possibilité de manipuler des dates et des durées (\emph{dates} et \emph{times}).

Il existe plusieurs types d'objets désignant des dates :

\begin{itemize}
\tightlist
\item
  \texttt{date} : une date suivant le calendrier grégorien, renseignant l'année, le mois et le jour ;
\item
  \texttt{time} : un temp donné, sans prise en compte d'un jour particulier, renseignant l'heure, la minute, la seconde (possiblement la microseconde et le fuseau horaire également).
\item
  \texttt{datetime} : une date combinant \texttt{date} et \texttt{time} ;
\item
  \texttt{timedelta} : une durée entre deux objets de type \texttt{dates}, \texttt{time} ou \texttt{datetime} ;
\item
  \texttt{tzinfo} : un type de base abstraite, renseignant au sujet des fuseaux horaires ;
\item
  \texttt{timezone} : un type utilisant le type \texttt{tzinfo} comme un décalage fixe par rapport à l'UTC.
\end{itemize}

\subsubsection{Date}\label{type-date}

Les objets de type \texttt{date} désignent des dates du calendrier grégorien, pour lesquelles sont mentionnées les caractéristiques suivantes : l'année, le mois et le jour.

Pour créer un objet \texttt{date}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date(year, month, day)}
\end{Highlighting}
\end{Shaded}

Par exemple, pour créer la date renseignant le 23 avril 2013 :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ date}
\NormalTok{debut }\OperatorTok{=}\NormalTok{ date(year }\OperatorTok{=} \DecValTok{2013}\NormalTok{, month }\OperatorTok{=} \DecValTok{4}\NormalTok{, day }\OperatorTok{=} \DecValTok{23}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(debut)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-04-23
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(debut))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.date'>
\end{lstlisting}

\begin{remarque}
Il n'est pas obligatoire de préciser le nom des paramètres dans l'appel à la fonction \texttt{date}. L'ordre à respecter devra toutefois être le suivant : année, mois, jour.
\end{remarque}

On peut ensuite accéder aux attributs de la date créée (ce sont des entiers) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.year) }\CommentTok{\# Extraire l\textquotesingle{}année}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.month) }\CommentTok{\# Extraire le mois}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.day) }\CommentTok{\# Extraire le jour}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23
\end{lstlisting}

Les objets du type \texttt{date} possèdent quelques méthodes. Nous allons passer en revue quelques-unes d'entre-elles.

\paragraph{\texorpdfstring{\texttt{ctime()}}{ctime()}}\label{ctime}

La méthode \texttt{ctime()} retourne la date sous forme d'une chaîne de caractères.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.ctime())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tue Apr 23 00:00:00 2013
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{weekday()}}{weekday()}}\label{weekday}

La méthode \texttt{weekday()} retourne la position du jour de la semaine (lundi valant 0, dimanche 6)

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.weekday())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1
\end{lstlisting}

\begin{remarque}
Cette méthode peut être très pratique lors d'une analyse des données, pour explorer les aspects de saisonnalité hebdomadaire.
\end{remarque}

\paragraph{\texorpdfstring{\texttt{isoweekday()}}{isoweekday()}}\label{isoweekday}

Dans la même veine que \texttt{weekday()}, la méthode \texttt{isoweekday()} retourne la position du jour de la semaine, en attribuant cette fois la valeur 1 au lundi et 7 au dimanche.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.isoweekday())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{toordinal()}}{toordinal()}}\label{toordinal}

La méthode \texttt{toordinal()} retourne le numéro du jour, en prenant comme référence la valeur 1 pour le premier jour de l'an 1.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.toordinal())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 734981
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{isoformat()}}{isoformat()}}\label{isoformat}

La méthode \texttt{isoformat()} retourne la date en \href{https://fr.wikipedia.org/wiki/Num\%C3\%A9rotation_ISO_des_semaines}{numérotation ISO}, sous forme d'une chaîne de caractères.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.isoformat())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-04-23
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{isocalendar()}}{isocalendar()}}\label{isocalendar}

La méthode \texttt{isocalendar()} retourne un nuplet (c.f. Section~\ref{n-uplets-tuples}) comprenant trois éléments : l'année, le numéro de la semaine et le jour de la semaine (les trois en numérotation ISO).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.isocalendar())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## datetime.IsoCalendarDate(year=2013, week=17, weekday=2)
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{replace()}}{replace()}}\label{replace}

La méthode \texttt{replace()} retourne la date après avoir effectué une modification

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ debut.replace(year}\OperatorTok{=}\DecValTok{2014}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ debut.replace(month}\OperatorTok{=}\DecValTok{5}\NormalTok{)}
\NormalTok{z }\OperatorTok{=}\NormalTok{ debut.replace(day}\OperatorTok{=}\DecValTok{24}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x, y, z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2014-04-23 2013-05-23 2013-04-24
\end{lstlisting}

Cela n'a pas d'incidence sur l'objet d'origine :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-04-23
\end{lstlisting}

Il est possible de modifier plusieurs éléments en même temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ debut.replace(day}\OperatorTok{=}\DecValTok{24}\NormalTok{, month}\OperatorTok{=}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-05-24
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{strftime()}}{strftime()}}\label{strftime}

La méthode \texttt{strftime()} retourne, sous la forme d'une chaîne de caractères, une représentation de la date, selon un masque utilisé.

Par exemple, pour que la date soit représentée sous la forme \texttt{DD-MM-YYYY} (jour sur deux chiffres, mois sur deux chiffres et année sur 4) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.strftime(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{{-}\%m{-}\%Y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23-04-2013
\end{lstlisting}

Dans l'exemple précédent, on note deux choses : la présence de directives de formatage (qui commencent par le symbole de pourcentage) et des caractères autres (ici, les tirets). On peut noter que les caractères peuvent être remplacés par d'autres, il s'agit ici d'un choix pour représenter la date en séparant ses éléments par ddes tirets. Il est tout à fait possible d'adopter une autre écriture, par exemple avec des barres obliques, ou même d'autres chaînes de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.strftime(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{/\%m/\%Y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23/04/2013
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(debut.strftime(}\StringTok{"Jour : }\SpecialCharTok{\%d}\StringTok{, Mois : \%m, Annee : \%Y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Jour : 23, Mois : 04, Annee : 2013
\end{lstlisting}

Concernant les directives de formatage, elles correspondent aux codes requis par le standard C (c.f. la \href{https://docs.python.org/fr/3/library/datetime.html\#strftime-strptime-behavior}{documentation de Python}). En voici quelques-uns :

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.0988}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.6667}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2346}}@{}}
\caption{\label{tab:codes-formatage} Codes de formatages}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Exemple
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Exemple
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\%a} & Abréviation du jour de la semaine (dépend du lieu) & \texttt{Tue} \\
\texttt{\%A} & Jour de la semaine complet (dépend du lieu) & \texttt{Tuesday} \\
\texttt{\%b} & Abréviation du mois (dépend du lieu) & \texttt{Apr} \\
\texttt{\%B} & Nom du mois complet (dépend du lieu) octobre & \texttt{April} \\
\texttt{\%c} & Date et heure (dépend du lieu) au format \%a \%e \%b \%H:\%M:\%S:\%Y & \texttt{Tue\ Apr\ 23\ 00:00:00\ 2013} \\
\texttt{\%C} & Siècle (00-99) -1 (partie entière de la division de l'année par 100) & \texttt{20} \\
\texttt{\%d} & Jour du mois (01--31) & \texttt{23} \\
\texttt{\%D} & Date au format \%m/\%d/\%y & \texttt{04/23/13} \\
\texttt{\%e} & Jour du mois en nombre décimal (1--31) & \texttt{23} \\
\texttt{\%F} & Date au format \%Y-\%m-\%d & \texttt{2013-04-23} \\
\texttt{\%h} & Même chose que \%b & \texttt{Apr} \\
\texttt{\%H} & Heure (00--24) & \texttt{00} \\
\texttt{\%I} & Heure (01--12) & \texttt{12} \\
\texttt{\%j} & Jour de l'année (001--366) & \texttt{113} \\
\texttt{\%m} & Mois (01--12) & \texttt{04} \\
\texttt{\%M} & Minute (00-59) & \texttt{00} \\
\texttt{\%n} & Retour à la ligne en output, caractère blanc en input & \texttt{\textbackslash{}n} \\
\texttt{\%p} & AM/PM PM & \texttt{AM} \\
\texttt{\%r} & Heure au format 12 AM/PM & \texttt{12:00:00\ AM} \\
\texttt{\%R} & Même chose que \%H:\%M & \texttt{00:00} \\
\texttt{\%S} & Seconde (00-61) & \texttt{00} \\
\texttt{\%t} & Tabulation en output, caractère blanc en input & \texttt{\textbackslash{}t} \\
\texttt{\%T} & Même chose que \%H:\%M:\%S & \texttt{00:00:00} \\
\texttt{\%u} & Jour de la semaine (1--7), commence le lundi & \texttt{2} \\
\texttt{\%U} & Semaine de l'anné (00--53), dimanche comme début de semaine, et le premier dimanche de l'année définit la semaine & \texttt{16} \\
\texttt{\%V} & Semaine de l'année (00-53). Si la semaine (qui commence un lundi) qui contient le 1 er janvier a quatre jours ou plus dans la nouvelle année, alors elle est considérée comme la semaine 1. Sinon, elle est considérée comme la dernière de l'année précédente, et la semaine suivante est considérée comme semaine 1 (norme ISO 8601) & \texttt{17} \\
\texttt{\%w} & Jour de la semaine (0--6), dimanche étant 0 & \texttt{2} \\
\texttt{\%W} & Semaine de l'année (00--53), le lundi étant le premier jour de la semaine, et typiquement, le premier lundi de l'année définit la semaine 1 (conviention G.B.) & \texttt{16} \\
\texttt{\%x} & Date (dépend du lieu) & \texttt{04/23/13} \\
\texttt{\%X} & Heure (dépend du lieu) & \texttt{00:00:00\textquotesingle{}} \\
\texttt{\%y} & Année sans le ``siècle''\,'' (00--99) & \texttt{13} \\
\texttt{\%Y} & Année (en input, uniquement de 0 à 9999) & \texttt{2013} \\
\texttt{\%z} & offset en heures et minutes par rapport au temps UTC & \\
\texttt{\%Z} & Abréviation du fuseau horaire (en output seulement) CEST & \\
\end{longtable}

\subsubsection{Time}\label{type-time}

Les objets de type \texttt{time} désignent des temps précis sans prise en compte d'un jour particulier. Ils renseignant l'heure, la minute, la seconde (possiblement la microseconde et le fuseau horaire également).

Pour créer un objet \texttt{time}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time(hour, minute, second)}
\end{Highlighting}
\end{Shaded}

Par exemple, pour créer le moment 23:04:59 (vingt-trois heures, quatre minutes et cinquante-neuf secondes) :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ time}
\NormalTok{moment }\OperatorTok{=}\NormalTok{ time(hour }\OperatorTok{=} \DecValTok{23}\NormalTok{, minute }\OperatorTok{=} \DecValTok{4}\NormalTok{, second }\OperatorTok{=} \DecValTok{59}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(moment)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23:04:59
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(moment))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.time'>
\end{lstlisting}

On peut rajouter des informations sur la microseconde. Sa valeur doit être comprise entre zéro et un million.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{moment }\OperatorTok{=}\NormalTok{ time(hour }\OperatorTok{=} \DecValTok{23}\NormalTok{, minute }\OperatorTok{=} \DecValTok{4}\NormalTok{, second }\OperatorTok{=} \DecValTok{59}\NormalTok{, microsecond }\OperatorTok{=} \DecValTok{230}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(moment)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23:04:59.000230
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(moment))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.time'>
\end{lstlisting}

On peut ensuite accéder aux attributs de la date créée (ce sont des entiers), parmi lesquels :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(moment.hour) }\CommentTok{\# Extraire l\textquotesingle{}heure}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(moment.minute) }\CommentTok{\# Extraire la minute}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(moment.second) }\CommentTok{\# Extraire la seconde}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 59
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(moment.microsecond) }\CommentTok{\# Extraire la microseconde}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 230
\end{lstlisting}

Les objets du type \texttt{time} possèdent quelques méthodes, dont l'utilisation est similaire aux objets de classe \texttt{date} (se référer à la Section~\ref{type-date}).

\subsubsection{Datetime}\label{datetime}

Les objets de type \texttt{datetime} combinent les éléments des objets de type \texttt{date} et \texttt{time}. Ils renseignant le jour dans le calendrier grégorien ainsi que l'heure, la minute, la seconde (possiblement la microseconde et le fuseau horaire).

Pour créer un objet \texttt{datetime}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime(year, month, day, hour, minute, second, microsecond)}
\end{Highlighting}
\end{Shaded}

Par exemple, pour créer la date 23-04-2013 à 17:10:00 :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ datetime}
\NormalTok{x }\OperatorTok{=}\NormalTok{ datetime(year }\OperatorTok{=} \DecValTok{2013}\NormalTok{, month }\OperatorTok{=} \DecValTok{4}\NormalTok{, day }\OperatorTok{=} \DecValTok{23}\NormalTok{,}
\NormalTok{  hour }\OperatorTok{=} \DecValTok{23}\NormalTok{, minute }\OperatorTok{=} \DecValTok{4}\NormalTok{, second }\OperatorTok{=} \DecValTok{59}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-04-23 23:04:59
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.datetime'>
\end{lstlisting}

Les objets de type \texttt{datetime} disposent des attributs des objets de type \texttt{date} (c.f. Section~\ref{type-date}) et de type \texttt{time} (c.f. Section~\ref{type-time}).

Pour ce qui est des méthodes, davantage sont disponibles. Nous allons en commenter certaines.

\paragraph{\texorpdfstring{\texttt{today()} et \texttt{now()}}{today() et now()}}\label{today-et-now}

Les méthodes \texttt{today()} et \texttt{now()} retournent le \texttt{datetime} courant, celui au moment où est évaluée l'instruction :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.today())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2025-05-23 10:28:26.217827
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(datetime.today())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2025-05-23 10:28:26.219100
\end{lstlisting}

La distinction entre les deux réside dans le fuseau horaire. Avec \texttt{today()}, l'attribut \texttt{tzinfo} est mis à \texttt{None}, tandis qu'avec \texttt{now()}, l'attribut \texttt{tzinfo}, s'il est indiqué, est pris en compte.

\paragraph{\texorpdfstring{\texttt{timestamp()}}{timestamp()}}\label{timestamp}

La méthode \texttt{timestamp()} retourne, sous forme d'un nombre à virgule flottante, le \emph{timestamp} POSIX correspondant à l'objet de type \texttt{datetime}. Le \emph{timestamp} POSIX correspond à l'heure Posix, équivalent au nombre de secondes écoulées depuis le premier janvier 1970, à 00:00:00 UTC.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x.timestamp())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1366772699.0
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{date()}}{date()}}\label{date}

La méthode \texttt{date()} retourne un objet de type \texttt{date} dont les attributs d'année, de mois et de jour sont identiques à ceux de l'objet :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_date }\OperatorTok{=}\NormalTok{ x.date()}
\BuiltInTok{print}\NormalTok{(x\_date)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2013-04-23
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x\_date))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.date'>
\end{lstlisting}

\paragraph{\texorpdfstring{\texttt{time()}}{time()}}\label{time}

La méthode \texttt{time()} retourne un objet de type \texttt{time} dont les attributs d'heure, minute, seconde, microseconde sont identiques à ceux de l'objet :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_time }\OperatorTok{=}\NormalTok{ x.time()}
\BuiltInTok{print}\NormalTok{(x\_time)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 23:04:59
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(x\_time))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.time'>
\end{lstlisting}

\subsubsection{Timedelta}\label{timedelta}

Les objets de type \texttt{timedelta} représentent des durées séparant deux dates ou heures.

Pour créer un objet de type \texttt{timedelta}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{timedelta(days, hours, minutes, seconds, microseconds)}
\end{Highlighting}
\end{Shaded}

Il n'est pas obligatoire de fournir une valeur à chaque paramètre. Lorsque qu'un paramètre ne reçoit pas de valeur, celle qui lui est attribuée par défaut est 0.

Par exemple, pour créer un objet indiquant une durée de 1 jour et 30 secondes :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ timedelta}
\NormalTok{duree }\OperatorTok{=}\NormalTok{ timedelta(days }\OperatorTok{=} \DecValTok{1}\NormalTok{, seconds }\OperatorTok{=} \DecValTok{30}\NormalTok{)}
\NormalTok{duree}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## datetime.timedelta(days=1, seconds=30)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime.timedelta(}\DecValTok{1}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On peut accéder ensuite aux attributs (ayant été définis). Par exemple, pour accéder au nombre de jours que représente la durée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{duree.days}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}
\end{Highlighting}
\end{Shaded}

La méthode \texttt{total\_seconds()} permet d'obtenir la durée exprimée en secondes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{duree }\OperatorTok{=}\NormalTok{ timedelta(days }\OperatorTok{=} \DecValTok{1}\NormalTok{, seconds }\OperatorTok{=} \DecValTok{30}\NormalTok{, hours }\OperatorTok{=} \DecValTok{20}\NormalTok{)}
\NormalTok{duree.total\_seconds()}
\FloatTok{158430.0}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{Durée séparant deux objets \texttt{date} ou \texttt{datetime}}{Durée séparant deux objets date ou datetime}}\label{duruxe9e-suxe9parant-deux-objets-date-ou-datetime}

Lorsqu'on soustrait deux objets de type \texttt{date}, on obtient le nombre de jours séparant ces deux dates, sous la forme d'un objet de type \texttt{timedelta} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ timedelta}
\NormalTok{debut }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{fin }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{nb\_jours }\OperatorTok{=}\NormalTok{ fin}\OperatorTok{{-}}\NormalTok{debut}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(nb\_jours))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.timedelta'>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(nb\_jours)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1 day, 0:00:00
\end{lstlisting}

Lorsqu'on soustrait deux objets de type \texttt{datetime}, on obtient le nombre de jours, secondes (et microsecondes, si renseignées) séparant ces deux dates, sous la forme d'un objet de type \texttt{timedelta} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut }\OperatorTok{=}\NormalTok{ datetime(}\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{230}\NormalTok{)}
\NormalTok{fin }\OperatorTok{=}\NormalTok{ datetime(}\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{31}\NormalTok{)}
\NormalTok{duree }\OperatorTok{=}\NormalTok{ fin}\OperatorTok{{-}}\NormalTok{debut}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(duree))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'datetime.timedelta'>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(duree)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 22:48:00.999770
\end{lstlisting}

On peut noter que les durée données prennent en compte les années bissextiles. Regardons d'abord pour une année non-bissextile, le nombre de jours séparant le 28 février du premier mars :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2021}\NormalTok{, }\DecValTok{2}\NormalTok{,}\DecValTok{28}\NormalTok{)}
\NormalTok{fin }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2021}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{duree }\OperatorTok{=}\NormalTok{ fin }\OperatorTok{{-}}\NormalTok{ debut}
\NormalTok{duree}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime.timedelta(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Regardons à présent la même chose, mais dans le cas d'une année bissextile :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut\_biss }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2020}\NormalTok{, }\DecValTok{2}\NormalTok{,}\DecValTok{28}\NormalTok{)}
\NormalTok{fin\_biss }\OperatorTok{=}\NormalTok{ date(}\DecValTok{2020}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{duree\_biss }\OperatorTok{=}\NormalTok{ fin\_biss }\OperatorTok{{-}}\NormalTok{ debut\_biss}
\NormalTok{duree\_biss}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datetime.timedelta(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il est également possible d'\textbf{ajouter des durées à une date} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{debut }\OperatorTok{=}\NormalTok{ datetime(}\DecValTok{2018}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{59}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(debut }\OperatorTok{+}\NormalTok{ timedelta(seconds }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2019-01-01 00:00:00
\end{lstlisting}

\subsection{\texorpdfstring{Module \texttt{pytz}}{Module pytz}}\label{module-pytz}

Si la gestion des dates revêt une importance particulière, une librairie propose d'aller un peu plus loins, notamment en ce qui concerne la gestion des fuseaux horaires. Cette librarie s'appelle \texttt{pytz}. De nombreux exemples sont proposés sur \href{https://pypi.org/project/pytz/}{la page web du projet}.

\subsection{Exercices}\label{exercices}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  En utilisant la fonction appropriée, stocker la date du 29 août 2019 dans un objet que l'on appellera
  \texttt{d} puis afficher le type de l'objet.
\item
  À l'aide de la fonction appropriée, afficher la date du jour.
\item
  Stocker la date suivante dans un objet nommé \texttt{d2} : ``2019-08-29 20:30:56''. Puis, afficher dans la console avec la fonction \texttt{print()} les attributs d'année, de minute et de seconde de \texttt{d2}.
\item
  Ajouter 2 jours, 3 heures et 4 minutes à \texttt{d2}, et stocker le résultat dans un objet appelé \texttt{d3}.
\item
  Afficher la différence en secondes entre \texttt{d3} et \texttt{d2}.
\item
  À partir de l'objet \texttt{d2}, afficher sous forme de chaîne de caractères la date de \texttt{d2} de manière à ce qu'elle respecte la syntaxe suivante : ``Mois Jour, Année'', avec ``Mois'' le nom du mois (August), ``Jour'' le numéro du jour sur deux chiffres (29) et ``Année'' l'année de la date (2019).
\end{enumerate}
\end{exframe}

\chapter{Structures}\label{structures}

Python dispose de plusieurs structures différentes intégrées de base. Nous allons aborder dans cette partie quelques unes d'entre-elles : les listes, les N-uplet (ou \emph{tuples}), les ensembles et les dictionnaires.

\section{Listes}\label{structures-listes}

Une des structures les plus flexibles en Python est la liste. Il s'agit d'un regroupement de valeurs. La création d'une liste s'effectue en écrivant les valeurs en les séparant par une virgule et en entourant l'ensemble par des crochets (\texttt{{[}} et \texttt{{]}}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\StringTok{"Pascaline"}\NormalTok{, }\StringTok{"Gauthier"}\NormalTok{, }\StringTok{"Xuan"}\NormalTok{, }\StringTok{"Jimmy"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Pascaline', 'Gauthier', 'Xuan', 'Jimmy']
\end{lstlisting}

Le contenu d'une liste n'est pas forcément du texte :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 2, 3, 4, 5]
\end{lstlisting}

Il est même possible de faire figurer des éléments de type différent dans une liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=}\NormalTok{ [}\StringTok{"Piketty"}\NormalTok{, }\StringTok{"Thomas"}\NormalTok{, }\DecValTok{1971}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Piketty', 'Thomas', 1971]
\end{lstlisting}

Une liste peut contenir une autre liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweets }\OperatorTok{=}\NormalTok{ [}\StringTok{"aaa"}\NormalTok{, }\StringTok{"bbb"}\NormalTok{]}
\NormalTok{followers }\OperatorTok{=}\NormalTok{ [}\StringTok{"Anne"}\NormalTok{, }\StringTok{"Bob"}\NormalTok{, }\StringTok{"Irma"}\NormalTok{, }\StringTok{"John"}\NormalTok{]}
\NormalTok{compte }\OperatorTok{=}\NormalTok{ [tweets, followers]}
\BuiltInTok{print}\NormalTok{(compte)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [['aaa', 'bbb'], ['Anne', 'Bob', 'Irma', 'John']]
\end{lstlisting}

\subsection{Extraction des éléments}\label{structure-liste-extraction}

L'accès aux éléments se fait grace à son indexation (attention, l'indice du premier élément est 0) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{0}\NormalTok{]) }\CommentTok{\# Le premier élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Pascaline
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{1}\NormalTok{]) }\CommentTok{\# Le second élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Gauthier
\end{lstlisting}

L'accès à un élément peut aussi se faire en parant de la fin, en faisant figurer le signe moins (\texttt{-}) devant l'indice :
L'accès aux éléments se fait grace à son indexation (attention, l'indice du premier élément est 0) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]) }\CommentTok{\# Le dernier élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Jimmy
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]) }\CommentTok{\# L\textquotesingle{}avant dernier élément de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Xuan
\end{lstlisting}

Le découpage d'une liste de manière à obtenir un sous-ensemble de la liste s'effectue avec les deux points (\texttt{:}) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{]) }\CommentTok{\# Les premiers et seconds éléments de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Gauthier']
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{2}\NormalTok{:]) }\CommentTok{\# Du second (non inclus) à la fin de x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Xuan', 'Jimmy']
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[:}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]) }\CommentTok{\# Du premier à l\textquotesingle{}avant dernier (non inclus)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Pascaline', 'Gauthier']
\end{lstlisting}

\begin{remarque}
Le découpage retourne également une liste.
\end{remarque}

Lors de l'extraction des éléments de la liste à l'aide des crochets, il est possible de rajouter un troisième paramètre, le pas :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[::}\DecValTok{2}\NormalTok{]) }\CommentTok{\# Un élément sur deux}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Pascaline', 'Xuan']
\end{lstlisting}

L'accès à des listes imbriquées s'effectue en utilisant plusieurs fois les crochets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweets }\OperatorTok{=}\NormalTok{ [}\StringTok{"aaa"}\NormalTok{, }\StringTok{"bbb"}\NormalTok{]}
\NormalTok{followers }\OperatorTok{=}\NormalTok{ [}\StringTok{"Anne"}\NormalTok{, }\StringTok{"Bob"}\NormalTok{, }\StringTok{"Irma"}\NormalTok{, }\StringTok{"John"}\NormalTok{]}
\NormalTok{compte }\OperatorTok{=}\NormalTok{ [tweets, followers]}
\NormalTok{res }\OperatorTok{=}\NormalTok{ compte[}\DecValTok{1}\NormalTok{][}\DecValTok{3}\NormalTok{] }\CommentTok{\# Le 4e élément du 2e élément de la liste compte}
\end{Highlighting}
\end{Shaded}

Le \textbf{nombre d'éléments d'une liste} s'obtient avec la fonction \texttt{len()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(compte))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(compte[}\DecValTok{1}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\subsection{Modification}\label{modification}

Les listes sont mutables, c'est-à-dire que leur contenu peut être modifié une fois l'objet créé.

\subsubsection{Remplacement}\label{remplacement}

Pour \textbf{modifier} un élément dans une liste, on utilise l'indiçage :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{]}
\NormalTok{x[}\DecValTok{3}\NormalTok{] }\OperatorTok{=} \DecValTok{7} \CommentTok{\# Remplacement du 4e élément}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 3, 5, 7, 9]
\end{lstlisting}

\subsubsection{Ajout d'éléments}\label{ajout-duxe9luxe9ments}

Pour \textbf{ajouter des éléments à une liste}, on utilise la méthode \texttt{append()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x.append(}\DecValTok{11}\NormalTok{) }\CommentTok{\# Ajout de la valeur 11 en fin de liste}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 3, 5, 7, 9, 11]
\end{lstlisting}

Il est aussi possible d'utiliser la méthode \texttt{extend()}, pour concaténer des listes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{13}\NormalTok{, }\DecValTok{15}\NormalTok{]}
\NormalTok{x.extend(y)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 3, 5, 7, 9, 11, 13, 15]
\end{lstlisting}

\subsubsection{Suppression d'éléments}\label{suppression-duxe9luxe9ments}

Pour \textbf{retirer un élément d'une liste}, on utilise la méthode \texttt{remove()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x.remove(}\DecValTok{3}\NormalTok{) }\CommentTok{\# Retire le 4e élément}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 5, 7, 9, 11, 13, 15]
\end{lstlisting}

On peut aussi utiliser la commande \texttt{del} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{3}\NormalTok{] }\CommentTok{\# Retire le 4e élément}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 3, 5, 9]
\end{lstlisting}

\subsubsection{Affectations multiples}\label{affectations-multiples}

On peut modifier plusieurs valeurs en même temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{]}
\NormalTok{x[}\DecValTok{3}\NormalTok{:}\DecValTok{5}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{] }\CommentTok{\# Remplace les 4e et 5e valeurs}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 3, 5, 7, 9]
\end{lstlisting}

La modification peut agrandir la taille de la liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\NormalTok{x[}\DecValTok{2}\NormalTok{:}\DecValTok{3}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{] }\CommentTok{\# Remplace la 3e valeur}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 2, 'a', 'b', 'c', 'd', 4, 5]
\end{lstlisting}

On peut supprimer plusieurs valeurs en même temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\NormalTok{x[}\DecValTok{3}\NormalTok{:}\DecValTok{5}\NormalTok{] }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# Retire les 4e et 5e valeurs}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 2, 3]
\end{lstlisting}

\subsection{Test d'appartenance}\label{test-dappartenance}

En utilisant l'opérateur \texttt{in}, on peut tester l'appartenance d'un objet à une liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \KeywordTok{in}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\subsection{Copie de liste}\label{copie-de-liste}

Attention, la copie d'une liste n'est pas triviale en Python. Prenons un exemple.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

Modifions le premier élément de \texttt{y}, et observons le contenu de \texttt{y} et de \texttt{x} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0, 2, 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0, 2, 3]
\end{lstlisting}

Comme on peut le constater, le fait d'avoir utilisé le signe égal a simplement créé une référence et non pas une copie.

Pour effectuer une copie de liste, plusieurs façons existent. Parmi elles, l'utilisation de la fonction \texttt{list()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(x)}
\NormalTok{y[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x : "}\NormalTok{, x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x :  [1, 2, 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"y : "}\NormalTok{, y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y :  [0, 2, 3]
\end{lstlisting}

On peut noter que lorsque l'on fait un découpement, un nouvel objet est créé, pas une référence :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x[:}\DecValTok{2}\NormalTok{]}
\NormalTok{y[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x : "}\NormalTok{, x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x :  [1, 2, 3, 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"y : "}\NormalTok{, y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y :  [0, 2]
\end{lstlisting}

\subsection{Tri}\label{tri}

Pour trier les objets de la liste (sans en créer une nouvelle), Python propose la méthode \texttt{sort()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{x.sort()}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 2, 3, 4]
\end{lstlisting}

Cela fonctionne également avec des valeurs textuelles, en triant par ordre alphabétique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{]}
\NormalTok{x.sort()}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['a', 'a', 'b', 'c']
\end{lstlisting}

Il est possible de fournir à la méthode \texttt{sort()} des paramètres. Parmi ces paramètres, il en est un, \texttt{key}, qui permet de fournir une fonction pour effectuer le tri. Cette fonction doit retourner une valeur pour chaque objet de la liste, sur laquelle le tri sera effectué. Par exemple, avec la fonction \texttt{len()}, qui, lorsqu'appliquée à du texte, retourne le nombre de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\StringTok{"aa"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"aaaaa"}\NormalTok{, }\StringTok{"aa"}\NormalTok{]}
\NormalTok{x.sort(key}\OperatorTok{=}\BuiltInTok{len}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['a', 'aa', 'aa', 'aaaaa']
\end{lstlisting}

\section{N-uplets (Tuples)}\label{n-uplets-tuples}

Les n-uplets, ou \emph{tuples} sont des séquences d'objets Python.

Pour créer un n-uplet, on liste les valeurs, séparées par des virgules :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{25}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1, 4, 9, 16, 25)
\end{lstlisting}

On note que les n-uplets sont repérés par une suite de valeurs, entourées dans deux parenthèses.

\subsection{Extraction des éléments}\label{extraction-des-uxe9luxe9ments}

Les éléments d'un n-uplet s'extraient de la même manière que ceux des listes (c.f. Section~\ref{structure-liste-extraction}).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1
\end{lstlisting}

\subsection{Modification}\label{modification-1}

Contrairement aux listes, les n-uplets sont \textbf{inaltérables} (c'est-à-dire ne pouvant pas être modifés après avoir été créés) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## TypeError: 'tuple' object does not support item assignment
\end{lstlisting}

Il est possible d'\textbf{imbriquer des n-uplets} à l'intérieur d'un autre n-uplet. Pour ce faire, on a recours à l'utilisation de parenthèses :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ ((}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{16}\NormalTok{), (}\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{64}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ((1, 4, 9, 16), (1, 8, 26, 64))
\end{lstlisting}

\section{Ensembles}\label{structure-ensembles}

Les ensembles (\emph{sets}) sont des collections non ordonnée d'éléments uniques. Les ensembles sont inaltérables, et non indexés.

Pour créer un ensemble, Python fournit la fonction \texttt{set()}. On fournit un ou plusieurs éléments constituant l'ensemble, en les séparant par des virgules et en entourant l'ensemble d'accolades (\texttt{\{\}}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(\{}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix{-}en{-}Provence"}\NormalTok{, }\StringTok{"Nice"}\NormalTok{, }\StringTok{"Rennes"}\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Marseille', 'Nice', 'Aix-en-Provence'}
\end{lstlisting}

De manière équivalent, on peut ne pas utiliser la fonction \texttt{set()} et définir l'ensemble uniquement à l'aide des crochets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix{-}en{-}Provence"}\NormalTok{, }\StringTok{"Nice"}\NormalTok{, }\StringTok{"Rennes"}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

En revanche, si l'ensemble est vide, Python retourne un erreur si la fonction \texttt{set()} n'est pas utilisée :
il est nécessaire d'utiliser la fonction set :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble\_vide }\OperatorTok{=}\NormalTok{ \{\}}
\BuiltInTok{type}\NormalTok{(ensemble\_vide)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'dict'>
\end{lstlisting}

Le type de l'objet que l'on vient de créer n'est pas \texttt{set} mais \texttt{dict} (c.f. Section~\ref{type-dict}). Aussi, pour créer l'ensemble vide, on utilise \texttt{set()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble\_vide }\OperatorTok{=} \BuiltInTok{set}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(ensemble\_vide))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'set'>
\end{lstlisting}

Lors de la création, s'il existe des doublons dans les valeurs fournies, ils seront supprimés pour ne garder qu'une seule valeur :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(\{}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix{-}en{-}Provence"}\NormalTok{, }\StringTok{"Nice"}\NormalTok{, }\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Rennes"}\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

La longueur d'un ensemble s'obtient à l'aide de la fonction \texttt{len()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(ensemble))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\subsection{Modifications}\label{modifications}

\subsubsection{Ajout}\label{ajout}

Pour ajouter un élément à un ensemble, Python offre la méthode \texttt{add()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble.add(}\StringTok{"Toulon"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Toulon', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

Si l'élément est déjà présent, il ne sera pas ajouté :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble.add(}\StringTok{"Toulon"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Toulon', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

\subsubsection{Suppression}\label{suppression}

Pour supprimer une valeur d'un ensemble, Python propose la méthode \texttt{remove()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble.remove(}\StringTok{"Toulon"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

Si la valeur n'est pas présente dans l'ensemble, Python retourne un message d'erreur :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble.remove(}\StringTok{"Toulon"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## KeyError: 'Toulon'
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Rennes', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

\subsection{Test d'appartenance}\label{test-dappartenance-1}

Un des intérêts des ensembles est la recherche rapide de présence ou absence de valeurs (plus rapide que dans une liste). Comme pour les listes, les tests d'appartenance s'effectuent à l'aide de l'opérateur \texttt{in} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Marseille"} \KeywordTok{in}\NormalTok{ ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Paris"} \KeywordTok{in}\NormalTok{ ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\subsection{Copie d'ensemble}\label{copie-densemble}

Pour copier un ensemble, comme pour les listes (c.f. Section~\ref{copie-de-liste}), il ne faut pas utiliser le signe d'égalité. La copie d'un ensemble se fait à l'aide de la méthode \texttt{copy()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ensemble }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(\{}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix{-}en{-}Provence"}\NormalTok{, }\StringTok{"Nice"}\NormalTok{\})}
\NormalTok{y }\OperatorTok{=}\NormalTok{ ensemble.copy()}
\NormalTok{y.add(}\StringTok{"Toulon"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"y : "}\NormalTok{, y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y :  {'Toulon', 'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"ensemble : "}\NormalTok{, ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ensemble :  {'Aix-en-Provence', 'Nice', 'Marseille'}
\end{lstlisting}

\subsection{Conversion en liste}\label{conversion-en-liste}

Un des intérêts des ensembles est est qu'ils contiennent des éléments uniques. Aussi, lorsque l'on souhaite obtenir les éléments distincts d'une liste, il est possible de la convertir en ensemble (avec la fonction \texttt{set()}), puis de convertir l'ensemble en liste (avec la fonction \texttt{list()}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma\_liste }\OperatorTok{=}\NormalTok{ [}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix{-}en{-}Provence"}\NormalTok{, }\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Marseille"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(ma\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Marseille', 'Aix-en-Provence', 'Marseille', 'Marseille']
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_ensemble }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(ma\_liste)}
\BuiltInTok{print}\NormalTok{(mon\_ensemble)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Aix-en-Provence', 'Marseille'}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma\_nouvelle\_liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(mon\_ensemble)}
\BuiltInTok{print}\NormalTok{(ma\_nouvelle\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Aix-en-Provence', 'Marseille']
\end{lstlisting}

\section{Dictionnaires}\label{type-dict}

Les dictionnaires en Python sont une implémentation d'objets clé-valeurs, les clés étant indexées.

Les clés sont souvent du texte, les valeurs peuvent être de différents types et différentes structures.

Pour créer un dictionnaire, on peut procéder en utilisant des accolades (\texttt{\{\}}). Comme rencontré dans la Section~\ref{structure-ensembles}, si on évalue le code suivant, on obtient un dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dict\_vide }\OperatorTok{=}\NormalTok{ \{\}}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(dict\_vide))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'dict'>
\end{lstlisting}

Pour créer un dictionnaire avec des entrée, on peut utiliser les accolades, on sépare chaque entrée par des virgules, et on distingue la clé de la valeur associée par deux points (\texttt{:}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_dict }\OperatorTok{=}\NormalTok{ \{ }\StringTok{"nom"}\NormalTok{: }\StringTok{"Kyrie"}\NormalTok{,}
  \StringTok{"prenom"}\NormalTok{: }\StringTok{"John"}\NormalTok{,}
  \StringTok{"naissance"}\NormalTok{: }\DecValTok{1992}\NormalTok{,}
  \StringTok{"equipes"}\NormalTok{: [}\StringTok{"Cleveland"}\NormalTok{, }\StringTok{"Boston"}\NormalTok{]\}}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Cleveland', 'Boston']}
\end{lstlisting}

Il est aussi possible de créer un dictionnaire à l'aide de la fonction \texttt{dict()}, en fournissant une séquence de clés-valeurs :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \BuiltInTok{dict}\NormalTok{([(}\StringTok{"Julien{-}Yacine"}\NormalTok{, }\StringTok{"Data{-}scientist"}\NormalTok{),}
\NormalTok{  (}\StringTok{"Sonia"}\NormalTok{, }\StringTok{"Directrice"}\NormalTok{)])}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'Julien-Yacine': 'Data-scientist', 'Sonia': 'Directrice'}
\end{lstlisting}

\subsection{Extraction des éléments}\label{extraction-des-uxe9luxe9ments-1}

L'extraction dans les dictionnaires repose sur le même principe que pour les listes et les n-uplets (c.f. Section~\ref{structure-liste-extraction}). Toutefois, l'extraction d'un élément d'un dictionnaire ne se fait pas en fonction de sa position dans le dictionnaire, mais par sa clé :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict[}\StringTok{"prenom"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## John
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict[}\StringTok{"equipes"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Cleveland', 'Boston']
\end{lstlisting}

Si l'extraction s'effectue par une clé non présente dans le dictionnaire, une erreur sera retournée :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict[}\StringTok{"age"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## KeyError: 'age'
\end{lstlisting}

On peut tester la présence d'une clé avec l'opérateur \texttt{in} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"prenom"} \KeywordTok{in}\NormalTok{ mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"age"} \KeywordTok{in}\NormalTok{ mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

L'extraction de valeurs peut aussi se faire à l'aide de la méthode \texttt{get()}, qui retourne une valeur \texttt{None} si la clé n'est pas présente :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict.get(}\StringTok{"prenom"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## John
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict.get(}\StringTok{"age"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\subsection{Clés et valeurs}\label{cluxe9s-et-valeurs}

À l'aide de la méthode \texttt{key()}, on peut accéder aux clés du dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{les\_cles }\OperatorTok{=}\NormalTok{ mon\_dict.keys()}
\BuiltInTok{print}\NormalTok{(les\_cles)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## dict_keys(['nom', 'prenom', 'naissance', 'equipes'])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(les\_cles))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'dict_keys'>
\end{lstlisting}

Il est possible par la suite de transformer cette énumération de clés en liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{les\_cles\_liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(les\_cles)}
\BuiltInTok{print}\NormalTok{(les\_cles\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['nom', 'prenom', 'naissance', 'equipes']
\end{lstlisting}

La méthode \texttt{values()} fournit quand à elle les valeurs du dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{les\_valeurs }\OperatorTok{=}\NormalTok{ mon\_dict.values()}
\BuiltInTok{print}\NormalTok{(les\_valeurs)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## dict_values(['Kyrie', 'John', 1992, ['Cleveland', 'Boston']])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(les\_valeurs))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'dict_values'>
\end{lstlisting}

La méthode \texttt{items()} fournit quand à elle les clés et valeurs sous forme de n-uplets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{les\_items }\OperatorTok{=}\NormalTok{ mon\_dict.items()}
\BuiltInTok{print}\NormalTok{(les\_items)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## dict_items([('nom', 'Kyrie'), ('prenom', 'John'), ('naissance', 1992), ('equipes', ['Cleveland', 'Boston'])])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(les\_items))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'dict_items'>
\end{lstlisting}

\subsection{Recherche d'appartenance}\label{recherche-dappartenance}

Grâce aux méthodes \texttt{keys()}, \texttt{values()} et \texttt{items()}, il est aisé de rechercher la présence d'objets dans un dictionnaire.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"age"} \KeywordTok{in}\NormalTok{ les\_cles)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"nom"} \KeywordTok{in}\NormalTok{ les\_cles)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{([}\StringTok{\textquotesingle{}Cleveland\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Boston\textquotesingle{}}\NormalTok{] }\KeywordTok{in}\NormalTok{ les\_valeurs)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\subsection{Modification}\label{modification-2}

\subsubsection{Remplacement}\label{remplacement-1}

Pour remplacer la valeur associée à une clé, on peut utiliser les crochets (\texttt{{[}{]}}) et le signe d'égalité (\texttt{=}).

Par exemple, pour remplacer les valeurs associées à la clé \texttt{equipes} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_dict[}\StringTok{"equipes"}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\StringTok{"Montclair Kimberley Academy"}\NormalTok{,}
  \StringTok{"Cleveland Cavaliers"}\NormalTok{, }\StringTok{"Boston Celtics"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics']}
\end{lstlisting}

\subsubsection{Ajout d'éléments}\label{ajout-duxe9luxe9ments-1}

L'ajout d'un élément dans un dictionnaire peut s'effectuer avec les crochets (\texttt{{[}{]}}) et le signe d'égalité (\texttt{=}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_dict[}\StringTok{"taille\_cm"}\NormalTok{] }\OperatorTok{=} \DecValTok{191}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics'], 'taille_cm': 191}
\end{lstlisting}

Pour ajouter le contenu d'un autre dictionnaire à un dictionnaire, Python propose la méthode \texttt{update()}.

Créons un second dictionnaire dans un premier temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second\_dict }\OperatorTok{=}\NormalTok{ \{}\StringTok{"masse\_kg"}\NormalTok{ : }\DecValTok{88}\NormalTok{, }\StringTok{"debut\_nba"}\NormalTok{ : }\DecValTok{2011}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(second\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'masse_kg': 88, 'debut_nba': 2011}
\end{lstlisting}

Ajoutons le contenu de ce second dictionnaire au premier :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_dict.update(second\_dict)}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics'], 'taille_cm': 191, 'masse_kg': 88, 'debut_nba': 2011}
\end{lstlisting}

Si on modifie par la suite le second dictionnaire, cela n'aura pas d'incidence sur le premier :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second\_dict[}\StringTok{"poste"}\NormalTok{] }\OperatorTok{=} \StringTok{"PG"}
\BuiltInTok{print}\NormalTok{(second\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'masse_kg': 88, 'debut_nba': 2011, 'poste': 'PG'}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics'], 'taille_cm': 191, 'masse_kg': 88, 'debut_nba': 2011}
\end{lstlisting}

\subsubsection{Suppression d'éléments}\label{suppression-duxe9luxe9ments-1}

La suppression d'un élément dans un dictionnaire peut s'effectuer de plusieurs manières. Par exemple, avec l'opérateur \texttt{del} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{del}\NormalTok{ mon\_dict[}\StringTok{"debut\_nba"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics'], 'taille_cm': 191, 'masse_kg': 88}
\end{lstlisting}

Il est également possible d'utiliser la méthode \texttt{pop()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OperatorTok{=}\NormalTok{ mon\_dict.pop(}\StringTok{"masse\_kg"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(mon\_dict)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'nom': 'Kyrie', 'prenom': 'John', 'naissance': 1992, 'equipes': ['Montclair Kimberley Academy', 'Cleveland Cavaliers', 'Boston Celtics'], 'taille_cm': 191}
\end{lstlisting}

Dans l'instruction précédente, nous avons ajouté une assignation du résultat de l'appliation de la méthode \texttt{pop()} à une variable nommée \texttt{res}. Comme on peut le constater, la méthode \texttt{pop()}, en plus d'avoir supprimé la clé, a retourné la valeur associée :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 88
\end{lstlisting}

\subsection{Copie de dictionnaire}\label{copie-de-dictionnaire}

Pour copier un dictionnaire, et non créer une référence (ce qui est le cas si on utilise le signe d'égalité), Python fournit comme pour les ensembles, une méthode \texttt{copy()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Marseille"}\NormalTok{: }\DecValTok{13}\NormalTok{, }\StringTok{"Rennes"}\NormalTok{ : }\DecValTok{35}\NormalTok{\}}
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ d.copy()}
\NormalTok{d2[}\StringTok{"Paris"}\NormalTok{] }\OperatorTok{=} \DecValTok{75}
\BuiltInTok{print}\NormalTok{(}\StringTok{"d: "}\NormalTok{, d)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## d:  {'Marseille': 13, 'Rennes': 35}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"d2: "}\NormalTok{, d2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## d2:  {'Marseille': 13, 'Rennes': 35, 'Paris': 75}
\end{lstlisting}

\subsection{Exercice}\label{exercice-1}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Créer un dictionnaire nommé \texttt{photo}, comprenant les couples clés-valeurs suivants :
\item
  clé : \texttt{id}, valeur : \texttt{1},
\item
  clé : \texttt{description}, valeur : \texttt{Une\ photo\ du\ Vieux-port\ de\ Marseille},
\item
  clé : \texttt{loc}, valeur : une liste dans laquelle sont données les coordonnées suivantes \texttt{5.3772133}, \texttt{43.302424}.
  2.Ajouter le couple de clé-valeur suivant au dictionnaire \texttt{photo} : clé : \texttt{utilisateur}, valeur : \texttt{bob}.
\item
  Rechercher s'il existe une entrée dont la clé vaut \texttt{description} dans le dictionnaire \texttt{photo}. Si tel est le cas, afficher l'entrée correspondante (clé et valeur).
\item
  Supprimer l'entrée dans \texttt{photo} dont la clé vaut \texttt{utilisateur}.
\item
  Modifier la valeur de l'entrée \texttt{loc} dans le dictionnaire \texttt{photo}, pour proposer une nouvelle liste, dont les coordonnées sont les suivantes : \texttt{5.3692712} et \texttt{43.2949627}.
\end{enumerate}
\end{exframe}

\chapter{Opérateurs}\label{opuxe9rateurs}

Python comprend différents opérateurs, permettant d'effectuer des opérations entre les opérandes, c'est-à-dire entre des variables, des littéraux ou encore des expressions.

\section{Opérateurs arithmétiques}\label{operateurs-arithmetiques}

Les opérateurs arithmétiques de base sont intégrés dans Python.

Nous avons déjà utilisé dans les chapitres précédents certains d'entre eux, pour effectuer des opérations sur les entiers ou les nombres à virgule flotante (addition, soustraction, etc.). Faisons un tour rapide des opérateurs arithmétiques les plus courants permettant de réaliser des opérations sur des nombres.

\subsection{Addition}\label{addition}

On effectue une addition entre deux nombres à l'aide du symbole \texttt{+} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\OperatorTok{+}\DecValTok{1}\NormalTok{) }\CommentTok{\# Addition}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2
\end{lstlisting}

\subsection{Soustraction}\label{soustraction}

On effectue une soustraction entre deux nombres à l'aide du symbole \texttt{-} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\OperatorTok{{-}}\DecValTok{1}\NormalTok{) }\CommentTok{\# Soustraction}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0
\end{lstlisting}

\subsection{Multiplication}\label{multiplication}

On effectue une multiplication entre deux nombres à l'aide du symbole \texttt{*} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\DecValTok{2}\NormalTok{) }\CommentTok{\# Multiplication}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\subsection{Division}\label{division}

On effectue une division (réelle) entre deux nombres à l'aide du symbole \texttt{/} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{3}\OperatorTok{/}\DecValTok{2}\NormalTok{) }\CommentTok{\# Division}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1.5
\end{lstlisting}

Pour effectuer une division entière, on double la barre oblique :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{3}\OperatorTok{//}\DecValTok{2}\NormalTok{) }\CommentTok{\# Division entière}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1
\end{lstlisting}

\subsection{Modulo}\label{modulo}

Le modulo (reste de la division euclidienne) s'obtient à l'aide du symbole \texttt{\%} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{12}\OperatorTok{\%}\DecValTok{10}\NormalTok{) }\CommentTok{\# Modulo}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2
\end{lstlisting}

\subsection{Puissance}\label{puissance}

Pour élever un nombre à une puissance données, on utilise deux étoiles (\texttt{**}) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{2}\OperatorTok{**}\DecValTok{3}\NormalTok{) }\CommentTok{\# 2 élevé à la puissance 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 8
\end{lstlisting}

\subsection{Ordre}\label{ordre}

L'ordre des opérations suit la règle PEMDAS (\emph{Parentheses}, \emph{Exponents}, \emph{Multiplication and Division}, \emph{Addition and Subtraction}).

Par exemple, l'instruction suivante effectue d'abord le calcul \(2\times 2\), puis ajoute \(1\) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\DecValTok{2}\OperatorTok{+}\DecValTok{1}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 5
\end{lstlisting}

L'instruction suivante, grâce aux parenthèses, effectue d'abord le calcul \(2+1\), puis la multiplication du résultat avec \(2\) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{(}\DecValTok{2}\OperatorTok{+}\DecValTok{1}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 6
\end{lstlisting}

\subsection{Opérateurs mathématiques sur des chaînes de caractères}\label{opuxe9rateurs-mathuxe9matiques-sur-des-chauxeenes-de-caractuxe8res}

Certains opérateurs mathématiques présentés dans la Section~\ref{operateurs-arithmetiques} peuvent-être appliquées à des chaînes de caractères.

Lorsque l'on utilise le symbole \texttt{+} entre deux chaînes de caractères, Python concatène ces deux chaînes (cf.~Section~\ref{type-chaines-concatenation}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \StringTok{"euro"}
\NormalTok{b }\OperatorTok{=} \StringTok{"dollar"}
\BuiltInTok{print}\NormalTok{(a}\OperatorTok{+}\NormalTok{b)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## eurodollar
\end{lstlisting}

Lorsqu'on ``multiplie'' une chaîne par un scalaire \(n\), Python répète la chaîne le nombre \(n\) fois :

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\OperatorTok{*}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 'euroeuro'
\end{lstlisting}

\subsection{Opérateurs mathématiques sur des listes ou des n-uplets}\label{opuxe9rateurs-mathuxe9matiques-sur-des-listes-ou-des-n-uplets}

Certains opérateurs mathématiques peuvent également être appliquées à des listes.

Lorsque l'on utilise le symble \texttt{+} entre deux listes, Python les concatène en une seule :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l\_1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{"pomme"}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{l\_2 }\OperatorTok{=}\NormalTok{ [}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(l\_1 }\OperatorTok{+}\NormalTok{ l\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 'pomme', 5, 7, 9, 11]
\end{lstlisting}

Idem avec des n-uplets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\StringTok{"pomme"}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(t\_1 }\OperatorTok{+}\NormalTok{ t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1, 'pomme', 5, 7, 9, 11)
\end{lstlisting}

En ``multipliant'' une liste par un scalaire \(n\), Python répète \(n\) fois cette liste :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{3}\OperatorTok{*}\NormalTok{l\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1, 'pomme', 5, 7, 1, 'pomme', 5, 7, 1, 'pomme', 5, 7]
\end{lstlisting}

Idem avec des n-uplets :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{3}\OperatorTok{*}\NormalTok{t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (1, 'pomme', 5, 7, 1, 'pomme', 5, 7, 1, 'pomme', 5, 7)
\end{lstlisting}

\section{Opérateurs de comparaison}\label{operateurs-comparaison}

Les opérateurs de comparaisons permettent de comparer entre eux des objets de tous les types de base. Le résultat d'un test de comparaison produit des valeurs booléennes.

\begin{longtable}[]{@{}rrr@{}}
\caption{\label{tab:operateurs-comparaison} Opérateurs de comparaison}\tabularnewline
\toprule\noalign{}
Opérateur & Opérateur en Python & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Opérateur & Opérateur en Python & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(=\) & \texttt{==} & Égal à \\
\(\ne\) & \texttt{!=} (ou \texttt{\textless{}\textgreater{}}) & Différent de \\
\(>\) & \texttt{\textgreater{}} & Supérieur à \\
\(\geq\) & \texttt{\textgreater{}=} & \& Supérieur ou égal à \\
\(<\) & \texttt{\textless{}} & Inférieur à \\
\(\leq\) & \texttt{\textless{}=} & Inférieur ou égal à \\
\(\in\) & \texttt{in} & Dans \\
\(\notin\) & \texttt{not\ in} & Exclu \\
\end{longtable}

\subsection{Égalité, inégalité}\label{uxe9galituxe9-inuxe9galituxe9}

Pour tester l'égalité de contenu entre deux objets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \StringTok{"Hello"}
\NormalTok{b }\OperatorTok{=} \StringTok{"World"}
\NormalTok{c }\OperatorTok{=} \StringTok{"World"}

\BuiltInTok{print}\NormalTok{(a }\OperatorTok{==}\NormalTok{ c)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(b }\OperatorTok{==}\NormalTok{ c)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

L'inégalité entre deux objets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\NormalTok{z }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(x }\OperatorTok{!=}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{!=}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\subsection{Infériorité et supériorité, stricts ou larges}\label{infuxe9riorituxe9-et-supuxe9riorituxe9-stricts-ou-larges}

Pour savoir si un objet est inférieur (strictement ou non) ou inférieur (strictement ou non) à un autre :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}
\NormalTok{y }\OperatorTok{=} \DecValTok{1}
\NormalTok{z }\OperatorTok{=} \DecValTok{2}

\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}=}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textgreater{}}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textgreater{}=}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

On peut également effectuer la comparaison entre deux chaînes de caractères. La comparaison s'effectue en fonction de l'ordre lexicographique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_1 }\OperatorTok{=} \StringTok{"mange"}
\NormalTok{m\_2 }\OperatorTok{=} \StringTok{"manger"}
\NormalTok{m\_3 }\OperatorTok{=} \StringTok{"boire"}
\BuiltInTok{print}\NormalTok{(m\_1 }\OperatorTok{\textless{}}\NormalTok{ m\_2) }\CommentTok{\# mange avant manger}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(m\_3 }\OperatorTok{\textgreater{}}\NormalTok{ m\_1) }\CommentTok{\# boire avant manger}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

Lorsque l'on compare deux listes entre-elles, Python fonctionne pas à pas. Regardons à travers un exemple comment cette comparaison est effectuée.

Créons deux listes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Python va commencer par comparer les premiers éléments de chaque liste (ici, c'est possible, les deux éléments sont comparables ; dans le cas contraire, une erreur serait retournée) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Comme \texttt{1\textless{}9}, Python retourne \texttt{True}.

Changeons \texttt{x} pour que le premier élément soit supérieur au premier de \texttt{y}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

Cette fois, comme \(10>9\), Python retourne \texttt{False}.

Changeons à présent le premier élément de \texttt{x} pour qu'ils soit égal à celui de \texttt{y} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Cette fois, Python compare le premier élement de \texttt{x} avec celui de \texttt{y}, comme les deux sont identiques, les seconds éléments sont comparés. On peut s'en convaincre en évaluant le code suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x }\OperatorTok{\textless{}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\subsection{Inclusion et exclusion}\label{inclusion-et-exclusion}

Comme rencontré plusieurs fois dans le Chapitre~\ref{structures}, les tests d'inclusions s'effectuent à l'aide de l'opérateur \texttt{in}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{3} \KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Pour tester si un élément est exclu d'une liste, d'un n-uplet, dictionnaire, etc., on utilise \texttt{not\ in} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{4} \KeywordTok{not} \KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{4} \KeywordTok{not} \KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

Avec un dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionnaire }\OperatorTok{=}\NormalTok{ \{}\StringTok{"nom"}\NormalTok{: }\StringTok{"Rockwell"}\NormalTok{, }\StringTok{"prenom"}\NormalTok{: }\StringTok{"Criquette"}\NormalTok{\}}
\CommentTok{"age"} \KeywordTok{not} \KeywordTok{in}\NormalTok{ dictionnaire.keys()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\section{Opérateurs logiques}\label{operateurs-logiques}

Les opérateurs logiques opèrent sur un ou plusieurs objets de type logique (des booléens).

\subsection{Et logique}\label{et-logique}

L'opérateur \texttt{and} permet d'effectuer des comparaisons ``ET'' logiques. On compare deux objets, \texttt{x} et \texttt{y} (ces objets peuvent résulter d'une comparaison préalable, il suffit juste que tous deux soient des booléens).

Si l'un des deux objets \texttt{x} et \texttt{y} est vrai, la comparaison ``ET'' logique retourne vrai :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{True}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{and}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Si au moins l'un des deux est faux, la comparaison ``ET'' logique retourne faux :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}

\BuiltInTok{print}\NormalTok{(x }\KeywordTok{and}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y }\KeywordTok{and}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

Si un des deux objets comparés vaut la valeur vide (\texttt{None}), alors la comparaison ``ET'' logique retourne :

\begin{itemize}
\tightlist
\item
  la valeur \texttt{None} si l'autre objet vaut \texttt{True} ou \texttt{None} ;
\item
  la valeur \texttt{False} si l'autre objet vaut \texttt{False}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\NormalTok{z }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{and}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y }\KeywordTok{and}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(z }\KeywordTok{and}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\subsection{Ou logique}\label{ou-logique}

L'opérateur \texttt{or} permet d'effectuer des comparaisons ``OU'' logiques. À nouveau, on compare deux booléens, \texttt{x} et \texttt{y}.

Si au moins un des deux objets \texttt{x} et \texttt{y} est vrai, la comparaison ``OU'' logique retourne vrai :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{or}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Si les deux sont faux, la comparaison ``OU'' logique retourne faux :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{False}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{or}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

Si l'un des deux objets vaut \texttt{None}, la comparaison ``OU'' logique retourne :

\begin{itemize}
\tightlist
\item
  \texttt{True} si l'autre objet vaut \texttt{True} ;
\item
  \texttt{None} si l'autre objet vaut \texttt{False} ou \texttt{None}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\NormalTok{z }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(x }\KeywordTok{or}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y }\KeywordTok{or}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(z }\KeywordTok{or}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\subsection{Non logique}\label{non-logique}

L'opérateur \texttt{not}, lorsqu'appliqué à un booléen, évalue ce dernier à sa valeur opposée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{True}
\NormalTok{y }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(}\KeywordTok{not}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\KeywordTok{not}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

Lorsque l'on utilise l'opérateur \texttt{not} sur une valeur vide (\texttt{None}), Python retourne \texttt{True} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \VariableTok{None}
\KeywordTok{not}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\section{Quelques fonctions}\label{quelques-fonctions}

Python dispose de nombreuses fonctions utiles pour manipuler les structures et données. Le tableau suivant en répertorie quelques-unes. Certaines nécessitent le chargement de la librairie \texttt{math}, d'autres la librairie \texttt{statistics}. Nous verrsons d'autres fonctions propres à la librairie \texttt{NumPy} au Chapitre~\ref{numpy}.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2500}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7500}}@{}}
\caption{\label{tab:fonctions-numeriques} Quelques fonctions numériques}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Fonction
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Fonction
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{math.ceil(x)} & Plus petit entier supérieur ou égal à \texttt{x} \\
\texttt{math.copysign(x,\ y)} & Valeur absolue de \texttt{x} mais avec le signe de \texttt{y} \\
\texttt{math.floor(x)} & Plus grand entier inférieur ou égal à \texttt{x} \\
\texttt{math.round(x,\ ndigits)} & Arrondi de \texttt{x} à \texttt{ndigits} décimales près \\
\texttt{math.fabs(x)} & Valeur absolue de \texttt{x} \\
\texttt{math.exp(x)} & Exponentielle de \texttt{x} \\
\texttt{math.log(x)} & Logarithme naturel de \texttt{x} (en base e) \\
\texttt{math.log(x,\ b)} & Logarithme en base \texttt{b} de \texttt{x} \\
\texttt{math.log10(x)} & Logarithme en base 10 de \texttt{x} \\
\texttt{math.pow(x,y)} & \texttt{x} élevé à la puissance \texttt{y} \\
\texttt{math.sqrt(x)} & Racine carrée de \texttt{x} \\
\texttt{math.fsum()} & Somme des valeurs de \texttt{x} \\
\texttt{math.sin(x)} & Sinus de \texttt{x} \\
\texttt{math.cos(x)} & Cosinus de \texttt{x} \\
\texttt{math.tan(x)} & Tangente de \texttt{x} \\
\texttt{math.asin(x)} & Arc-sinus de \texttt{x} \\
\texttt{math.acos(x)} & Arc-cosinus de \texttt{x} \\
\texttt{math.atan(x)} & Arc-tangente de \texttt{x} \\
\texttt{math.sinh(x)} & Sinus hyperbolique de \texttt{x} \\
\texttt{math.cosh(x)} & Cosinus hyperbolique de \texttt{x} \\
\texttt{math.tanh(x)} & Tangente hyperbolique de \texttt{x} \\
\texttt{math.asinh(x)} & Arc-sinus hyperbolique de \texttt{x} \\
\texttt{math.acosh(x)} & Arc-cosinus hyperbolique de \texttt{x} \\
\texttt{math.atanh(x)} & Arc-tangente hyperbolique de \texttt{x} \\
\texttt{math.degree(x)} & Conversion de \texttt{x} de radians en degrés \\
\texttt{math.radians(x)} & Conversion de \texttt{x} de degrés en radians \\
\texttt{math.factorial()} & Factorielle de \texttt{x} \\
\texttt{math.gcd(x,\ y)} & Plus grand commun diviseur de \texttt{x} et \texttt{y} \\
\texttt{math.isclose(x,\ y,\ rel\_tol=1e-09,\ abs\_tol=0.0)} & Compare \texttt{x} et \texttt{y} et retourne s'ils sont proches au reard de la tolérance \texttt{rel\_tol} (\texttt{abs\_tol} est la tolérance minimum absolue) \\
\texttt{math.isfinite(x)} & Retourne \texttt{True} si \texttt{x} est soit l'infini, soir \texttt{NaN} \\
\texttt{math.isinf(x)} & Retourne \texttt{True} si \texttt{x} est l'infini, \texttt{False} sinon \\
\texttt{math.isnan(x)} & Retourne \texttt{True} si \texttt{x} est \texttt{NaN}, \texttt{False} sinon \\
\texttt{statistics.mean(x)} & Moyenne de x \\
\texttt{statistics.median(x)} & Médiane de x \\
\texttt{statistics.mode(x)} & Mode de x \\
\texttt{statistics.stdev(x)} & Écart-type de x \\
\texttt{statistics.variance(x)} & Variance de x \\
\end{longtable}

\section{Quelques constantes}\label{quelques-constantes}

La librairie \texttt{math} propose quelques constantes :

\begin{longtable}[]{@{}rr@{}}
\caption{\label{tab:constantes-base} Quelques constantes intégrées dans Python}\tabularnewline
\toprule\noalign{}
Fonction & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Fonction & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{math.pi} & Le nombre Pi (\(\pi\)) \\
\texttt{math.e} & La constante \(e\) \\
\texttt{math.tau} & La constante \(\tau\), égale à \(2\pi\) \\
\texttt{math.inf} & L'infini (\(\infty\)) \\
\texttt{-math.inf} & Moins l'infini (\(-\infty\)) \\
\texttt{math.nan} & Nombre à virgule flotante \emph{not a number} \\
\end{longtable}

\section{Exercice}\label{exercice-2}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Calculer le reste de la division euclidienne de 10 par 3.
\item
  Afficher le plus grand commun diviseur entre 6209 et 4435.
\item
  Soient deux objets : \texttt{a\ =\ 18} et \texttt{b\ =\ -4}. Tester si:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{a} est inférieur à \texttt{b} strictement,
\item
  \texttt{a} est supérieur ou égal à \texttt{b},
\item
  \texttt{a} est différent de \texttt{b}.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Soit la liste \texttt{x\ =\ {[}1,\ 1,\ 2,\ 3,\ 5,\ 8{]}}. Regarder si :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{1} est dans \texttt{x} ;
\item
  \texttt{0} est dans \texttt{x} ;
\item
  \texttt{1} et \texttt{0} sont dans \texttt{x} ;
\item
  \texttt{1} ou \texttt{0} sont dans \texttt{x} ;
\item
  \texttt{1} ou \texttt{0} n'est pas présent dans \texttt{x}.
\end{itemize}
\end{exframe}

\chapter{Chargement et sauvegarde de données}\label{chargement-et-sauvegarde-de-donnuxe9es}

Pour explorer des données et/ou réaliser des analyses statistiques ou économétriques, il est important de savoir importer et exporter des données.

Avant toute chose, il convient d'évoquer la notion de répertoire courant (\emph{working directory}). En informatique, le répertroire courant d'un processus désigne un répertoire du système de fichier associé à ce processus.

Lorsqu'on lance Jupyter, une arborescence nous est proposée, et nous navigons à l'interieur de celle-ci pour créer ou ouvrir un \emph{notebook}. Le répertoire contenant le \emph{notebook} est le répertoire courant. Lorsqu'on indiquera à Python d'importer des données (ou d'exporter des objets), l'origine (ou la destination) sera indiquée \textbf{relativement} au répertoire courant, à moins d'avoir recours à des chemins absolus (c'est-à-dire un chemin d'accès à partir de la racine \texttt{/}).

Si on lance un programme Python depuis un terminal, le répertoire courant est le répertoire dans lequel on se trouve dans le terminal au moment de lancer le programme.

Pour afficher dans Python le répertoire courant, on peut utiliser le code suivant :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\NormalTok{cwd }\OperatorTok{=}\NormalTok{ os.getcwd()}
\BuiltInTok{print}\NormalTok{(cwd)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## /Users/ewengallic/Dropbox/Universite_Aix_Marseille/Enseignements/Magistere_2_Programming_for_big_data/Cours/chapters/python/Python_pour_economistes
\end{lstlisting}

\begin{remarque}
La fonction \texttt{listdir()} de la librairie \texttt{os} est très pratique : elle permet de lister tous les documents et répertoires contenus dans le répertoire couant, ou dans n'importe quel répertoire si le
paramètre \texttt{path} renseigne le chemin (absolu ou relatif). Après avoir importé la fonction (\texttt{from\ os\ import\ getcwd}), on peut l'appeler : \texttt{os.listdir()}.
\end{remarque}

\section{Charger des données}\label{charger-donnees}

En fonction du format d'enregistrement des données, les techniques d'importation de données diffèrent.

\begin{remarque}
Le Chapitre~\ref{pandas} propose d'autres manières d'importer les données, avec la libraririe \texttt{pandas}.
\end{remarque}

\subsection{Fichiers textes}\label{import-fichiers-texte}

Lorsque les données sont présentes dans un fichier texte (ASCII), Python propose d'utiliser la fonction \texttt{open()}.

La syntaxe (simplifiée) de la fonction \texttt{open()} est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{open}\NormalTok{(}\BuiltInTok{file}\NormalTok{, mode}\OperatorTok{=}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, buffering}\OperatorTok{={-}}\DecValTok{1}\NormalTok{,}
\NormalTok{  encoding}\OperatorTok{=}\VariableTok{None}\NormalTok{, errors}\OperatorTok{=}\VariableTok{None}\NormalTok{, newline}\OperatorTok{=}\VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Voici à quoi correspondent les paramètres (il en existe d'autres) :

\begin{itemize}
\tightlist
\item
  \texttt{file} : une chaîne de caractères indiquant le chemin et le nom du fichier à ouvrir ;
\item
  \texttt{mode} : spécifie la manière par laquelle le fichier est ouvert (c.f. juste après pour les valeurs possibles) ;
\item
  \texttt{buffering} : spécifie à l'aide d'un entier le comportement à adopter pour la mise en mémoire tampon (1 pour mettre en mémoire par ligne ; un entier \(>1\) pour indiquer la taille en octets des morceaux à charger en mémoire tampon) ;
\item
  \texttt{encoding} : spécifie l'encodage du fichier ;
\item
  \texttt{errors} : spécifie la manière de gérer les erreurs d'encodage et de décodage (\emph{e.g.}, \texttt{strict} retourne une erreur d'exception, \texttt{ignore} permet d'ignorer les erreurs, \texttt{replace} de les remplacer, \texttt{backslashreplace} de remplacer les données mal formées par des séquences d'échappement) ;
\item
  \texttt{newline} : contrôle la fin des lignes (\texttt{\textbackslash{}n}, \texttt{\textbackslash{}r}, etc.).
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1333}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8667}}@{}}
\caption{\label{tab:open-mode-ouverture} Valeurs principales pour la manière d'ouvrir les fichiers.}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Valeur
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Valeur
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{r} & Ouverture pour lire (défaut) \\
\texttt{w} & Ouverture pour écrire \\
\texttt{x} & Ouverture pour créer un document, échoue si le fichier existe déjà \\
\texttt{a} & Ouverture pour écrire, en venant ajouter à la fin du fichier si celui-ci existe déjà \\
\texttt{+} & Ouverture pour mise à jour (lecture et écriture) \\
\texttt{b} & À ajouter à un mode d'ouverture pour les fichiers binaires (\texttt{rb} ou \texttt{wb}) \\
\texttt{t} & Mode texte (décodage automatique des octets en Unicode). Par défaut si non spécifié (s'ajoute au mode, comme \texttt{b}) \\
\end{longtable}

Il est important de bien penser à \textbf{fermer le fichier} une fois qu'on a terminé de l'utiliser. Pour ce faire, on utilise la méthode \texttt{close()}.

Dans le dossier \texttt{fichiers\_exemples} se trouve un fichier appelé \texttt{fichier\_texte.txt} qui contient trois lignes de texte. Ouvrons ce fichier, et utilisons la méthode \texttt{.read()} pour afficher son contenu :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OperatorTok{=} \StringTok{"./fichiers\_exemples/fichier\_texte.txt"}
\CommentTok{\# Ouverture en mode lecture (par défaut)}
\NormalTok{mon\_fichier }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(path, mode }\OperatorTok{=} \StringTok{"r"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(mon\_fichier.read())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Bonjour, je suis un fichier au format txt.
## Je contiens plusieurs lignes, l'idée étant de montrer comment fonctionne l'importation d'un tel fichier dans Python.
## Trois lignes devraient suffir.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mon\_fichier.close()}
\end{Highlighting}
\end{Shaded}

Une pratique courante en Python est d'ouvrir un fichier dans un bloc \texttt{with}. La raison de ce choix est qu'un fichier ouvert dans un tel bloc est automatiquement refermé à la fin du bloc.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ouverture en mode lecture (par défaut)}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(path, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  donnees }\OperatorTok{=}\NormalTok{ fonction\_pour\_recuperer\_donnees\_depuis\_mon\_fichier()}
\end{Highlighting}
\end{Shaded}

Par exemple, pour récupérer chaque ligne comme un élément d'une liste, on peut utiliser une boucle parcourant chaque ligne du fichier. À chaque itération, on récupère la ligne :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ouverture en mode lecture (par défaut)}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(path, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  donnees }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ mon\_fichier]}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Bonjour, je suis un fichier au format txt.\n', "Je contiens plusieurs lignes, l'idée étant de montrer comment fonctionne l'importation d'un tel fichier dans Python.\n", 'Trois lignes devraient suffir.']
\end{lstlisting}

Note : à chaque itération, on peut appliquer la méthode \texttt{strip()}, qui retourne la chaîne de caractère de la ligne, en retirant les éventuels caractères blancs en début de chaîne :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ouverture en mode lecture (par défaut)}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(path, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  donnees }\OperatorTok{=}\NormalTok{ [x.strip() }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ mon\_fichier]}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Bonjour, je suis un fichier au format txt.', "Je contiens plusieurs lignes, l'idée étant de montrer comment fonctionne l'importation d'un tel fichier dans Python.", 'Trois lignes devraient suffir.']
\end{lstlisting}

On peut également utiliser la méthode \texttt{readlines()} pour importer les lignes dans une liste :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(path, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{    donnees }\OperatorTok{=}\NormalTok{ mon\_fichier.readlines()}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['Bonjour, je suis un fichier au format txt.\n', "Je contiens plusieurs lignes, l'idée étant de montrer comment fonctionne l'importation d'un tel fichier dans Python.\n", 'Trois lignes devraient suffir.']
\end{lstlisting}

Il se peut parfois que l'encodage des caractères pose problème lors de l'importation. Dans ce cas, il peut être une bonne idée de changer la valeur du paramètre \texttt{encoding} de la fonction \texttt{open()}. Les encodages disponibles sont fonction de la locale. Les valeurs disponibles s'obtiennent à l'aide de la méthode suivante (code non exécuté dans ces notes) :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ locale}
\NormalTok{locale.locale\_alias}
\end{Highlighting}
\end{Shaded}

\subsubsection{Importation depuis internet}\label{importation-depuis-internet}

Pour importer un fichier texte depuis Internet, on peut utiliser des méthodes de la librairie \texttt{urllib} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ urllib}
\ImportTok{from}\NormalTok{ urllib.request }\ImportTok{import}\NormalTok{ urlopen}
\NormalTok{url }\OperatorTok{=} \StringTok{"http://egallic.fr/Enseignement/Python/fichiers\_exemples/fichier\_texte.txt"}
\ControlFlowTok{with}\NormalTok{ urllib.request.urlopen(url) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{   donnees }\OperatorTok{=}\NormalTok{ mon\_fichier.read()}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## b"Bonjour, je suis un fichier au format txt.\nJe contiens plusieurs lignes, l'id\xc3\xa9e \xc3\xa9tant de montrer comment fonctionne l'importation d'un tel fichier dans Python.\nTrois lignes devraient suffir."
\end{lstlisting}

Comme on peut le constater, l'encodage des caractères pose souci ici. On peut appliquer la méthode \texttt{decode()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(donnees.decode())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Bonjour, je suis un fichier au format txt.
## Je contiens plusieurs lignes, l'idée étant de montrer comment fonctionne l'importation d'un tel fichier dans Python.
## Trois lignes devraient suffir.
\end{lstlisting}

\subsection{Fichiers CSV}\label{importation-fichiers-csv}

Les fichier CSV (\emph{comma separated value}) sont très répandus. De nombreuses bases de données exportent leurs données en CSV (\emph{e.g.}, Banque Mondiale, FAO, Eurostat, etc.). Pour les importer dans Python, on peut uiliser le module \texttt{csv}.

À nouveau, on utilise la fonction \texttt{open()}, avec les paramètres décrits dans la Section~\ref{import-fichiers-texte}. Ensuite, on fait appel à la méthode \texttt{reader()} du module \texttt{csv} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ csv}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}./fichiers\_exemples/fichier\_csv.csv\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  mon\_fichier\_reader }\OperatorTok{=}\NormalTok{ csv.reader(mon\_fichier, delimiter}\OperatorTok{=}\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, quotechar}\OperatorTok{=}\StringTok{\textquotesingle{}"\textquotesingle{}}\NormalTok{)}
\NormalTok{  donnees }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ mon\_fichier\_reader]}

\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [['nom', 'prénom', 'équipe'], ['Irving', ' "Kyrie"', ' "Celtics"'], ['James', ' "Lebron"', ' "Lakers"', ''], ['Curry', ' "Stephen"', ' "Golden State Warriors"']]
\end{lstlisting}

La méthode \texttt{reader()} peut prendre plusieurs paramètres, décrits dans le Tableau~\ref{tab:parametres-reader-csv}.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2923}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7077}}@{}}
\caption{\label{tab:parametres-reader-csv} Paramètres de la fonction \texttt{reader()}}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Paramètre
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Paramètre
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{csvfile} & L'objet ouvert avec \texttt{open()} \\
\texttt{dialect} & Paramètre spécifiant le `dialect' du fichier CSV (e.g., \texttt{excel}, \texttt{excel-tab}, \texttt{unix}) \\
\texttt{delimiter} & Le caractère délimitant les champs (\emph{i.e.}, les valeurs des variables) \\
\texttt{quotechar} & Caractère utilisé pour entourer les champs contenant des caractères spéciaux \\
\texttt{escapechar} & Caractère d'échappement \\
\texttt{doublequote} & Contrôle comment les \emph{quotechar} apparaissent à l'intérieur d'un champ : quand \texttt{True}, le caractère est doublé, ; quand \texttt{False}, le caractère d'échappement est utilisé en préfixe au \emph{quotechar} \\
\texttt{lineterminator} & Chaîne de caractères utilisée pour terminer une ligne \\
\texttt{skipinitialspace} & Quand \texttt{True}, le caractère blanc situé juste après le caractère de séparation des champs est ignoré \\
\texttt{strict} & Quand \texttt{True}, retourne une erreur d'exception en cas de mauvais \texttt{input} de CSV \\
\end{longtable}

On peut aussi importer un fichier CSV en tant que dictionnaire, à l'aide de la méthode \texttt{csv.DictReader()} du module CSV :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ csv}
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/fichier\_csv.csv"}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{    mon\_fichier\_csv }\OperatorTok{=}\NormalTok{ csv.DictReader(mon\_fichier)}
\NormalTok{    donnees }\OperatorTok{=}\NormalTok{ [ligne }\ControlFlowTok{for}\NormalTok{ ligne }\KeywordTok{in}\NormalTok{ mon\_fichier\_csv]}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [{'nom': 'Irving', 'prénom': ' "Kyrie"', 'équipe': ' "Celtics"'}, {'nom': 'James', 'prénom': ' "Lebron"', 'équipe': ' "Lakers"', None: ['']}, {'nom': 'Curry', 'prénom': ' "Stephen"', 'équipe': ' "Golden State Warriors"'}]
\end{lstlisting}

\subsubsection{Importation depuis internet}\label{importation-depuis-internet-1}

Comme pour les fichiers \texttt{txt}, on peut charger un fichier CSV hébergé sur Internet :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ csv}
\ImportTok{import}\NormalTok{ urllib.request}
\ImportTok{import}\NormalTok{ codecs}

\NormalTok{url }\OperatorTok{=} \StringTok{"http://egallic.fr/Enseignement/Python/fichiers\_exemples/fichier\_csv.csv"}
\ControlFlowTok{with}\NormalTok{ urllib.request.urlopen(url) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{    mon\_fochier\_csv }\OperatorTok{=}\NormalTok{ csv.reader(codecs.iterdecode(mon\_fichier, }\StringTok{\textquotesingle{}utf{-}8\textquotesingle{}}\NormalTok{))}
\NormalTok{    donnees }\OperatorTok{=}\NormalTok{ [ligne }\ControlFlowTok{for}\NormalTok{ ligne }\KeywordTok{in}\NormalTok{ mon\_fochier\_csv]}
\BuiltInTok{print}\NormalTok{(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [['nom', 'prénom', 'équipe'], ['Irving', ' "Kyrie"', ' "Celtics"'], ['James', ' "Lebron"', ' "Lakers"', ''], ['Curry', ' "Stephen"', ' "Golden State Warriors"']]
\end{lstlisting}

\subsection{Fichier JSON}\label{fichier-json}

Pour importer des fichiers au format JSON (\emph{JavaScript Object Notation}), qui sont très utilisés dès lors qu'on communique avec une API, on peut utiliser la librairie \texttt{json}, et sa méthode \texttt{load()} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ json}
\NormalTok{lien }\OperatorTok{=} \StringTok{\textquotesingle{}./fichiers\_exemples/tweets.json\textquotesingle{}}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(lien) }\ImportTok{as}\NormalTok{ mon\_fichier\_json:}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ json.load(mon\_fichier\_json)}
\end{Highlighting}
\end{Shaded}

Ensuite, on peut afficher le contenu importé à l'aide de la fonction \texttt{pprint()} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ pprint }\ImportTok{import}\NormalTok{ pprint}
\NormalTok{pprint(data)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'created_at': 'Wed Sep 26 07:38:05 +0000 2018',
##  'id': 11,
##  'loc': [{'long': 5.3698}, {'lat': 43.2965}],
##  'text': 'Un tweet !',
##  'user_mentions': [{'id': 111, 'screen_name': 'nom_twittos1'},
##                    {'id': 112, 'screen_name': 'nom_twittos2'}]}
\end{lstlisting}

\subsubsection{Importation depuis Internet}\label{importation-depuis-internet-2}

Encore une fois, il est possible d'importer des fichiers JSON depuis Internet :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ urllib}
\ImportTok{from}\NormalTok{ urllib.request }\ImportTok{import}\NormalTok{ urlopen}
\NormalTok{url }\OperatorTok{=} \StringTok{"http://egallic.fr/Enseignement/Python/fichiers\_exemples/tweets.json"}
\ControlFlowTok{with}\NormalTok{ urllib.request.urlopen(url) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{   donnees }\OperatorTok{=}\NormalTok{ json.load(mon\_fichier)}
\NormalTok{pprint(donnees)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'created_at': 'Wed Sep 26 07:38:05 +0000 2018',
##  'id': 11,
##  'loc': [{'long': 5.3698}, {'lat': 43.2965}],
##  'text': 'Un tweet !',
##  'user_mentions': [{'id': 111, 'screen_name': 'nom_twittos1'},
##                    {'id': 112, 'screen_name': 'nom_twittos2'}]}
\end{lstlisting}

\subsection{Fichiers Excel}\label{fichiers-excel}

Les fichiers Excel (\texttt{xls} ou \texttt{xlsx}) sont aussi très largement répandus en économie. Le lecteur est prié de se référer à la Section~\ref{pandas-importation-excel} pour une méthode d'importation des données Excel avec la librairie \texttt{pandas}.

\section{Exporter des données}\label{exporter-des-donnuxe9es}

Il n'est pas rare de devoir exporter ses données, ne serait-ce que pour les partager. À nouveau, la fonction \texttt{open()} est mise à contribution, en jouant avec la valeur du paramètre \texttt{mode} (c.f. Tableau~\ref{tab:open-mode-ouverture}).

\subsection{Fichiers textes}\label{fichiers-textes}

Admettons que nous ayons besoin d'exporter des lignes de texte dans un fichier. Avant de donner un exemple avec la fonction \texttt{open()}, regardons deux fonctions importantes pour convertir les contenus de certains objets en texte.

La première, \texttt{str()}, retourne une version en chaînes de caractères d'un objet. Nous l'avons déjà appliquée à des nombres que l'on désirait concaténer en Section~\ref{conversion-chaines-caracteres}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\StringTok{"pomme"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{str}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## "['pomme', 1, 3]"
\end{lstlisting}

Le résultat de cette instruction retourne la liste sous la forme d'une chaîne de caractères : \texttt{"{[}\textquotesingle{}pomme\textquotesingle{},\ 1,\ 3{]}"}.

La seconde fonction qu'il semble important d'aborder est \texttt{repr()}. Cette fonction retourne une chaîne contenant une représentation imprimable à l'écran d'un objet. De plus, cette chaîne peut être lue par l'interprète.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=} \StringTok{"Fromage, tu veux du fromage ?}\CharTok{\textbackslash{}n}\StringTok{"}
\BuiltInTok{repr}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## "'Fromage, tu veux du fromage ?\\n'"
\end{lstlisting}

Le résultat donne : \texttt{"\textquotesingle{}Fromage,\ tu\ veux\ du\ fromage\ ?\textbackslash{}\textbackslash{}n\textquotesingle{}"}.

Admettons que nous souhaitons exporter deux lignes :

\begin{itemize}
\tightlist
\item
  la première, un texte qui indique un titre (``Caractéristiques de Kyrie Irving'') ;
\item
  la seconde, un dictionnaire contenant des informations sur Kyrie Irving (c.f. ci-dessous).
\end{itemize}

Définissions ce dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=}\NormalTok{ \{ }\StringTok{"nom"}\NormalTok{: }\StringTok{"Kyrie"}\NormalTok{,}
  \StringTok{"prenom"}\NormalTok{: }\StringTok{"John"}\NormalTok{,}
  \StringTok{"naissance"}\NormalTok{: }\DecValTok{1992}\NormalTok{,}
  \StringTok{"equipes"}\NormalTok{: [}\StringTok{"Cleveland"}\NormalTok{, }\StringTok{"Boston"}\NormalTok{]\}}
\end{Highlighting}
\end{Shaded}

Une des syntaxes pour exporter les données au format \texttt{txt} est :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ouverture en mode lecture (par défaut)}
\NormalTok{chemin }\OperatorTok{=} \StringTok{"chemin/vers/fichier.txt"}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  fonction\_pour\_exporter()}
\end{Highlighting}
\end{Shaded}

On créé une variable indiquant le chemin vers le fichier. On ouvre ensuite le fichier en mode écriture en précisant le paramètre \texttt{mode\ =\ "w"}. Puis, il reste à écrire nos lignes dans le fichier.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/Irving.txt"}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, mode }\OperatorTok{=} \StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  mon\_fichier.write(}\StringTok{"Caractéristiques de Kyrie Irving}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  mon\_fichier.writelines(}\BuiltInTok{repr}\NormalTok{(z))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 33
\end{lstlisting}

Si le fichier est déjà existant, en ayant utilisé \texttt{mode="w"}, l'ancien fichier sera écrasé par le nouveau. Si on souhaite ajouter des lignes au fichier existant, on utilisera \texttt{mode="a"} par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, mode }\OperatorTok{=} \StringTok{"a"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  mon\_fichier.writelines(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Une autre ligne}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si on souhaite être prévenu si le fichier est déjà existant, et faire échouer l'écriture si tel est le cas, on peut utiliser \texttt{mode="x"} :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, mode }\OperatorTok{=} \StringTok{"x"}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{  mon\_fichier.writelines(}\StringTok{"Une nouvelle ligne qui ne sera pas ajoutée}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## FileExistsError: [Errno 17] File exists: './fichiers_exemples/Irving.txt'
\end{lstlisting}

\subsection{Fichiers CSV}\label{fichiers-csv}

En tant qu'économiste, il est plus fréquent d'avoir à exporter les données au format CSV plutôt que texte, du fait de la structure en rectangle des données que l'on manipule. Comme pour l'importation de CSV (c.f. Section~\ref{importation-fichiers-csv}), on utilise le module \texttt{csv}. Pour écrire dans le fichier, on utilise la méthode \texttt{writer()}. Les paramètres de formatage de cette fonction sont les mêmes que ceux de la fonction \texttt{reader()} (c.f. Tableau~\ref{tab:parametres-reader-csv}).

Exemple de création d'un fichier CSV :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ csv}
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/fichier\_export.csv"}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, mode}\OperatorTok{=}\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ mon\_fichier:}
\NormalTok{    mon\_fichier\_ecrire }\OperatorTok{=}\NormalTok{ csv.writer(mon\_fichier, delimiter}\OperatorTok{=}\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{,}
\NormalTok{                                    quotechar}\OperatorTok{=}\StringTok{\textquotesingle{}"\textquotesingle{}}\NormalTok{,}
\NormalTok{                                    quoting}\OperatorTok{=}\NormalTok{csv.QUOTE\_MINIMAL)}

\NormalTok{    mon\_fichier\_ecrire.writerow([}\StringTok{\textquotesingle{}Pays\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Année\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Trimestre\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}TC\_PIB\textquotesingle{}}\NormalTok{])}
\NormalTok{    mon\_fichier\_ecrire.writerow([}\StringTok{\textquotesingle{}France\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Q4\textquotesingle{}}\NormalTok{, }\FloatTok{0.7}\NormalTok{])}
\NormalTok{    mon\_fichier\_ecrire.writerow([}\StringTok{\textquotesingle{}France\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2018\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Q1\textquotesingle{}}\NormalTok{, }\FloatTok{0.2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 29
## 20
## 20
\end{lstlisting}

Bien évidemment, la plupart du temps, nous n'écrivons pas à la main chaque entrée. Nous exportons les données contenues dans une structure. La Section~\ref{pandas-importation-excel} donne des exemples de ce type d'export, lorsque les données sont contenues dans des tableaux à deux dimension créés avec la librairie \texttt{pandas}.

\subsection{Fichier JSON}\label{fichier-json-1}

Il peut être nécessaire de sauvegarder des données structurées au format JSON, par exemple lorsqu'on a fait appel à une API (\emph{e.g.}, l'API de Twitter) qui retourne des objets au format JSON.

Pour ce faire, nous allons utiliser la librairire \texttt{json}, et sa méthode \texttt{dump()}. Cette méthode permet de sérialiser un objet (par exemple une liste, comme ce que l'on obtient avec l'API Twitter interrogée avec la libraririe \texttt{twitter-python}) en JSON.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ json}
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{"pomme"}\NormalTok{, [}\StringTok{"pépins"}\NormalTok{, }\StringTok{"rouge"}\NormalTok{]]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ \{ }\StringTok{"nom"}\NormalTok{: }\StringTok{"Kyrie"}\NormalTok{,}
  \StringTok{"prenom"}\NormalTok{: }\StringTok{"John"}\NormalTok{,}
  \StringTok{"naissance"}\NormalTok{: }\DecValTok{1992}\NormalTok{,}
  \StringTok{"equipes"}\NormalTok{: [}\StringTok{"Cleveland"}\NormalTok{, }\StringTok{"Boston"}\NormalTok{]\}}
\NormalTok{x\_json }\OperatorTok{=}\NormalTok{ json.dumps(x)}
\NormalTok{y\_json }\OperatorTok{=}\NormalTok{ json.dumps(y)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"x\_json: "}\NormalTok{, x\_json)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x_json:  [1, "pomme", ["p\u00e9pins", "rouge"]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"y\_json: "}\NormalTok{, y\_json)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y_json:  {"nom": "Kyrie", "prenom": "John", "naissance": 1992, "equipes": ["Cleveland", "Boston"]}
\end{lstlisting}

Comme on peut le constater, on rencontre quelques petite problèmes d'affichage des caractères accentués. On peut préciser, à l'aide du paramètre \texttt{ensure\_ascii} évalué à \texttt{False} que l'on ne désire pas s'assurer que les caractères non-ascii soient échappés par des séquences de type \texttt{\textbackslash{}uXXXX}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_json }\OperatorTok{=}\NormalTok{ json.dumps(x, ensure\_ascii}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\NormalTok{y\_json }\OperatorTok{=}\NormalTok{ json.dumps(y, ensure\_ascii}\OperatorTok{=}\VariableTok{False}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"x\_json: "}\NormalTok{, x\_json)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x_json:  [1, "pomme", ["pépins", "rouge"]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"y\_json: "}\NormalTok{, y\_json)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y_json:  {"nom": "Kyrie", "prenom": "John", "naissance": 1992, "equipes": ["Cleveland", "Boston"]}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/export\_json.json"}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, }\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    json.dump(json.dumps(x, ensure\_ascii}\OperatorTok{=}\VariableTok{False}\NormalTok{), f)}
\NormalTok{    f.write(}\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{    json.dump(json.dumps(y, ensure\_ascii}\OperatorTok{=}\VariableTok{False}\NormalTok{), f)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1
\end{lstlisting}

Si on souhaite réimporter dans Python le contenu du fichier \texttt{export\_json.json} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/export\_json.json"}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(chemin, }\StringTok{"r"}\NormalTok{, encoding}\OperatorTok{=}\StringTok{"utf{-}8"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ f:}
\NormalTok{        data.append(json.loads(line))}

\BuiltInTok{print}\NormalTok{(data)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ['[1, "pomme", ["pépins", "rouge"]]', '{"nom": "Kyrie", "prenom": "John", "naissance": 1992, "equipes": ["Cleveland", "Boston"]}']
\end{lstlisting}

\subsection{Exercice}\label{exercice-3}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer une liste nommée \texttt{a} contenant des informations sur le taux de chômage en France au deuxième trimestre 2018. Cette liste doit contenir trois éléments :

  \begin{itemize}
  \tightlist
  \item
    l'année ;
  \item
    le trimestre ;
  \item
    la valeur du taux de chômage (\(9.1\%\)).
  \end{itemize}
\item
  Exporter au format CSV le contenu de la liste \texttt{a}, en le faisant précéder d'une ligne précisant les noms des champs. Utiliser le point virgule comme séparateur de champs.
\item
  Importer le fichier créé dans la question précédente dans Python.
\end{enumerate}
\end{exframe}

\chapter{Conditions}\label{conditions}

Souvent, en fonction de l'évaluation d'une expression, on désire réaliser une opération plutôt qu'une autre. Par exemple, lorsqu'on créé une nouvelle variable dans une analyse statistique, et que cette variable prend ses valeurs en fonction d'une autre, on peut être amené à utiliser des \textbf{instructions conditionnelles} : ``si la valeur est inférieur à \(x\), alors\ldots{} sinon, \ldots{}''.

Dans ce court chapitre, nous regardons comment rédiger les instructions conditionnelles.

\section{\texorpdfstring{Les instructions conditionnelles \texttt{if}}{Les instructions conditionnelles if}}\label{les-instructions-conditionnelles-if}

L'instruction conditionnelle la plus simple que l'on peut rencontrer est \texttt{if}. Si et seulement si une expression est évaluée à \texttt{True}, alors une instruction sera évaluée.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ expression:}
\NormalTok{  instruction}
\end{Highlighting}
\end{Shaded}

Les lignes après les deux points (\texttt{:}) doivent être placées dans un bloc, en utilisant un taquet de tabulation.

\begin{remarque}
Un bloc de code est un regroupement d'instructions. Des codes imbriqués indentés à la même position font partie du même bloc :

\begin{lstlisting}
ligne du bloc 1
ligne du bloc 1
  ligne du bloc2
  ligne du bloc2
ligne du bloc1
\end{lstlisting}
\end{remarque}

Dans le code ci-dessous, nous définissons une variable \texttt{x} contenant l'entier \(2\). L'instruction suivante évalue l'expression \texttt{x\ ==\ 2} (cf.~Section~@ref(\#operateurs-comparaison) pour des rappels sur les opérateurs de comparaison). Si le résultat de cette expression est \texttt{Vrai}, alors le contenu du bloc est évalué.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{2}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello
\end{lstlisting}

Si on change la valeur de \texttt{x} de manière à ce que l'expression \texttt{x\ ==\ 2} retourne \texttt{False} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{2}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

À l'intérieur du bloc, on peut écrire plusieurs instructions qui seront évaluées si l'expression est \texttt{True} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{2}\NormalTok{:}
\NormalTok{  y }\OperatorTok{=} \StringTok{"Hello"}
  \BuiltInTok{print}\NormalTok{(y }\OperatorTok{+} \StringTok{", x vaut : "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Hello, x vaut : 2
\end{lstlisting}

\begin{remarque}
Lorsqu'on rédige son code, il peut-être pratique d'utiliser des instructions conditionnelles \texttt{if} pour évaluer ou non certaines parties du code. Par exemple, quand on régide un script, il arrive des moments où nous devons réévaluer le début, mais que certaines parties ne nécessitent pas d'être réévaluées à chaque fois, comme des sorties graphiques (ce qui prend du temps). Il est possible de commenter ces parties de codes ne nécessitant pas une nouvelle évaluation, ou alors on peut les placer dans un bloc conditionnel :

\begin{itemize}
\tightlist
\item
  au début du script, on créé une variable \texttt{graph\ =\ False} ;
\item
  avant de créer un graphique, on le place dans un bloc \texttt{if\ graphe:}
\end{itemize}

Au moment de l'exécution du script, on peut choisir de créer et exporter les graphiques des blocs \texttt{if\ graphe:} en modifiant à sa guise la variable \texttt{graph}.
\end{remarque}

\section{\texorpdfstring{Les instructions conditionnelles \texttt{if-else}}{Les instructions conditionnelles if-else}}\label{les-instructions-conditionnelles-if-else}

Si la condition n'est pas vérifiée, on peut proposer des instructions à effectuer, à l'aide des instructions \texttt{if-else}.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ expression:}
\NormalTok{  instructions}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  autres\_instruction}
\end{Highlighting}
\end{Shaded}

Par exemple, admettons qu'on veuille créer une variable de chaleur prenant la valeur \texttt{chaud} si la valeur de la variable \texttt{temperature} dépasse 28 degrés C, \texttt{froid} sinon. Admettons que la température est de 26 degrés C :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperature }\OperatorTok{=} \DecValTok{26}
\NormalTok{chaleur }\OperatorTok{=} \StringTok{""}

\ControlFlowTok{if}\NormalTok{ temperature }\OperatorTok{\textgreater{}} \DecValTok{28}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"chaud"}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"froid"}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Il fait "} \OperatorTok{+}\NormalTok{ chaleur)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Il fait froid
\end{lstlisting}

Si la température est à présent de 32 degrés C :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperature }\OperatorTok{=} \DecValTok{32}
\NormalTok{chaleur }\OperatorTok{=} \StringTok{""}

\ControlFlowTok{if}\NormalTok{ temperature }\OperatorTok{\textgreater{}} \DecValTok{28}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"chaud"}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"froid"}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Il fait "} \OperatorTok{+}\NormalTok{ chaleur)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Il fait chaud
\end{lstlisting}

\section{\texorpdfstring{Les instructions conditionnelles \texttt{if-elif}}{Les instructions conditionnelles if-elif}}\label{les-instructions-conditionnelles-if-elif}

Si la condition n'est pas vérifiée, on peut en tester une autre et alors évaluer d'autres instructions si cette seconde est vérifiée. Sinon, on peut en tester encore une autre, et ainsi de suite. On peut aussi proposer des instructions si aucune des conditions n'a été évaluée à \texttt{True}. Pour ce faire, on peut utiliser des instructions conditionnelles \texttt{if-elif}.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ expression:}
\NormalTok{  instructions}
\ControlFlowTok{elif}\NormalTok{ expression\_2:}
\NormalTok{  instructions\_2}
\ControlFlowTok{elif}\NormalTok{ expression\_3:}
\NormalTok{  instructions\_3}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  autres\_instruction}
\end{Highlighting}
\end{Shaded}

L'exemple précédent manque un peu de sens commun. Peut-on dire que lordqu'il fait 28 degrés C ou moins il fait froid ? Ajoutons quelques nuances :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperature }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{4}
\NormalTok{chaleur }\OperatorTok{=} \StringTok{""}

\ControlFlowTok{if}\NormalTok{ temperature }\OperatorTok{\textgreater{}} \DecValTok{28}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"chaude"}
\ControlFlowTok{elif}\NormalTok{ temperature }\OperatorTok{\textless{}=} \DecValTok{28} \KeywordTok{and}\NormalTok{ temperature }\OperatorTok{\textgreater{}} \DecValTok{15}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"tempérée"}
\ControlFlowTok{elif}\NormalTok{ temperature }\OperatorTok{\textless{}=} \DecValTok{15} \KeywordTok{and}\NormalTok{ temperature }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"froide"}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  chaleur }\OperatorTok{=} \StringTok{"très froide"}

\BuiltInTok{print}\NormalTok{(}\StringTok{"La température est "} \OperatorTok{+}\NormalTok{ chaleur)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## La température est très froide
\end{lstlisting}

\begin{remarque}
L'avantage d'utiliser des instructions conditionnelles \texttt{if-elif} par rapport à écrire plusieurs instructions conditionnelles \texttt{if} à la suite est qu'avec la première manière de faire, les comparaisons s'arrêtent dès qu'une est remplie, ce qui est plus efficace.
\end{remarque}

\section{Exercice}\label{exercice-4}

\begin{exframe}
Soit une liste nommée \texttt{europe} contenant les valeurs suivantes, sous forme de chaînes de caractères : ``Allemagne'', ``France'' et ``Espagne''.

Soit une seconde liste, nommée \texttt{asie}, contenant sous forme de chaînes de caractères : ``Vietnam'', ``Chine'' et ``Inde''.

L'objectif va être de créer une variable \texttt{continent} qui va indiquer soit \texttt{"Europe"}, \texttt{"Asie"} ou \texttt{"Autre"} à l'issue de l'exécution du code.

À l'aide d'instructions conditionnelles de type \texttt{if-elif}, rédiger un code qui vérifie la valeur d'une variable \texttt{pays}, et définit la valeur d'une autre variable nommée \texttt{continent} en fonction du contenu observé dans \texttt{pays} tel que :

\begin{itemize}
\tightlist
\item
  si la valeur de pays est présente dans la liste \texttt{europe}, \texttt{continent} vaudra \texttt{"Europe"} ;
\item
  si la valeur de pays est présente dans la liste \texttt{asie}, \texttt{continent} vaudra \texttt{"Asie"} ;
\item
  si la valeur de pays n'est présente ni dans \texttt{europe} ni dans \texttt{asie}, la variable \texttt{continent} vaudra \texttt{"Autre"}.
\end{itemize}

Pour ce faire :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer les deux listes \texttt{europe} et \texttt{asie} ainsi que la variable \texttt{pays} (valant ``Espagne'') et la variable \texttt{continent} (initiée avec une chaîne de caractères vide).
\item
  Rédiger le code permettant de réaliser l'objectif expliqué, et afficher le contenu de la variable \texttt{continent} à l'issue de l'exécution.
\item
  Changer la valeur de \texttt{pays} à \texttt{"Chine"} puis à \texttt{"Brésil"} et dans chacun des cas, exécuter le code rédigé dans la question précédente.
\end{enumerate}
\end{exframe}

\chapter{Boucles}\label{boucles}

Quand on doit répéter plusieurs fois la même opération, pour un nombre déterminé de fois ou tant qu'une condition est vérifiée (ou tant qu'elle n'est pas vérifiée), on peut utiliser des boucles, ce qui est bien moins pénible que d'évaluer à la main ou à coups de copier/coller la même instruction.

Nous allons aborder deux types de boucles dans ce chapitre :

\begin{itemize}
\tightlist
\item
  celles pour lesquelles nous ne savons pas \texttt{a\ priori} le nombre d'itérations (le nombre de répétitions) à effectuer : les boucles \texttt{while()}
\item
  celles pour lesquelles nous savons \texttt{a\ priori} combien d'itérations sont nécessaires : les boucles \texttt{for()}
\end{itemize}

\begin{remarque}
Il est possible d'arrêter une boucle \texttt{for()} avant un nombre d'itérations prédéfini ; dans le même esprit, il est possible d'utiliser une boucle \texttt{while()} en sachant d'avance le nombre d'itérations à effectuer.
\end{remarque}

\section{\texorpdfstring{Boucles avec \texttt{while()}}{Boucles avec while()}}\label{boucles-avec-while}

Le principe d'une boucle \texttt{while()} est que les instructions à l'intérieur de la boucle seront répétées tant qu'une condition est respectée. L'idée est de faire dépendre cette condition d'un ou plusieurs objets qui seront modifiés au cours des itérations (sans cela, la boucle tournerait à l'infini).

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{ condition:}
\NormalTok{  instructions}
\end{Highlighting}
\end{Shaded}

Comme pour les instructions conditionnelles (c.f. Section~\ref{conditions}), les instructions sont placées à l'intérieur d'un bloc.

Regardons un exemple de boucle \texttt{while()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{100}
\ControlFlowTok{while}\NormalTok{ x}\OperatorTok{/}\DecValTok{3} \OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(x}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ x}\OperatorTok{/}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 33.333333333333336
## 11.111111111111112
## 3.703703703703704
## 1.234567901234568
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x}\OperatorTok{/}\DecValTok{3}\OperatorTok{\textgreater{}}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## False
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(x}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0.41152263374485604
\end{lstlisting}

Dans cette boucle, à chaque itération, la valeur de \texttt{x} divisé par 3 est affichée, puis la valeur de \texttt{x} est remplacée par le tiers de sa valeur courante. Cette opération est répétée tant que l'expression \texttt{x/3\ \textgreater{}\ 1} retourne \texttt{True}.

\section{\texorpdfstring{Boucles avec \texttt{for()}}{Boucles avec for()}}\label{boucles-avec-for}

Quand on connaît le nombre d'itérations à l'avance, on pourra utiliser une boucle \texttt{for()}. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ objet }\KeywordTok{in}\NormalTok{ valeurs\_possibles:}
\NormalTok{  instructions}
\end{Highlighting}
\end{Shaded}

avec \texttt{objet} le nom d'une variable locale à la fonction \texttt{for()}, \texttt{valeurs\_possibles} un objet comprenant \(n\) éléments définissant les valeurs que prendra \texttt{objet} pour chacun des \(n\) tours, et \texttt{instructions} les instructions qui seront exécutées à chaque itération.

Nous allons, dans l'exemple qui suit, calculer le carré des \(n\) premiers entiers. Les valeurs que vont prendre notre variable \texttt{objet} (que nous allons appeler \texttt{i}) seront les entiers de 1 à \(n\). Pour obtenir une séquence d'entiers en Python, on peut utiliser la fonction \texttt{range()}, qui prend les paramètres suivants :

\begin{itemize}
\tightlist
\item
  \texttt{start} : (optionnel, par défaut, 0) valeur de début pour la séquence (inclue) ;
\item
  \texttt{stop} : valeur de fin de la séquence (non inclue) ;
\item
  \texttt{step} : (optionnel, par défaut 1) le pas.
\end{itemize}

Avant de calculer la suite des \(n\) premiers carrés, regardons un exemple de fonctionnement de la fonction \texttt{range()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{))) }\CommentTok{\# Les entiers de 0 à 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0, 1, 2, 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{4}\NormalTok{))) }\CommentTok{\# Les entiers de 0 à 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0, 1, 2, 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{))) }\CommentTok{\# Les entiers de 2 à 9}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [2, 3, 4, 5, 6, 7, 8, 9]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{))) }\CommentTok{\# Les entiers de 2 à 9 par pas de 3}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [2, 5, 8]
\end{lstlisting}

Aussi, pour afficher la suite des \(10\) premiers carrés :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Le carré de }\SpecialCharTok{\{\}}\StringTok{ est }\SpecialCharTok{\{\}}\StringTok{"} 
\NormalTok{n}\OperatorTok{=}\DecValTok{10}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{+}\DecValTok{1}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(i,i}\OperatorTok{**}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Le carré de 0 est 0
## Le carré de 1 est 1
## Le carré de 2 est 4
## Le carré de 3 est 9
## Le carré de 4 est 16
## Le carré de 5 est 25
## Le carré de 6 est 36
## Le carré de 7 est 49
## Le carré de 8 est 64
## Le carré de 9 est 81
## Le carré de 10 est 100
\end{lstlisting}

Lors de la première itération, \texttt{i} vaut 0. Lors de la seconde, \texttt{i} vaut 1. Lors de la troisième, \texttt{i} vaut 2, etc.

Si on veut stocker le résultat dans une liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\OperatorTok{=}\DecValTok{10}
\NormalTok{n\_entiers\_carres }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{+}\DecValTok{1}\NormalTok{):}
\NormalTok{  n\_entiers\_carres.append(i}\OperatorTok{**}\DecValTok{2}\NormalTok{)}
  
\BuiltInTok{print}\NormalTok{(n\_entiers\_carres)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\end{lstlisting}

Il n'est pas obligatoire d'utiliser la fonction \texttt{range()} dans une boucle \texttt{for()}, on peut définir les valeurs ``à la main'' :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Le carré de }\SpecialCharTok{\{\}}\StringTok{ est }\SpecialCharTok{\{\}}\StringTok{"}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{]:}
  \BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(i,i}\OperatorTok{**}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Le carré de 0 est 0
## Le carré de 1 est 1
## Le carré de 2 est 4
## Le carré de 8 est 64
## Le carré de 9 est 81
## Le carré de 10 est 100
\end{lstlisting}

Dans le même esprit, il n'est pas obligatoire d'itérer sur des valeurs numériques :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Il y a }\SpecialCharTok{\{\}}\StringTok{ lettre(s) dans le prénom }\SpecialCharTok{\{\}}\StringTok{"}
\ControlFlowTok{for}\NormalTok{ prenom }\KeywordTok{in}\NormalTok{ [}\StringTok{"Pascaline"}\NormalTok{, }\StringTok{"Gauthier"}\NormalTok{, }\StringTok{"Xuan"}\NormalTok{, }\StringTok{"Jimmy"}\NormalTok{]:}
  \BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(}\BuiltInTok{len}\NormalTok{(prenom), prenom))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Il y a 9 lettre(s) dans le prénom Pascaline
## Il y a 8 lettre(s) dans le prénom Gauthier
## Il y a 4 lettre(s) dans le prénom Xuan
## Il y a 5 lettre(s) dans le prénom Jimmy
\end{lstlisting}

Rien n'empêche de faire des boucles à l'intérieur de boucles :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"i vaut }\SpecialCharTok{\{\}}\StringTok{ et j vaut }\SpecialCharTok{\{\}}\StringTok{"}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{3}\NormalTok{):}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{3}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(i, j))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## i vaut 0 et j vaut 0
## i vaut 0 et j vaut 1
## i vaut 0 et j vaut 2
## i vaut 1 et j vaut 0
## i vaut 1 et j vaut 1
## i vaut 1 et j vaut 2
## i vaut 2 et j vaut 0
## i vaut 2 et j vaut 1
## i vaut 2 et j vaut 2
\end{lstlisting}

Comme on peut le constater, l'itération se fait pour chaque valeur de \texttt{i}, et pour chacune de ces valeurs, une seconde itération est effectuée sur les valeurs de \texttt{j}.

\begin{remarque}
On utilise souvent les lettres \texttt{i} et \texttt{j} pour désigner un compteur dans une boucle \texttt{for()}, mais ce n'est évidemment pas une obligation.
\end{remarque}

Dans une boucle, si on désire incrémenter un comteur, on peut utiliser le symbole \texttt{+=} plutôt que d'écrire \texttt{compteur\ =\ compteur\ +\ ...} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Nouvelle valeur pour j : }\SpecialCharTok{\{\}}\StringTok{"}
\NormalTok{j }\OperatorTok{=} \DecValTok{10}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{):}
\NormalTok{  j }\OperatorTok{+=} \DecValTok{5}
  \BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(j))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Nouvelle valeur pour j : 15
## Nouvelle valeur pour j : 20
## Nouvelle valeur pour j : 25
## Nouvelle valeur pour j : 30
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
  
\BuiltInTok{print}\NormalTok{(j)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 30
\end{lstlisting}

\section{Exercice}\label{exercice-5}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Rédiger un programme très naïf visant à déterminer si un nombre est premier ou non. Pour ce faire :

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    définir une variable \texttt{nombre} contenant un entier naturel de votre choix (pas trop grand),
  \item
    à l'aide d'une boucle, vérifier si chaque entier jusqu'à la racine carrée de votre nombre, est un diviseur de votre nombre (s'arrêter si jamais c'est le cas)
  \item
    en sortie de boucle, écrire une instruction conditionnelle indiquant si le nombre est premier ou non.
  \end{enumerate}
\item
  Choisir un nombre mystère entre 1 et 100, et le stocker dans un objet que l'on nommera \texttt{nombre\_mystere}. Ensuite, créer une boucle qui à chaque itération effectue un tirage aléatoire d'un entier compris entre 1 et 100. Tant que le nombre tiré est différent du nombre mystère, la boucle doit continuer. À la sortie de la boucle, une variable que l'on appellera \texttt{nb\_tirages} contiendra le nombre de tirages réalisés pour obtenir le nombre mystère.
\end{enumerate}

\emph{Note : pour tirer un nombre aléatoirement entre 1 et 100, on peut utiliser la méthode \texttt{randint()} du module \texttt{random}).}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Parcourir les entiers de 1 à 20 à l'aide d'une boucle for en affichant dans la console à chaque itération si le nombre courant est pair.
\item
  Utiliser une boucle \texttt{for()} pour reprouire la suite de Fibonacci jusqu'à son dixième terme (la séquence \(F_n\) est définie par la relation de récurrence suivante : \(F_n = F_{n-1} + F_{n-2}\) ; les valeurs initiales sont \(F_0 = 0\) et \(F_1 = 1\)).
\end{enumerate}
\end{exframe}

\chapter{Fonctions}\label{fonctions}

La plupart du temps, on utilise les fonctions de base ou contenues dans des modules. Cela dit, lorsque l'on récupère des données en ligne ou qu'on doit mettre en forme des données importées depuis diverses sources, il arrive qu'il soit nécessaire de créer ses propres fonctions. L'avantage de créer ses fonctions se révèle dès lors qu'on doit effectuer une suite d'instruction de manière répétée, avec quelques légères différences (on peut alors appliquer les fonctions au sein d'une boucle, comme nous l'avons abordé dans le Chapitre~\ref{boucles}).

\section{Définition}\label{duxe9finition}

Une fonction est déclarée à l'aide du mot clé \texttt{keyword}. Ce qu'elle renvoie est retourné à l'aide du mot clé \texttt{return}.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ nom\_fonction(parametres):}
\NormalTok{  corps\_de\_la\_fonction}
\end{Highlighting}
\end{Shaded}

Une fois que la fonction est définie, on l'appelle en faisant référence à son nom :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nom\_fonction()}
\end{Highlighting}
\end{Shaded}

Il suffit donc de rajouter des parenthèses au nom de la fonction pour l'appeler. En effet, \texttt{nom\_fonction} désigne l'objet qui contient la fonction qui est appelée à l'aide de l'expression \texttt{nom\_fonction()}.
Par exemple, si on souhaite définir la fonction qui calcule le carré d'un nombre, voici ce que l'on peut écrire :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ carre(x):}
  \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

On peut ensuite l'appeler :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(carre(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(carre(}\OperatorTok{{-}}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 9
\end{lstlisting}

\subsection{Ajout d'une description}\label{ajout-dune-description}

Il est possible (et fortement recommandé) d'ajouter une description de ce que la fonction fait, en adoptant des conventions (c.f. \url{https://www.python.org/dev/peps/pep-0257/}) =

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ carre(x):}
  \CommentTok{"""retourne le carré de x"""}
  \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

De fait, quand on évalue ensuite l'instruction suivante, la description de la fonction s'affiche :

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{\textasciigrave{}}\AttributeTok{?}\StringTok{\textasciigrave{}}\NormalTok{(carre)}
\end{Highlighting}
\end{Shaded}

Dans Jupyter Notebook, après avoir écrit le nom de la fonction, on peut aussi afficher la description en appuyant sur les touches du clavier \texttt{Shift} et \texttt{Tabulation}.

\subsection{Paramètres d'une fonction}\label{paramuxe8tres-dune-fonction}

Dans l'exemple de la fonction \texttt{carre()} que nous avons créée, nous avons renseigné un seul paramètre, appelé \texttt{x}. Si la fonction que l'on souhaite créer nécessite plusieurs paramètres, il faut les séparer par une virgule.

Considérons par exemple le problème suivant. Nous disposons d'une fonction de production \(Y(L, K, M)\), qui dépend du nombre de travailleurs \(L\) et de la quantité de capital \(K\), et du matériel \(M\), telle que \(Y(L, K, M) = L^{0.3} K^{0.5}M^2\). Cette fonction pourra s'écrire en Python de la manière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ production(l, k, m):}
  \CommentTok{"""}
\CommentTok{  Retourne la valeur de la production en fonction}
\CommentTok{  du travail, du capital et du matériel.}
\CommentTok{  }
\CommentTok{  Keyword arguments:}
\CommentTok{  l {-}{-} travail (float)}
\CommentTok{  k {-}{-} capital (float)}
\CommentTok{  m {-}{-} matériel (float)}
\CommentTok{  """}
  \ControlFlowTok{return}\NormalTok{ l}\OperatorTok{**}\FloatTok{0.3} \OperatorTok{*}\NormalTok{ k}\OperatorTok{**}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ m}\OperatorTok{**}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Appel sans noms de paramètres}\label{appel-sans-noms-de-paramuxe8tres}

En reprenant l'exemple précédent, si on nous donne \(L = 60\) et \(K = 42\) et \(M = 40\), on peut en déduire la production :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prod\_val }\OperatorTok{=}\NormalTok{ production(}\DecValTok{60}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(prod\_val)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 46.289449781254994
\end{lstlisting}

On peut noter que le nom des paramètres n'a pas été mentionné ici. Lors de l'appel de la fonction, la valeur du premier paramètre a été attribué au paramètre défini en premier (\texttt{l}), celle du second au second paramètre (\texttt{k}) et enfin celle du troisième au troisième paramètre (\texttt{m}).

\subsubsection{Paramètres positionnels paramètres par mots-clés}\label{paramuxe8tres-positionnels-paramuxe8tres-par-mots-cluxe9s}

Il existe deux types de paramètres que l'on peut donner à une fonction en Python :

\begin{itemize}
\tightlist
\item
  les paramètres positionnels ;
\item
  les paramètres par mots-clés.
\end{itemize}

Contrairement aux paramètres positionnels, les paramètres par mot clé ont une valeur attribuée par défaut. On parle de paramètre formel pour désigner les paramètres de la fonction (les variables utilisées dans le corps de la fonction) et de paramètre effectif pour désigner la valeur que l'on souhaite donner au paramètre formel. Pour définir la valeur à donner à un paramètre formel, on utilise le symbol d'égalité. Lors de l'appel de la fonction, si l'utilisateur ne définit pas explicitement une valeur, celle par défaut sera affectée. Ainsi, il n'est pas forcément nécessaire de préciser les paramètres par mots-clés lors de l'appel de la fonction.

Il est important de noter que les arguments positionnels (ceux qui n'ont pas de valeur par défaut) doivent apparaître en premier dans la liste des paramètres.

Prenons un exemple avec deux paramètres positionnels (\texttt{l} et \texttt{m}) et un paramètre par mot-clé (\texttt{k}) :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ production\_2(l, m, k}\OperatorTok{=}\DecValTok{42}\NormalTok{):}
  \CommentTok{"""}
\CommentTok{  Retourne la valeur de la production en fonction}
\CommentTok{  du travail, du capital et du matériel.}
\CommentTok{  }
\CommentTok{  Keyword arguments:}
\CommentTok{  l {-}{-} travail (float)}
\CommentTok{  m {-}{-} matériel (float)}
\CommentTok{  k {-}{-} capital (float) (default 42)}
\CommentTok{  """}
  \ControlFlowTok{return}\NormalTok{ l}\OperatorTok{**}\FloatTok{0.3} \OperatorTok{*}\NormalTok{ k}\OperatorTok{**}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ m}\OperatorTok{**}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La fonction \texttt{production\_2()} peut s'appeler, pour donner le même résultat, des trois manières suivantes :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# En nommant tous les paramètres, en ommettant k}
\NormalTok{prod\_val\_1 }\OperatorTok{=}\NormalTok{ production\_2(l }\OperatorTok{=} \DecValTok{42}\NormalTok{, m }\OperatorTok{=} \DecValTok{40}\NormalTok{)}
\CommentTok{\# En nommant tous les paramètres et en précisant k}
\NormalTok{prod\_val\_2 }\OperatorTok{=}\NormalTok{ production\_2(l }\OperatorTok{=} \DecValTok{42}\NormalTok{, m }\OperatorTok{=} \DecValTok{40}\NormalTok{, k }\OperatorTok{=} \DecValTok{42}\NormalTok{)}
\CommentTok{\# En nommant uniquement le paramètre mot{-}clé k}
\NormalTok{prod\_val\_3 }\OperatorTok{=}\NormalTok{ production\_2(}\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{, k }\OperatorTok{=} \DecValTok{42}\NormalTok{)}
\CommentTok{\# En ne nommant aucun paramètre}
\NormalTok{prod\_val\_4 }\OperatorTok{=}\NormalTok{ production\_2(}\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{42}\NormalTok{)}

\NormalTok{res }\OperatorTok{=}\NormalTok{ [prod\_val\_1, prod\_val\_2, prod\_val\_3, prod\_val\_4]}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [41.59215573604822, 41.59215573604822, 41.59215573604822, 41.59215573604822]
\end{lstlisting}

\begin{remarque}
Si la fonction contient plusieurs paramètres positionnels ; lors de l'appel :

\begin{itemize}
\tightlist
\item
  soit on nomme tous les paramètres positonnels par leur nom ;
\item
  soit aucun ;
\item
  il n'y a pas d'entre deux.
\end{itemize}
\end{remarque}

Du moment que tous les paramètres positionnels sont nommés lors de l'appel, on peut les faire figurer dans des ordres différents :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ production\_3(a, l, m }\OperatorTok{=} \DecValTok{40}\NormalTok{, k}\OperatorTok{=}\DecValTok{42}\NormalTok{):}
  \CommentTok{"""}
\CommentTok{  Retourne la valeur de la production en fonction}
\CommentTok{  de la productivité, du travail, du capital et du matériel.}
\CommentTok{  }
\CommentTok{  Keyword arguments:}
\CommentTok{  a {-}{-} productivité totale des facteurs (float)}
\CommentTok{  l {-}{-} travail (float)}
\CommentTok{  m {-}{-} matériel (float) (default 40)}
\CommentTok{  k {-}{-} capital (float) (default 42)}
\CommentTok{  """}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ l}\OperatorTok{**}\FloatTok{0.3} \OperatorTok{*}\NormalTok{ k}\OperatorTok{**}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ m}\OperatorTok{**}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
  
\NormalTok{prod\_val\_1 }\OperatorTok{=}\NormalTok{ production\_3(}\DecValTok{1}\NormalTok{, }\DecValTok{42}\NormalTok{, m }\OperatorTok{=} \DecValTok{38}\NormalTok{)}
\NormalTok{prod\_val\_2 }\OperatorTok{=}\NormalTok{ production\_3(a }\OperatorTok{=} \DecValTok{1}\NormalTok{, l }\OperatorTok{=} \DecValTok{42}\NormalTok{)}
\NormalTok{prod\_val\_3 }\OperatorTok{=}\NormalTok{ production\_3(l }\OperatorTok{=} \DecValTok{42}\NormalTok{, a }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{prod\_val\_4 }\OperatorTok{=}\NormalTok{ production\_3(m }\OperatorTok{=} \DecValTok{40}\NormalTok{, l }\OperatorTok{=} \DecValTok{42}\NormalTok{, a }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\NormalTok{res }\OperatorTok{=}\NormalTok{ [prod\_val\_1, prod\_val\_2, prod\_val\_3, prod\_val\_4]}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [41.16765711449734, 41.59215573604822, 41.59215573604822, 41.59215573604822]
\end{lstlisting}

\subsubsection{Fonction comme paramètre}\label{fonction-comme-paramuxe8tre}

Une fonction peut être fournie en paramètre à une autre fonction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ carre(x):}
  \CommentTok{"""Retourne le carré de x"""}
  \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
  
\KeywordTok{def}\NormalTok{ appliquer\_carre\_4(fun):}
  \CommentTok{"""Applique la fonction \textasciigrave{}fun\textasciigrave{} à 4"""}
  \ControlFlowTok{return}\NormalTok{ fun(}\DecValTok{4}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(appliquer\_carre\_4(carre))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 16
\end{lstlisting}

\section{Portée}\label{portuxe9e}

Lorsque une fonction est appelée, le corps de cette fonction est interprété. Les variables ayant été définies dans le corps de la fonction sont assignées à un \emph{namespace} local. C'est-à-dire qu'elles ne vivent qu'à l'intérieur ce cet espace local, qui est créé au moment de l'appel de la fonction et détruit à la fin de celui ci. On parle alors de portée des variables. Ainsi, une variable ayant une portée locale (assignée dans l'espace local) peut avoir le même nom qu'une variable globale (définie dans l'espace de travail global), sans pour autant désigner le même objet, ou écraser cet objet.

Regardons cela à travers un exemple.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Définition d\textquotesingle{}une variable globale :}
\NormalTok{valeur }\OperatorTok{=} \DecValTok{1}

\CommentTok{\# Définition d\textquotesingle{}une variable locale à la fonction f}
\KeywordTok{def}\NormalTok{ f(x):}
\NormalTok{  valeur }\OperatorTok{=} \DecValTok{2}
\NormalTok{  nouvelle\_valeur }\OperatorTok{=} \DecValTok{3}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"valeur vaut :"}\NormalTok{, valeur)}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"nouvelle\_valeur vaut :"}\NormalTok{, nouvelle\_valeur)}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ valeur}
\end{Highlighting}
\end{Shaded}

Appelons la fonction \texttt{f()}, puis regardons la valeur de \texttt{valeur} et celle de \texttt{nouvelle\_valeur} après l'exécution de la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OperatorTok{=}\NormalTok{ f(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## valeur vaut : 2
## nouvelle_valeur vaut : 3
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"valeur vaut :"}\NormalTok{, valeur)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## valeur vaut : 1
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"nouvelle\_valeur vaut :"}\NormalTok{, nouvelle\_valeur)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## NameError: name 'nouvelle_valeur' is not defined
\end{lstlisting}

Comme on peut le constater, durant l'appel, la variable locale du nom \texttt{valeur} valait 2. Cette variable ne faisait pas référence à la variable du même nom définie dans l'environnement global. À l'issue de l'exécution de la fonction \texttt{f()}, cette variable \texttt{valeur} locale est supprimée, et il en est de même pour la variable locale \texttt{nouvelle\_valeur}, qui n'existe pas dans l'environnement gloabl (d'où l'erreur retournée).

Sans trop rentrer trop dans les détails, il semble important de connaître quelques principes à propos de la portée des variables. Les variables sont définies dans des environnements, qui sont embriqués les uns dans les autres. Si une variable n'est pas définie dans le corps d'une fonction, Python ira chercher dans un environnement parent.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valeur }\OperatorTok{=} \DecValTok{1}
\KeywordTok{def}\NormalTok{ f(x):}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ valeur}
  
\BuiltInTok{print}\NormalTok{(f(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

Si on définit une fonction à l'intérieur d'une autre fonction, et qu'on appelle une variable non définie dans le corps de cette fonction, Python ira chercher dans l'environnement directement supérieur. S'il ne trouve pas, il ira chercher dans l'environnement encore supérieur, et ainsi de suite jusqu'à l'environnement global.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La variable valeur n\textquotesingle{}est pas définie dans}
\CommentTok{\# l\textquotesingle{}environnement local de g().}
\CommentTok{\# Python va alors chercher dans f().}
\NormalTok{valeur }\OperatorTok{=} \DecValTok{1}
\KeywordTok{def}\NormalTok{ f():}
\NormalTok{  valeur }\OperatorTok{=} \DecValTok{2}
  \KeywordTok{def}\NormalTok{ g(x):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ valeur}

  \ControlFlowTok{return}\NormalTok{ g(}\DecValTok{2}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(f())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La variable valeur n\textquotesingle{}est définie ni dans g() ni dans f()}
\CommentTok{\# mais dans l\textquotesingle{}environnement supérieur (ici, global)}
\NormalTok{valeur }\OperatorTok{=} \DecValTok{1}
\KeywordTok{def}\NormalTok{ f():}
  \KeywordTok{def}\NormalTok{ g(x):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ valeur}

  \ControlFlowTok{return}\NormalTok{ g(}\DecValTok{2}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(f())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 3
\end{lstlisting}

Si on définit une variable dans le corps d'une fonction et que l'on souhaite qu'elle soit accessible dans l'environnement global, on peut utiliser le mot-clé \texttt{global} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ f(x):}
  \KeywordTok{global}\NormalTok{ y}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{+}\DecValTok{1}

\NormalTok{f(}\DecValTok{3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4
\end{lstlisting}

\begin{remarque}
La variable que l'on souhaite définir de manière globale depuis un espace local de la fonction ne doit pas avoir le même nom d'un des paramètres.
\end{remarque}

\section{Fonctions lambda}\label{fonctions-lambda}

Python propose ce que l'on appelle des fonctions lambdas, ou encore des fonctions anonymes. Une fonction lambda ne possède qu'une seule instruction dont le résultat est celui de la fonction.

On les définit à l'aide du mot-clé \texttt{lambda}. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nom\_fonction }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ parametres : retour}
\end{Highlighting}
\end{Shaded}

Les paramètres sont à séparer par des virugles.

Reprenons la fonction \texttt{carre()} créée précédemment :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ carre(x):}
  \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

La fonction lambda équivalent s'écrit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{carre\_2 }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ x: x}\OperatorTok{**}\DecValTok{2}
\BuiltInTok{print}\NormalTok{(carre\_2(}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 16
\end{lstlisting}

Avec plusieurs paramètres, regardons la fonction lambda équivalente à la fonction \texttt{produduction()} :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ production(l, k, m):}
  \CommentTok{"""}
\CommentTok{  Retourne la valeur de la production en fonction}
\CommentTok{  du travail, du capital et du matériel.}
\CommentTok{  }
\CommentTok{  Keyword arguments:}
\CommentTok{  l {-}{-} travail (float)}
\CommentTok{  k {-}{-} capital (float)}
\CommentTok{  m {-}{-} matériel (float)}
\CommentTok{  """}
  \ControlFlowTok{return}\NormalTok{ l}\OperatorTok{**}\FloatTok{0.3} \OperatorTok{*}\NormalTok{ k}\OperatorTok{**}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ m}\OperatorTok{**}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{production\_2 }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ l,k,m : l}\OperatorTok{**}\FloatTok{0.3} \OperatorTok{*}\NormalTok{ k}\OperatorTok{**}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ m}\OperatorTok{**}\NormalTok{(}\FloatTok{0.2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(production(}\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{42}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 40.987803063838406
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(production\_2(}\DecValTok{42}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{42}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 40.987803063838406
\end{lstlisting}

\section{Retour de plusieurs valeurs}\label{retour-de-plusieurs-valeurs}

Il peut parfois être pratique de retourner plusieurs éléments en retour d'une fonction. Bien que la liste se porte candidate à cette fonctionnalité, il peut-être plus avisé d'utiliser un dictionnaire, pour pouvoir accéder aux valeurs grâce à leur clé !

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ statistics}
\KeywordTok{def}\NormalTok{ stat\_des(x):}
  \CommentTok{"""Retourne la moyenne et l\textquotesingle{}écart{-}type de \textasciigrave{}x\textasciigrave{}"""}
  \ControlFlowTok{return}\NormalTok{ \{}\StringTok{"moyenne"}\NormalTok{: statistics.mean(x),}
  \StringTok{"ecart\_type"}\NormalTok{: statistics.stdev(x)\}}

\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{]}
\NormalTok{res }\OperatorTok{=}\NormalTok{ stat\_des(x)}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'moyenne': 3.9, 'ecart_type': 2.8460498941515415}
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"La moyenne vaut }\SpecialCharTok{\{\}}\StringTok{ et l\textquotesingle{}écart{-}type vaut }\SpecialCharTok{\{\}}\StringTok{"}
\BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(res[}\StringTok{"moyenne"}\NormalTok{], res[}\StringTok{"ecart\_type"}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## La moyenne vaut 3.9 et l'écart-type vaut 2.8460498941515415
\end{lstlisting}

\section{Exercice}\label{exercice-6}

\begin{exframe}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer une fonction nommée \texttt{somme\_n\_entiers} qui retourne la somme des \(n\) premiers entiers. Son seul paramètre sera \texttt{n}.
\item
  À l'aide d'une boucle, afficher la somme des 2 premiers entiers, puis 3 premiers entiers, puis 4 premiers entiers, etc. jusqu'à 10.
\item
  Créer une fonction qui à partir de deux points représentés par des couples de coordonnées (\(x_1\), \(y_1\)) et (\(x_2\), \(y_2\)) retourne la distance euclidienne entre ces deux points. Proposer une seconde solution à l'aide d'une fonction lambda.
\end{enumerate}
\end{exframe}

\chapter{Introduction à Numpy}\label{numpy}

Ce chapitre est consacré à une librairie importante pour les calculs numérique : \texttt{NumPy} (abréviation de \emph{Numerical Python}).

Il est coutume d'importer \texttt{NumPy} en lui attribuant l'alias \texttt{np} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

\section{Tableaux}\label{numpy-tableaux}

NumPy propose une structure de données populaire, les tableaux (de type \emph{array}), sur lesquels il est possible d'effectuer de manière efficace des calculs. Les tableaux sont une structure notamment utile pour effectuer des opérations statistiques basiques ainsi que de la génération pseudo-aléatoire de nombres.

La stucture des tableaux ressemble à celle des listes, mais ces dernières sont moins rapides à être traitées et utilisent davantage de mémoire. Le gain de vitesse de traitement des tableaux en \texttt{NumPy} vient du fait que les données sont stockées dans des blocs contigus de mémoire, facilitant ainsi les accès en lecture.

Pour s'en convaincre, on peut reprendre l'exemple de Pierre Navaro \href{https://github.com/pnavaro/python-notebooks/blob/master/13.Numpy.ipynb}{donné dans son \emph{notebook} sur \texttt{NumPy}}. Créons deux listes de longueur 1000 chacune, avec des nombres tirés aléatoirement à l'aide de la fonction \texttt{random()} du module \texttt{random}. Divisons chaque élément de la première liste par l'élément à la même position dans la seconde ligne, puis calculons la somme de ces 1000 divisions. Regardons ensuite le temps d'exécution à l'aide de la fonction magique \texttt{\%timeit} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ random}
\ImportTok{from}\NormalTok{ operator }\ImportTok{import}\NormalTok{ truediv}
\NormalTok{l1 }\OperatorTok{=}\NormalTok{ [random() }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1000}\NormalTok{)]}
\NormalTok{l2 }\OperatorTok{=}\NormalTok{ [random() }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1000}\NormalTok{)]}
\CommentTok{\# \%timeit s = sum(map(truediv,l1,l2))}
\end{Highlighting}
\end{Shaded}

(décommenter la dernière ligne et tester sur un Jupyter Notebook)

À présent, transformons les deux listes en tableaux \texttt{NumPy} avec la méthode \texttt{array()}, et effectuons le même calcul à l'aide d'une méthode \texttt{NumPy} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a1 }\OperatorTok{=}\NormalTok{ np.array(l1)}
\NormalTok{a2 }\OperatorTok{=}\NormalTok{ np.array(l2)}
\CommentTok{\# \%timeit s = np.sum(a1/a2)}
\end{Highlighting}
\end{Shaded}

Comme on peut le constater en exécutant ces codes dans un environnement IPython, le temps d'exécution est bien plus rapide avec les méthodes de \texttt{NumPy} pour ce calcul.

\subsection{Création}\label{cruxe9ation}

La création d'un tableau peut s'effectuer avec la méthode \texttt{array()}, à partir d'une liste, comme nous venon de le faire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{]}
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array(liste)}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1 2 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(tableau))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Si on fournit à \texttt{array()} une liste de listes imbriquées de même longueur, un tableau multidimensionnel sera créé :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste\_2 }\OperatorTok{=}\NormalTok{ [ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{] ]}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ np.array(liste\_2)}
\BuiltInTok{print}\NormalTok{(tableau\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1 2 3]
##  [4 5 6]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(tableau\_2))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Les tableaux peuvent aussi être créés à partir de n-uplets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nuplet }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array(nuplet)}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1 2 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(tableau))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Un tableau en dimension 1 peut être changé en tableau en dimension 2 (si possible), en modifiant son attribut \texttt{shape} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{tableau.shape }\OperatorTok{=}\NormalTok{ (}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[3 2]
##  [5 1]
##  [6 5]]
\end{lstlisting}

\subsubsection{\texorpdfstring{Quelques fonctions générant des \texttt{array}}{Quelques fonctions générant des array}}\label{quelques-fonctions-guxe9nuxe9rant-des-array}

Certaines fonctions de \texttt{NumPy} produisent des tableaux pré-remplis. C'est le cas de la fonction \texttt{zeros()}. Quand on lui fournit une valeur entière \(n\), la fonction \texttt{zeros()} créé un tableau à une dimension, avec \(n\) 0 :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.zeros(}\DecValTok{4}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0. 0. 0. 0.]
\end{lstlisting}

On peut préciser le type des zéros (par exemple \texttt{int}, \texttt{int32}, \texttt{int64}, \texttt{float}, \texttt{float32}, \texttt{float64}, etc.), à l'aide du paramètre \texttt{dtype} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.zeros(}\DecValTok{4}\NormalTok{, dtype }\OperatorTok{=} \StringTok{"int"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 0 0 0]
\end{lstlisting}

D'avantage d'explications sur les types de données avec \texttt{NumPy} sont disponibles \href{https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.dtypes.html}{sur la documentation en ligne}.

Le type des éléments d'un tableau est indiqué dans l'attribut \texttt{dtype} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.zeros(}\DecValTok{4}\NormalTok{, dtype }\OperatorTok{=} \StringTok{"int"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x, x.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 0 0 0] int64
\end{lstlisting}

Il est par ailleurs possible de convertir le type des éléments dans un un autre type, à l'aide de la méthode \texttt{astype()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ x.astype(}\StringTok{"float"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x, x.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 0 0 0] int64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y, y.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0. 0. 0. 0.] float64
\end{lstlisting}

Quand on lui fournit un n-uplet de longueur supérieure à 1, \texttt{zeros()} créé un tableau à plusieurs dimensions :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.zeros((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[0. 0. 0.]
##  [0. 0. 0.]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.zeros((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[[0. 0. 0. 0.]
##   [0. 0. 0. 0.]
##   [0. 0. 0. 0.]]
## 
##  [[0. 0. 0. 0.]
##   [0. 0. 0. 0.]
##   [0. 0. 0. 0.]]]
\end{lstlisting}

La fonction \texttt{empty()} de \texttt{Numpy} retourne également un tableau sur le même principe que \texttt{zeros()}, mais sans initialiser les valeurs à l'intérieur.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.empty((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), dtype }\OperatorTok{=} \StringTok{"int"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[0 0 0]
##  [0 0 0]]
\end{lstlisting}

La fonction \texttt{ones()} de \texttt{Numpy} retourne le même genre de tableaux, avec des 1 en valeurs initialisées :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.ones((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), dtype }\OperatorTok{=} \StringTok{"float"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1. 1. 1.]
##  [1. 1. 1.]]
\end{lstlisting}

Pour choisir une valeur spécifique pour l'initialisation, on peut utiliser la fonction \texttt{full()} de \texttt{Numpy} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.full((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), }\DecValTok{10}\NormalTok{, dtype }\OperatorTok{=} \StringTok{"float"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[10. 10. 10.]
##  [10. 10. 10.]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.full((}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), np.inf) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[inf inf inf]
##  [inf inf inf]]
\end{lstlisting}

La fonction \texttt{eye()} de \texttt{Numpy} créé un tableau à deux dimensions dans laquelle tous les éléments sont initalisés à zéro, sauf ceux de la diagonale initialisés à 1 :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.eye(}\DecValTok{2}\NormalTok{, dtype}\OperatorTok{=}\StringTok{"int64"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1 0]
##  [0 1]]
\end{lstlisting}

En modifiant le paramètre mot-clé \texttt{k}, on peut décaler la diagonale :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.eye(}\DecValTok{3}\NormalTok{, k}\OperatorTok{={-}}\DecValTok{1}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[0. 0. 0.]
##  [1. 0. 0.]
##  [0. 1. 0.]]
\end{lstlisting}

La fonction \texttt{identity()} de \texttt{Numpy} créé quant à elle une matrice identité sous la forme d'un tableau :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.identity(}\DecValTok{3}\NormalTok{, dtype }\OperatorTok{=} \StringTok{"int"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[1 0 0]
##  [0 1 0]
##  [0 0 1]]
\end{lstlisting}

La fonction \texttt{arange()} de \texttt{Numpy} permet de générer une séquence de nombres séparés par un interval fixe, le tout stocké dans un tableau. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.arange( start, stop, step, dtype )}
\end{Highlighting}
\end{Shaded}

avec \texttt{start} la valeur de départ, \texttt{stop} celle d'arrivée, \texttt{step} le pas, l'espacement entre les nombres de la séquence et \texttt{dtype} le type des nombres :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.arange(}\DecValTok{5}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 1 2 3 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.arange(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [2 3 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( np.arange(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [2 4 6 8]
\end{lstlisting}

\subsection{Dimensions}\label{dimensions}

Pour connaître la dimension d'un tableau, on peut afficher la valeur de l'attribut \texttt{ndim} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"ndim tableau : "}\NormalTok{, tableau.ndim)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ndim tableau :  2
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"ndim tableau\_2 : "}\NormalTok{, tableau\_2.ndim)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ndim tableau_2 :  2
\end{lstlisting}

Le nombre d'éléments dans le tableau peut s'obtenir par l'attribut \texttt{size} ou par la fonction \texttt{size()} de \texttt{Numpy} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"size tableau : "}\NormalTok{, tableau.size)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## size tableau :  6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"size tableau\_2 : "}\NormalTok{, tableau\_2.size)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## size tableau_2 :  6
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"np.size(tableau) :"}\NormalTok{, np.size(tableau))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## np.size(tableau) : 6
\end{lstlisting}

L'attribut \texttt{shape} retourne un n-uplet indiquant la longueur pour chaque dimension du tableau :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"size tableau : "}\NormalTok{, tableau.shape)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## size tableau :  (3, 2)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"size tableau\_2 : "}\NormalTok{, tableau\_2.shape)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## size tableau_2 :  (2, 3)
\end{lstlisting}

\subsection{Extraction des éléments d'un tableau}\label{extraction-des-uxe9luxe9ments-dun-tableau}

L'accès aux éléments d'un tableau se fait de la même manière que pour les listes (c.f. Section~\ref{structure-liste-extraction}), grâce à l'indiçage. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau[lower:upper:step]}
\end{Highlighting}
\end{Shaded}

avec \texttt{lower} la borne inférieur de la plage d'indices, \texttt{upper} la plage supérieur, et \texttt{step} l'espacement entre les valeurs.

\begin{itemize}
\tightlist
\item
  Lorsque \texttt{lower} n'est pas précisé, le premier élément (indicé 0) est considéré comme la valeur attribuée à \texttt{lower}.
\item
  Lorsque \texttt{upper} n'est pas précisé, le dernier élément est considéré comme la valeur attribuée à \texttt{upper}.
\item
  Lorsque \texttt{step} n'est pas précisé, un pas de 1 est attribué par défaut.
\end{itemize}

Reprenons rapidement quelques exemples, en s'appuyant sur deux objets : un tableau de dimension 1, et un second de dimension 2.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_1 }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{,}\DecValTok{13}\NormalTok{)}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ [ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ np.array(tableau\_2)}
\end{Highlighting}
\end{Shaded}

L'accès au premier élément :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"tableau\_}\SpecialCharTok{\{\}}\StringTok{[0] : }\SpecialCharTok{\{\}}\StringTok{ (type : }\SpecialCharTok{\{\}}\StringTok{)"}
\BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(}\DecValTok{0}\NormalTok{, tableau\_1[}\DecValTok{0}\NormalTok{], }\BuiltInTok{type}\NormalTok{(tableau\_1[}\DecValTok{0}\NormalTok{])))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_0[0] : 1 (type : <class 'numpy.int64'>)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(message.}\BuiltInTok{format}\NormalTok{(}\DecValTok{1}\NormalTok{, tableau\_2[}\DecValTok{0}\NormalTok{], }\BuiltInTok{type}\NormalTok{(tableau\_2[}\DecValTok{0}\NormalTok{])))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_1[0] : [1 2 3] (type : <class 'numpy.ndarray'>)
\end{lstlisting}

L'accès aux éléments peut se faire en partant par la fin :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_1[{-}1] : "}\NormalTok{, tableau\_1[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]) }\CommentTok{\# dernier élément}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_1[-1] :  12
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_2[{-}1] : "}\NormalTok{, tableau\_2[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]) }\CommentTok{\# dernier élément}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_2[-1] :  [10 11 12]
\end{lstlisting}

Le découpage est possible :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# les éléments du 2e (non inclus) au 4e}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Slice Tableau 1 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_1[}\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Slice Tableau 1 : 
##  [3 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sclie Tableau 2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_2[}\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Sclie Tableau 2 : 
##  [[ 7  8  9]
##  [10 11 12]]
\end{lstlisting}

Pour les tableaux à deux dimensions, on peut accéder aux éléments de la manière suivante, de manière équivalente :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Dans le 3e élément, accéder au 1er élément}
\BuiltInTok{print}\NormalTok{(tableau\_2[}\DecValTok{2}\NormalTok{][}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 7
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(tableau\_2[}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 7
\end{lstlisting}

Pour extraire des colonnes d'un tableau à deux entrées :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Deuxième colonne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_2[:, [}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Deuxième colonne : 
##  [[ 2]
##  [ 5]
##  [ 8]
##  [11]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Deuxièmes et troisièmes colonnes : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_2[:, [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Deuxièmes et troisièmes colonnes : 
##  [[ 2  3]
##  [ 5  6]
##  [ 8  9]
##  [11 12]]
\end{lstlisting}

Pour cette dernière instruction, on indique avec le premier paramètre non renseigné (avant les deux points) que l'on désire tous les éléments de la première dimension, puis, avec la virgule, on indique qu'on regarde à l'intérieur de chaque élément de la première dimension, et qu'on veut les valeurs aux positions 1 et 2 (donc les éléments des colonnes 2 et 3).

Pour extraire seulement certains éléments d'un tableau à 1 dimension, on peut indiquer les indices des éléments à récupérer :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"2e et 4e éléments : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_2[[}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 2e et 4e éléments : 
##  [[ 4  5  6]
##  [10 11 12]]
\end{lstlisting}

\subsubsection{Extraction à l'aide de booléens}\label{extraction-uxe0-laide-de-booluxe9ens}

Pour extraire ou non des éléments d'un tableu, on peut utiliser des tableaux de booléens en tant que masques. L'idée est de fournir un tableau de booléens (un masque) de même dimension que celui pour lequel on désire extraire des éléments sous certaines conditions. Lorsque la valeur du booléen dans le masque vaut \texttt{True}, l'élément correspondant du tableau est retourné ; sinon, il ne l'est pas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{res }\OperatorTok{=}\NormalTok{ tableau[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{]]}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 2 1 4]
\end{lstlisting}

Seuls les éléments en position 1, 3, 5 et 6 on été retournés.

En pratique, le masque n'est que très rarement créé par l'utilisateur, il est plutôt issu d'une instruction logique appliquée au tableau d'intérêt. Par exemple, dans notre tableau, nous pouvons dans un premier temps créer un masque de manière à identifier les éléments pairs :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{masque }\OperatorTok{=}\NormalTok{ tableau }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(masque)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [ True False  True False False  True]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(masque))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Une fois ce masque créé, on peut l'appliquer au tableau pour extraire uniquement les éléments pour lesquels la valeur correspondante dans le masque vaut \texttt{True} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(tableau[masque])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [0 2 4]
\end{lstlisting}

\subsection{Modification}\label{modification-3}

Pour remplacer les valeurs d'un tableau, on utilise le signe égal (\texttt{=}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\NormalTok{tableau[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\DecValTok{11}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{33}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[11 22 33]
##  [ 4  5  6]
##  [ 7  8  9]
##  [10 11 12]]
\end{lstlisting}

Si on fournit un scalaire lors du remplacement, la valeur sera répétée pour tous les éléments de la dimension :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{100}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[100 100 100]
##  [  4   5   6]
##  [  7   8   9]
##  [ 10  11  12]]
\end{lstlisting}

Idem avec un découpage :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{] }\OperatorTok{=} \DecValTok{100}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[100 100 100]
##  [100 100 100]
##  [  7   8   9]
##  [ 10  11  12]]
\end{lstlisting}

D'ailleurs, un découpage avec juste les deux points sans préciser les paramètres de début et de fin du découpage suivi d'un signe égal et d'un nombre remplace toutes les valeurs du tableau par ce nombre :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau[:] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[0 0 0]
##  [0 0 0]
##  [0 0 0]
##  [0 0 0]]
\end{lstlisting}

\subsubsection{Ajout d'éléments}\label{ajout-duxe9luxe9ments-2}

Pour ajouter des éléments, on utilise la fonction \texttt{append()} de \texttt{NumPy}. Il faut noter que l'appel à cette fonction ne modifie pas l'objet auquel on ajoute les valeurs. Si on désire que les modifications sont apportées à cet objet, il faut l'écraser :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 : "}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 :  [1 3 5]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.append(t\_1, }\DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 après l\textquotesingle{}ajout : "}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 après l'ajout :  [1 3 5 1]
\end{lstlisting}

Pour ajouter une colonne à un tableau à deux dimensions :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{], [}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{7}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 : 
##  [[1 2 3]
##  [5 6 7]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ajout\_col\_t\_2 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{4}\NormalTok{], [}\DecValTok{8}\NormalTok{]])}
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ np.append(t\_2,ajout\_col\_t\_2, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 après ajout colonne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 après ajout colonne : 
##  [[1 2 3 4]
##  [5 6 7 8]]
\end{lstlisting}

Pour ajouter une ligne, on utilise la fonction \texttt{vstack()} de \texttt{Numpy} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ajout\_ligne\_t\_2 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{])}
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ np.vstack([t\_2,ajout\_ligne\_t\_2])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 après ajout ligne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 après ajout ligne : 
##  [[ 1  2  3  4]
##  [ 5  6  7  8]
##  [10 11 12 13]]
\end{lstlisting}

\subsubsection{Suppression d'éléments}\label{suppression-duxe9luxe9ments-2}

Pour supprimer des éléments, on utilise la fonction \texttt{delete()} de \texttt{NumPy} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 : "}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 :  [1 3 5 1]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer le dernier élément}
\NormalTok{np.delete(t\_1, (}\OperatorTok{{-}}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([1, 3, 5])
\end{lstlisting}

Note : pour que la suppression soit effective, on assigne le résultat de \texttt{np.delete()} à l'objet.

Pour supprimer plusieurs éléments :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 : "}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 :  [1 3 5 1]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer les 1er et 2e éléments}
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.delete(t\_1, ([}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{]))}
\BuiltInTok{print}\NormalTok{(t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [3 1]
\end{lstlisting}

Pour supprimer une colonne d'un tableau à deux dimensions :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 : "}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 :  [[ 1  2  3  4]
##  [ 5  6  7  8]
##  [10 11 12 13]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer la première colonne :}
\NormalTok{np.delete(t\_2, (}\DecValTok{0}\NormalTok{), axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[ 2,  3,  4],
##        [ 6,  7,  8],
##        [11, 12, 13]])
\end{lstlisting}

Supprimer plusieurs colonnes :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 : "}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 :  [[ 1  2  3  4]
##  [ 5  6  7  8]
##  [10 11 12 13]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer la 1ère et la 3e colonne :}
\NormalTok{np.delete(t\_2, ([}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]), axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[ 2,  4],
##        [ 6,  8],
##        [11, 13]])
\end{lstlisting}

Et pour supprimer une ligne :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 : "}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 :  [[ 1  2  3  4]
##  [ 5  6  7  8]
##  [10 11 12 13]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer la première ligne :}
\NormalTok{np.delete(t\_2, (}\DecValTok{0}\NormalTok{), axis}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[ 5,  6,  7,  8],
##        [10, 11, 12, 13]])
\end{lstlisting}

Supprimer plusieurs lignes :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_2 : "}\NormalTok{, t\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_2 :  [[ 1  2  3  4]
##  [ 5  6  7  8]
##  [10 11 12 13]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Supprimer la 1ère et la 3e ligne}
\NormalTok{np.delete(t\_2, ([}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]), axis}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[5, 6, 7, 8]])
\end{lstlisting}

\subsection{Copie de tableau}\label{copie-de-tableau}

La copie d'un tableau, comme pour les listes (c.f. Section~\ref{copie-de-liste}), ne doit pas se faire avec le symbole égal (\texttt{=}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ tableau\_1}
\end{Highlighting}
\end{Shaded}

Modifions le premier élément de \texttt{tableau\_2}, et observons le contenu de \texttt{tableau\_2} et de \texttt{tableau\_1} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau 1 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau 1 : 
##  [0 2 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau 2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau 2 : 
##  [0 2 3]
\end{lstlisting}

Comme on peut le constater, le fait d'avoir utilisé le signe égal a simplement créé une référence et non pas une copie.

Pour effectuer une copie de tableaux, plusieurs façons existent. Parmi elles, l'utilisation de la fonction \texttt{np.array()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ np.array(tableau\_1)}
\NormalTok{tableau\_2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_1 : "}\NormalTok{, tableau\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_1 :  [1 2 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_2 : "}\NormalTok{, tableau\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_2 :  [0 2 3]
\end{lstlisting}

On peut également utiliser la méthode \texttt{copy()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ tableau\_1.copy()}
\NormalTok{tableau\_2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_1 : "}\NormalTok{, tableau\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_1 :  [1 2 3]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_2 : "}\NormalTok{, tableau\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_2 :  [0 2 3]
\end{lstlisting}

On peut noter que lorsque l'on fait un découpement, un nouvel objet est créé, pas une référence :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{tableau\_2 }\OperatorTok{=}\NormalTok{ tableau\_1[:}\DecValTok{2}\NormalTok{]}
\NormalTok{tableau\_2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_1 : "}\NormalTok{, tableau\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_1 :  [0 2 3 4]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_2 : "}\NormalTok{, tableau\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_2 :  [0 2]
\end{lstlisting}

\subsection{Tri}\label{tri-1}

La librairie \texttt{NumPy} fournit une fonction pour trier les tableaux : \texttt{sort()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau trié : "}\NormalTok{, np.sort(tableau))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau trié :  [1 2 3 5 5 6]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau : "}\NormalTok{, tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau :  [3 2 5 1 6 5]
\end{lstlisting}

Comme on peut le constater, la fonction \texttt{sort()} de \texttt{NumPy} propose une vue : le tableau n'est pas modifié, ce qui n'est pas le cas si on utilise la méthode \texttt{sort()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{tableau.sort()}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Le tableau a été modifié : "}\NormalTok{, tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Le tableau a été modifié :  [1 2 3 5 5 6]
\end{lstlisting}

\subsection{Transposition}\label{transposition-tableau}

Pour obtenir la transposée d'un tableau, on fait appel à l'attribut \texttt{T}. Il faut noter que l'on obtient une vue de l'objet, que cela ne le modifie pas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{tableau.shape }\OperatorTok{=}\NormalTok{ (}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau : 
##  [[3 2]
##  [5 1]
##  [6 5]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tableau transposé : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau.T)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Tableau transposé : 
##  [[3 5 6]
##  [2 1 5]]
\end{lstlisting}

On peut également utiliser la fonction \texttt{transpose()} de \texttt{NumPy} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.transpose(tableau))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[3 5 6]
##  [2 1 5]]
\end{lstlisting}

Attention, si on assigne un nom à la transposée, que ce soit en utilisant l'attribut \texttt{T} ou la méthode \texttt{np.transpose()}, cela créé une référence, pas une copie d'élément\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_transpose }\OperatorTok{=}\NormalTok{ np.transpose(tableau)}
\NormalTok{tableau\_transpose[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{99}
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau : 
##  [[99  2]
##  [ 5  1]
##  [ 6  5]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_transpose : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tableau\_transpose)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_transpose : 
##  [[99  5  6]
##  [ 2  1  5]]
\end{lstlisting}

Pour savoir si un tableau est une vue ou non, on peut afficher l'attribut \texttt{base}, qui retourne \texttt{None} si ce n'est pas le cas :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau : "}\NormalTok{, tableau.base)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau :  None
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"tableau\_transpose : "}\NormalTok{, tableau\_transpose.base)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## tableau_transpose :  [[99  2]
##  [ 5  1]
##  [ 6  5]]
\end{lstlisting}

\subsection{Opérations sur les tableaux}\label{operations-tableaux}

Il est possible d'utiliser des opérateurs sur les tableaux. Leur effet nécessite quelques explications.

\subsubsection{\texorpdfstring{Opérateurs \texttt{+} et \texttt{-}}{Opérateurs + et -}}\label{opuxe9rateurs-et--}

Lorsque l'opérateur \texttt{+} (\texttt{-}) est utilisé entre deux tableaux de même dimension, une addition (soustraction) terme à terme est effectuée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{])}
\NormalTok{t\_3 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\NormalTok{t\_4 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{16}\NormalTok{], [}\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{20}\NormalTok{], [}\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{24}\NormalTok{]])}
\NormalTok{t\_1 }\OperatorTok{+}\NormalTok{ t\_2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([ 6,  8, 10, 12])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_3 }\OperatorTok{+}\NormalTok{ t\_4}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[14, 16, 18, 20],
##        [22, 24, 26, 28],
##        [30, 32, 34, 36]])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{{-}}\NormalTok{ t\_2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([-4, -4, -4, -4])
\end{lstlisting}

Lorsque l'opérateur \texttt{+} (\texttt{-}) est utilisé entre un scalaire et un tableau, le scalaire est ajouté (soustrait) à tous les éléments du tableau :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 + 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1 }\OperatorTok{+} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 + 3 : 
##  [4 5 6 7]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 + 3. : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1 }\OperatorTok{+} \FloatTok{3.}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 + 3. : 
##  [4. 5. 6. 7.]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_3 + 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_3 }\OperatorTok{+} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_3 + 3 : 
##  [[ 4  5  6  7]
##  [ 8  9 10 11]
##  [12 13 14 15]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_3 {-} 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_3 }\OperatorTok{{-}} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_3 - 3 : 
##  [[-2 -1  0  1]
##  [ 2  3  4  5]
##  [ 6  7  8  9]]
\end{lstlisting}

\subsubsection{\texorpdfstring{Opérateurs \texttt{*} et \texttt{/}}{Opérateurs * et /}}\label{opuxe9rateurs-et}

Lorsque l'opérateur \texttt{*} (\texttt{/}) est utilisé entre deux tableaux de même dimension, une multiplication (division) terme à terme est effectuée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{*}\NormalTok{ t\_2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([ 5, 12, 21, 32])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_3 }\OperatorTok{*}\NormalTok{ t\_4}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[ 13,  28,  45,  64],
##        [ 85, 108, 133, 160],
##        [189, 220, 253, 288]])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_3 }\OperatorTok{/}\NormalTok{ t\_4}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[0.07692308, 0.14285714, 0.2       , 0.25      ],
##        [0.29411765, 0.33333333, 0.36842105, 0.4       ],
##        [0.42857143, 0.45454545, 0.47826087, 0.5       ]])
\end{lstlisting}

Lorsque l'opérateur \texttt{*} (\texttt{/}) est utilisé entre un scalaire et un tableau, tous les éléments du tableau sont multipliés (divisés) par ce scalaire :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 * 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1 }\OperatorTok{*} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 * 3 : 
##  [ 3  6  9 12]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 / 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1 }\OperatorTok{/} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 / 3 : 
##  [0.33333333 0.66666667 1.         1.33333333]
\end{lstlisting}

\subsubsection{Puissance}\label{puissance-1}

Il est également possible d'élever chaque nombre d'un tableau à une puissance donnée :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 ** 3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1 }\OperatorTok{**} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 ** 3 : 
##  [ 1  8 27 64]
\end{lstlisting}

\subsubsection{Opérations sur des matrices}\label{opuxe9rations-sur-des-matrices}

En plus des opérations/soustraction/multiplication/division terme à terme ou par un scalaire, il est possible d'effectuer certains calculs sur des tableaux à deux dimension.

Nous avons déjà vu la tranposée en Section~\ref{transposition-tableau}.

Pour effectuer un produit matriciel, \texttt{NumPy} fournit la fonction \texttt{dot()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.dot(t\_3, t\_4.T)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[150, 190, 230],
##        [382, 486, 590],
##        [614, 782, 950]])
\end{lstlisting}

Il faut bien s'assurer d'avoir des matrices compatibles, sinon, une erreur sera retournée :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.dot(t\_3, t\_4)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ValueError: shapes (3,4) and (3,4) not aligned: 4 (dim 1) != 3 (dim 0)
\end{lstlisting}

Le produit matriciel peut également s'obtenir à l'aide de l'opérateur \texttt{@} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_3 }\OperatorTok{@}\NormalTok{ t\_4.T}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[150, 190, 230],
##        [382, 486, 590],
##        [614, 782, 950]])
\end{lstlisting}

Le produit d'un vecteur avec une matrice est également possible :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.dot(t\_1, t\_3.T)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([ 30,  70, 110])
\end{lstlisting}

\subsection{Opérateurs logiques}\label{opuxe9rateurs-logiques}

Pour effectuer des tests logiques sur les éléments d'un tableau, \texttt{NumPy} propose des fonctions, répertoriées dans le Tableau~\ref{tab:numpy-operateurs-logiques}. Le résultat retourné par l'application de ces fonctions est un tableau de booléens.

\begin{longtable}[]{@{}rr@{}}
\caption{\label{tab:numpy-operateurs-logiques} Fonctions logiques}\tabularnewline
\toprule\noalign{}
Code & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Code & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{greater()} & Supérieur à \\
\texttt{greater\_equal()} & Supérieur ou égal à \\
\texttt{less()} & Inférieur à \\
\texttt{less\_equal()} & Inférieur ou égal à \\
\texttt{equal()} & Égal à \\
\texttt{not\_equal()} & Différent de \\
\texttt{logical\_and()} & Et logique \\
\texttt{logical\_or()} & Ou logique \\
\texttt{logical\_xor()} & XOR logique \\
\end{longtable}

Par exemple, pour obtenir les éléments de \texttt{t} compris entre 10 et 20 (inclus) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{24}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{14}\NormalTok{]])}
\NormalTok{masque }\OperatorTok{=}\NormalTok{ np.logical\_and(t }\OperatorTok{\textless{}=} \DecValTok{20}\NormalTok{, t }\OperatorTok{\textgreater{}=} \DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"masque : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, masque)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## masque : 
##  [[False  True False False]
##  [False  True False False]
##  [False False False  True]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"les éléments de t compris entre 10 et 20 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
\NormalTok{      t[masque])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## les éléments de t compris entre 10 et 20 : 
##  [10 12 14]
\end{lstlisting}

\subsection{Quelques constantes}\label{numpy-constantes}

\texttt{NumPy} propose quelques constantes, dont certaines sont reportées dans le Tableau~\ref{tab:constantes-numpy}.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1970}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8030}}@{}}
\caption{\label{tab:constantes-numpy} Codes de formatages}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{np.inf} & Infini (on obtient \(-\infty\) en écrivant \texttt{-np.inf} ou \texttt{np.NINF}) \\
\texttt{np.nan} & Représentation en tant que nombre à virgule flottante de Not a Number \\
\texttt{np.e} & Constante d'Euler (\(e\)) \\
\texttt{np.euler\_gamma} & Constante d'Euler-Mascheroni (\(\gamma\)) \\
\texttt{np.pi} & Nombre Pi (\(\pi\)) \\
\end{longtable}

On peut noter la présence de la valeur \texttt{NaN}, qui est une valeur spéciale parmi les nombres à virgule flottante. Le comportement de cette constante est spécial.

Quand on additionne, soustrait, multiplie ou divise un nombre par cette valeur \texttt{NaN}, on obtient \texttt{NaN} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Addition : "}\NormalTok{, np.nan }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Addition :  nan
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Soustraction : "}\NormalTok{, np.nan }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Soustraction :  nan
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Multiplication : "}\NormalTok{, np.nan }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Multiplication :  nan
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"AddDivisiontion : "}\NormalTok{, np.nan }\OperatorTok{/} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## AddDivisiontion :  nan
\end{lstlisting}

\subsection{Fonctions universelles}\label{fonctions-universelles}

Les fonctions universelles (\emph{ufunc} pour \emph{universal functions}) sont des fonctions qui peuvent être appliquées terme à terme aux éléments d'un tableau. On distingue deux types de fonctions universelles : les fonctions unaires, qui effectuent une opération sur une seule, et les fonctions binaires qui effectuent une opération sur deux opérandes.

Parmi les \emph{ufuncs}, on retrouve des opérations arithmétiques (addition, multiplication, puissance, valeur absolue, etc.) et des fonctions mathématiques usuelles (fonctions trigonométriques, exponentielle, logarithme, etc.). Le Tableau~\ref{tab:ufuncs-unaires} répertorie quelques fonctions universelles unaires, tandis que le Tableau~\ref{tab:ufuncs-binaires} répertories quelques fonctions universelles binaires.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1970}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8030}}@{}}
\caption{\label{tab:ufuncs-unaires} Fonctions universelles unaires}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{negative(x)} & Opposés des éléments de \texttt{x} \\
\texttt{absolute(x)} & Valeurs absolues des éléments de \texttt{x} \\
\texttt{sign(x)} & Signes des éléments de \texttt{x} (0, 1 ou -1) \\
\texttt{rint(x)} & Arrondi de \texttt{x} à l'entier \\
\texttt{floor(x)} & Troncature de \texttt{x} à l'entier inférieur \\
\texttt{ceil(x)} & Troncature de \texttt{x} à l'entier supérieur \\
\texttt{sqrt(x)} & Racine carrée de \texttt{x} \\
\texttt{square(x)} & Carré de \texttt{x} \\
\texttt{sin(x)}, \texttt{cos(x)}, \texttt{tan(x)} & Sinus (cosinus, et tangente) de \texttt{x} \\
\texttt{sinh(x)}, \texttt{cosh(x)}, \texttt{tanh(x)} & Sinus (cosinus, et tangente) hyperbolique de \texttt{x} \\
\texttt{arcsin(x)}, \texttt{arccos(x)}, \texttt{arctan(x)} & Arc-sinus (arc-cosinus, et arc-tangente) de \texttt{x\ \textbar{}\ \textbar{}\ \textasciigrave{}arcsinh(x)\textasciigrave{},\ \textasciigrave{}arccosh(x)\textasciigrave{},\ \textasciigrave{}arctanh(x)\textasciigrave{}\ \textbar{}\ Arc-sinus\ (arc-cosinus,\ et\ arc-tangente)\ hyperbolique\ de}x \\
\texttt{hypoth(x,y)} & Hypoténuse \(\sqrt{x^2+y^2}\) \\
\texttt{degrees(x)} & Conversion des angles \texttt{x} de radians en degrés \\
\texttt{radians(x)} & Conversion des angles \texttt{x} de degrés en radians \\
\texttt{exp(x)} & Exponentielle de \texttt{x} \\
\texttt{expm1(x)} & \(e^x-1\) \\
\texttt{log(x)} & Logarithme népérien des éléments de \texttt{x} \\
\texttt{log10(x)} & Logatithme des éléments de \texttt{x} en base 10 \\
\texttt{log2(x)} & Logarithme des éléments de \texttt{x} en base 2 \\
\texttt{log1p(x)} & \(ln(1+x\) \\
\texttt{exp2(x)} & \(2^x\) \\
\texttt{isnan(x)} & Tableau de booléens indiquant \texttt{True} pour les éléments \texttt{NaN} \\
\texttt{isfinite(x)} & Tableau de booléens indiquant \texttt{True} pour les éléments non infinis et non-NaN \\
\texttt{isinf(x)} & Tableau de booléens indiquant \texttt{True} pour les éléments infinis \\
\end{longtable}

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1970}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8030}}@{}}
\caption{\label{tab:ufuncs-binaires} Fonctions universelles binaires}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{add(x,y)} & Addition terme à terme de \texttt{x} et \texttt{y} \\
\texttt{subtract(x,y)} & Soustraction terme à terme de \texttt{x} et \texttt{y} \\
\texttt{multiply(x,y)} & Multiplication terme à terme de \texttt{x} et \texttt{y} \\
\texttt{divide(x,y)} & Division terme à terme de \texttt{x} et \texttt{y} \\
\texttt{floor\_divide(x,y)} & Quotients entiers des divisions terme à terme de \texttt{x} et \texttt{y} \\
\texttt{power(x,y)} & Élévation des éléments de \texttt{x} à la puissance des éléments de \texttt{y} \\
\texttt{mod(x,y)} & Restes des divisions eucliennes des éléments de \texttt{x} par ceux de \texttt{y} \\
\texttt{round(x,n)} & Arrondi de \texttt{x} à \(n\) décimales \\
\texttt{arctan2(x,y)} & Angles polaires de \texttt{x} et \texttt{y} \\
\end{longtable}

Pour utiliser ses fonctions, procéder comme dans l'exemple suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\NormalTok{t\_2 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{16}\NormalTok{], [}\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{20}\NormalTok{], [}\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{24}\NormalTok{]])}
\NormalTok{np.log(t\_1) }\CommentTok{\# Logarithme népérien}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[0.        , 0.69314718, 1.09861229, 1.38629436],
##        [1.60943791, 1.79175947, 1.94591015, 2.07944154],
##        [2.19722458, 2.30258509, 2.39789527, 2.48490665]])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.subtract(t\_1, t\_2) }\CommentTok{\# Soustraction des éléments de t\_1 par ceux de t\_2}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([[-12, -12, -12, -12],
##        [-12, -12, -12, -12],
##        [-12, -12, -12, -12]])
\end{lstlisting}

\subsection{Méthodes et fonctions mathématiques et statistiques}\label{muxe9thodes-et-fonctions-mathuxe9matiques-et-statistiques}

\texttt{NumPy} fournit de nombreuses méthodes pour calculer des statistiques sur l'ensemble des valeurs des tableaux, ou sur un des axes des tableaux (par exemple sur l'équivalent de lignes ou des colonnes dans les tableaux à deux dimensions). Certaines sont reportées dans le Tableau~\ref{tab:numpy-maths-methodes}.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1970}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8030}}@{}}
\caption{\label{tab:numpy-maths-methodes} Méthodes mathématiques et statistiques}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{sum()} & Retourne la somme des éléments \\
\texttt{prod()} & Retourne le produit des éléments \\
\texttt{cumsum()} & Retourne la somme cumulée des éléments \\
\texttt{cumprod()} & Retourne le produit cumulé des éléments \\
\texttt{mean()} & Retourne la moyenne \\
\texttt{var()} & Retourne la variance \\
\texttt{std()} & Retourne l'écart-type \\
\texttt{min()} & Retourne la valeur minimale \\
\texttt{max()} & Retourne la valeur maximale \\
\texttt{argmin()} & Retourne l'indice du premier élément à la plus petite valeur \\
\texttt{argmax()} & Retourne l'indice du premier élément à la plus grande valeur \\
\end{longtable}

Donnons un exemple de l'utilisation de ces méthodes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 : 
##  [[ 1  2  3  4]
##  [-1  6  7  8]
##  [ 9 -1 11 12]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Somme des éléments : "}\NormalTok{, t\_1.}\BuiltInTok{sum}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Somme des éléments :  61
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Covariance des éléments : "}\NormalTok{, t\_1.var())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Covariance des éléments :  18.07638888888889
\end{lstlisting}

Pour appliquer ces fonctions sur un axe donné, on modifie la valeur du paramètre \texttt{axis} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Somme par colonne: "}\NormalTok{, t\_1.}\BuiltInTok{sum}\NormalTok{(axis}\OperatorTok{=}\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Somme par colonne:  [ 9  7 21 24]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Somme par ligne: "}\NormalTok{, t\_1.}\BuiltInTok{sum}\NormalTok{(axis}\OperatorTok{=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Somme par ligne:  [10 20 31]
\end{lstlisting}

\texttt{NumPy} offre aussi certaines fonctions spécifiques aux statistiques, dont certaines sont répertoriées dans le Tableau~\ref{tab:numpy-stats-fonctions}.

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2319}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7681}}@{}}
\caption{\label{tab:numpy-stats-fonctions} Fonctions statistiques}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{sum(x)}, \texttt{nansum(x)} & Somme de \texttt{x} (\texttt{nansum(x)} ne tient pas compte des valeurs \texttt{NaN}) \\
\texttt{mean(x)}, \texttt{nanmean()} & Moyenne de \texttt{x} \\
\texttt{median(x)}, \texttt{nanmedian()} & Médiane de \texttt{x} \\
\texttt{average(x)} & Moyenne de \texttt{x} (possibilité d'utiliser des poids à l'aide du paramètre \texttt{weight}) \\
\texttt{min(x)}, \texttt{nanmin()} & Minimum de \texttt{x} \\
\texttt{max(x)}, \texttt{nanmax()} & Maximum de \texttt{x} \\
\texttt{percentile(x,p)}, \texttt{nanpercentile(n,p)} & P-ème percentile de \texttt{x} \\
\texttt{var(x)}, \texttt{nanvar(x)} & Variance de \texttt{x} \\
\texttt{std(x)}, \texttt{nanstd()} & Écart-type de \texttt{x} \\
\texttt{cov(x)} & Covariance de \texttt{x} \\
\texttt{corrcoef(x)} & Coefficients de corrélation \\
\end{longtable}

Pour utiliser les fonctions statistiques :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t\_1 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, t\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## t_1 : 
##  [[ 1  2  3  4]
##  [-1  6  7  8]
##  [ 9 -1 11 12]]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Variance: "}\NormalTok{, np.var(t\_1))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Variance:  18.07638888888889
\end{lstlisting}

Si le tableau comporte des valeurs \texttt{NaN}, pour calculer la somme par exempe, si on utilise \texttt{sum()}, le résultat sera \texttt{NaN}. Pour ignorer les valeurs \texttt{NaN}, on utilise une fonction spécifique (ici, \texttt{nansum()}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_1 }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, np.nan, }\DecValTok{4}\NormalTok{], [}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"somme : "}\NormalTok{, np.}\BuiltInTok{sum}\NormalTok{(t\_1))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## somme :  nan
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"somme en ignorant les NaN : "}\NormalTok{, np.nansum(t\_1))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## somme en ignorant les NaN :  58.0
\end{lstlisting}

Pour calculer une moyenne pondérée (prenons un vecteur) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v\_1 }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\NormalTok{w }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{.5}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Moyenne pondérée : "}\NormalTok{, np.average(v\_1, weights}\OperatorTok{=}\NormalTok{w))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Moyenne pondérée :  1.7142857142857142
\end{lstlisting}

\section{Génération de nombres pseudo-aléatoires}\label{guxe9nuxe9ration-de-nombres-pseudo-aluxe9atoires}

La génération de nombres pseudo-aléatoires est permise par le module \texttt{random} de \texttt{Numpy}. Le lecteur intéressé par les aspects plus statistiques pourra trouver davantage de notions abordées dans le sous-module \texttt{stats} de \texttt{SciPy}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ numpy }\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

Le Tableau~\ref{tab:numpy-pseudo-aleatoires} répertorie quelques fonctions permettant de tirer de manière pseudo-aléatoire des nombres avec le module \texttt{random} de \texttt{Numpy} (en évaluant \texttt{??random}, on obtient une liste exhaustive).

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1970}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8030}}@{}}
\caption{\label{tab:numpy-pseudo-aleatoires} Quelques fonctions de génération de nombres pseudo-aléatoires}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{rand(size)} & Tirage de \texttt{size} valeurs selon une Uniforme \([0,1]\) \\
\texttt{uniform(a,b,size)} & Tirage de \texttt{size} valeurs selon une Uniforme \([a ; b]\) \\
\texttt{randint(a,b,size)} & Tirage de \texttt{size} valeurs selon une Uniforme \([a ; b[\) \\
\texttt{randn(size)} & Tirage de \texttt{size} valeurs selon une Normale centrée réduite \\
\texttt{normal(mu,\ std,\ size)} & Tirage de \texttt{size} valeurs selon une Normale d'espérance \texttt{mu} et d'écart-type \texttt{std} \\
\texttt{binomial(size)} & Tirage de \texttt{size} valeurs selon une \(\mathcal{B}in(n,p)\) \\
\texttt{beta(alpha,\ beta,\ size)} & Tirage de \texttt{size} valeurs selon une loi bêta de paramètres alpha et beta \\
\texttt{poisson(lambda,\ size)} & Tirage de \texttt{size} valeurs selon une loi de Poisson de paramètre lambda \\
\texttt{f(size)} & Tirage de \texttt{size} valeurs selon une \\
\texttt{standard\_t(df,\ size)} & Tirage de \texttt{size} valeurs selon une loi de Student à \texttt{df} degrés de liberté \\
\end{longtable}

Voici un exemple de génération de nombres pseudo aléatoires selon une distribution Gaussienne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.normal(size}\OperatorTok{=}\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [-0.6165344   1.95148123 -1.86209348  0.50318225 -0.01591165  0.78406307
##  -1.46701195  0.43243289 -0.1367816   0.38104131]
\end{lstlisting}

On peut générer un tableau à plusieurs dimensions. Par exemple, un tableau à deux dimensions, dans lequel la première dimension contient 10 éléments, contenant chacun 4 tirages aléatoires selon une \(\mathcal{N}(0,1)\) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.randn(}\DecValTok{10}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [[-1.18606801 -0.97382568 -0.92620411 -0.97554381]
##  [ 0.19770499 -0.52902153  0.82164635  0.65053204]
##  [ 0.89161234  0.01409435 -0.27401799 -0.6460669 ]
##  [-0.07916362 -3.3723024   1.84689071 -0.3811847 ]
##  [-1.22224724  0.21083301  0.687349   -0.55311169]
##  [ 1.13616981 -0.39505067 -0.09516525  2.52330568]
##  [ 0.62623626 -0.42188232 -0.71732701 -2.04049649]
##  [-0.253399    0.81684889  0.21771468  0.57175578]
##  [-1.21945148  0.02836287  0.53427737  0.43329724]
##  [-0.33212777 -1.26458506  0.3862052  -0.62060573]]
\end{lstlisting}

La génération des nombres s'effectue en fonction d'une graine (\emph{seed}), c'est-à-dire un nombre initiant le générateur de nombres pseudo aléatoires. Il est possible de fixer cette graine, pour pouvoir avoir des résultats reproductibles par exemple. Pour ce faire, on peut faire appel à la méthode \texttt{seed()}, à qui on indique une valeur en paramètre :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.random.seed(}\DecValTok{1234}\NormalTok{)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.normal(size}\OperatorTok{=}\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [ 0.47143516 -1.19097569  1.43270697 -0.3126519  -0.72058873  0.88716294
##   0.85958841 -0.6365235   0.01569637 -2.24268495]
\end{lstlisting}

En fixant à nouveau la graîne, on obtiendra exactement le même tirage :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.random.seed(}\DecValTok{1234}\NormalTok{)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.normal(size}\OperatorTok{=}\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [ 0.47143516 -1.19097569  1.43270697 -0.3126519  -0.72058873  0.88716294
##   0.85958841 -0.6365235   0.01569637 -2.24268495]
\end{lstlisting}

Pour éviter d'affecter l'environnement global par la graine aléatoire, on peut utiliser la méthode \texttt{RandomState}du sous-module \texttt{random} de \texttt{NumPy} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ numpy.random }\ImportTok{import}\NormalTok{ RandomState}
\NormalTok{rs }\OperatorTok{=}\NormalTok{ RandomState(}\DecValTok{123}\NormalTok{)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ rs.normal(}\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 8.914369396699438
\end{lstlisting}

Par ailleurs, la fonction \texttt{permutation()} du sous-module \texttt{random} permet d'effectuer une permutation aléatoire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{10}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.random.permutation(x)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x : "}\NormalTok{, x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x :  [0 1 2 3 4 5 6 7 8 9]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"y : "}\NormalTok{, y)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## y :  [9 7 4 3 8 2 6 1 0 5]
\end{lstlisting}

La fonction \texttt{shuffle()} du sous-module \texttt{random} permet quant à elle d'effectuer une permutation aléatoire des éléments :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x avant permutation : "}\NormalTok{, x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x avant permutation :  [0 1 2 3 4 5 6 7 8 9]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.random.permutation(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## array([7, 5, 4, 1, 0, 8, 3, 9, 6, 2])
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"x après permutation : "}\NormalTok{, x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x après permutation :  [0 1 2 3 4 5 6 7 8 9]
\end{lstlisting}

\section{Exercice}\label{exercice-7}

\begin{exframe}
\emph{Premier exercice}

Considérons le vecteur suivant : \(x = \begin{bmatrix}1 & 2 & 3 & 4 & 5\end{bmatrix}\)

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer ce vecteur à l'aide d'un tableau que l'on appellera \texttt{x}.
\item
  Afficher le type de \texttt{x} puis sa longueur.
\item
  Extraire le premier élément, puis en faire de même avec le dernier.
\item
  Extraire les trois premiers éléments et les stocker dans un vecteur que l'on nommera \texttt{a}.
\item
  Extraire les 1er, 2e et 5e éléments du vecteur (attention aux positions) ; les stocker dans un vecteur que l'on nommera \texttt{b}.
\item
  Additionner le nombre 10 au vecteur \texttt{x}, puis multiplier le résultat par 2.
\item
  Effectuer l'addition de \texttt{a} et \texttt{b}, commenter le résultat.
\item
  Effectuer l'addition suivante : \texttt{x+a} ; commenter le résultat, puis regarder le résultat de \texttt{a+x}.
\item
  Multiplier le vecteur par le scalaire \texttt{c} que l'on fixera à 2.
\item
  Effectuer la multiplication de \texttt{a} et \texttt{b} ; commenter le résultat.
\item
  Effectier la multiplication suivante : \texttt{x*a} ; commenter le résultats.
\item
  Récupérer les positions des multiples de 2 et les stocker dans un vecteur que l'on nommera \texttt{ind}, piuis conserver uniquement les multiples de 2 de \texttt{x} dans un vecteur que l'on nommera \texttt{mult\_2}.
\item
  Afficher les éléments de \texttt{x} qui sont multiples de 3 \emph{et} multiples de 2.
\item
  Afficher les éléments de \texttt{x} qui sont multiples de 3 \emph{ou} multiples de 2.
\item
  Calculer la somme des éléments de \texttt{x}.
\item
  Remplacer le premier élément de \texttt{x} par un 4.
\item
  Remplacer le premier élément de \texttt{x} par la valeur \texttt{NaN}, puis calculer la somme des éléments de \texttt{x}.
  18 Supprimer le vecteur \texttt{x}.
\end{enumerate}

\emph{Deuxième exercice}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Créer la matrice suivante : \(A = \begin{bmatrix} -3 & 5 & 6 \\ -1 & 2 & 2 \\ 1 & -1 & -1 \end{bmatrix}\).
\item
  Afficher la dimension de \texttt{A}, son nombre de colonnes, son nombre de lignes et sa longueur.
\item
  Extraire la seconde colonne de \texttt{A}, puis la première ligne.
  4.Extraire l'élément en troisième position à la première ligne.
\item
  Extraire la sous-matrice de dimension \(2\times 2\) du coin inférieur de \texttt{A}, c'est-à-dire \(\begin{bmatrix} 2 & 2 \\ -1 & -1 \end{bmatrix}\).
\item
  Calculer la somme des colonnes puis des lignes de A.
\item
  Afficher la diagonale de \texttt{A}.
\item
  Rajouter le vecteur \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\) à droite de la matrice \texttt{A} et stocker le résultat dans un objet appelé \texttt{B}.
\item
  Retirer le quatrième vecteur de \texttt{B}.
\item
  Retirer la première et la troisième ligne de \texttt{B}.
\item
  Ajouter le scalaire 10 à \texttt{A}.
\item
  Ajouter le vecteur \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\) à \texttt{A}.
\item
  Ajouter la matrice identité \(I_3\) à \texttt{A}.
\item
  Diviser tous les éléments de la matrice \texttt{A} par 2.
\item
  Multiplier la matrice \texttt{A} par le vecteur ligne \(\begin{bmatrix} 1 & 2 & 3\end{bmatrix}^\top\).
\item
  Afficher la transposée de \texttt{A}.
\item
  Effectuer le produit avec transposition \(A^\top A\).
\end{enumerate}
\end{exframe}

\chapter{\texorpdfstring{Manipulation de données avec \texttt{pandas}}{Manipulation de données avec pandas}}\label{pandas}

\texttt{pandas} est une librairie open-source basée sur \texttt{NumPy} fournissant des structures de données facile à manipuler, et des outils d'analyse de données. Le lecteur familier avec les fonctions de base du langage \texttt{R} retrouvera de nombreuses fonctionnalités similaires avec \texttt{pandas}.

Pour avoir accès aux fonctionnalités de \texttt{pandas}, il est coutume de charger la librairie en lui accordant l'alias \texttt{pd} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\end{Highlighting}
\end{Shaded}

Nous allons également utiliser des fonctions de \texttt{numpy} (c.f. Section~\ref{numpy}). Assurons-nous de charger cette librairie, si ce n'est pas déjà fait :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

\section{Structures}\label{structures-1}

Nous allons nous pencher sur deux types de structures, les séries (\texttt{serie}) et les dataframes (\texttt{DataFrame}).

\subsection{Séries}\label{suxe9ries}

Les séries sont des tableaux à une dimension de données indexées.

\subsubsection{Création de séries à partir d'une liste}\label{cruxe9ation-de-suxe9ries-uxe0-partir-dune-liste}

Pour en créer,on peut définir une liste, puis appliquer la fonction \texttt{Series} de \texttt{pandas} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan, }\FloatTok{.5}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    1.0
## 1    4.0
## 2   -1.0
## 3    NaN
## 4    0.5
## 5    1.0
## dtype: float64
\end{lstlisting}

L'affichage précédent montre que la série \texttt{s} créée contient à la fois les données et un index associé. L'attribut \texttt{values} permet d'afficher les valeurs qui sont stockées dans un tableau \texttt{numpy} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"valeur de s : "}\NormalTok{, s.values)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## valeur de s :  [ 1.   4.  -1.   nan  0.5  1. ]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"type des valeurs de s : "}\NormalTok{, }\BuiltInTok{type}\NormalTok{(s.values))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## type des valeurs de s :  <class 'numpy.ndarray'>
\end{lstlisting}

L'indice est quand à lui stocké dans une structure spécifique de \texttt{pandas} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"index de s : "}\NormalTok{, s.index)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## index de s :  RangeIndex(start=0, stop=6, step=1)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"type de l\textquotesingle{}index de s : "}\NormalTok{, }\BuiltInTok{type}\NormalTok{(s.index))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## type de l'index de s :  <class 'pandas.core.indexes.range.RangeIndex'>
\end{lstlisting}

Il est possible d'attribuer un nom à la série ainsi qu'à l'index :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.name }\OperatorTok{=} \StringTok{"ma\_serie"}
\NormalTok{s.index.name }\OperatorTok{=} \StringTok{"nom\_index"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"nom de la série : }\SpecialCharTok{\{\}}\StringTok{ , nom de l\textquotesingle{}index : }\SpecialCharTok{\{\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(s.name, s.index.name))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nom de la série : ma_serie , nom de l'index : nom_index
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"série s : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## série s : 
##  nom_index
## 0    1.0
## 1    4.0
## 2   -1.0
## 3    NaN
## 4    0.5
## 5    1.0
## Name: ma_serie, dtype: float64
\end{lstlisting}

\subsubsection{Définition de l'index}\label{duxe9finition-de-lindex}

L'index peut être défini par l'utilisateur, au moment de la création de la série :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64
\end{lstlisting}

On peut définir l'indice avec des valeurs numériques également, sans être forcé de respecter un ordre précis :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4     1.0
## 40    4.0
## 2    -1.0
## 3     NaN
## dtype: float64
\end{lstlisting}

L'index peut être modifié par la suite, en venant écraser l'attribut \texttt{index} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Série s : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Série s : 
##  o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64
\end{lstlisting}

\subsubsection{Création de séries particulières}\label{cruxe9ation-de-suxe9ries-particuliuxe8res}

Il existe une petite astuce pour créer des séries avec une valeur répétée, qui consiste à fournir un scalaire à la fonction \texttt{Series} de \texttt{NumPy} et un index dont la longueur correspondra au nombre de fois où le scalaire sera répété :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{5}\NormalTok{, index }\OperatorTok{=}\NormalTok{ [np.arange(}\DecValTok{4}\NormalTok{)])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    5
## 1    5
## 2    5
## 3    5
## dtype: int64
\end{lstlisting}

On peut créer une série à partir d'un dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionnaire }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Roi"}\NormalTok{: }\StringTok{"Arthur"}\NormalTok{,}
                \StringTok{"Chevalier\_pays\_galles"}\NormalTok{: }\StringTok{"Perceval"}\NormalTok{,}
                \StringTok{"Druide"}\NormalTok{: }\StringTok{"Merlin"}\NormalTok{\}}
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(dictionnaire)}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Roi                        Arthur
## Chevalier_pays_galles    Perceval
## Druide                     Merlin
## dtype: object
\end{lstlisting}

Comme on le note dans la sortie précédente, les clés du dictionnaire ont été utilisées pour l'index. Lors de la création de la série, on peut préciser au paramètre clé des valeurs spécifiques : cela aura pour conséquence de ne récupérer que les observations correspondant à ces clés :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionnaire }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Roi"}\NormalTok{: }\StringTok{"Arthur"}\NormalTok{,}
                \StringTok{"Chevalier\_pays\_galles"}\NormalTok{: }\StringTok{"Perceval"}\NormalTok{,}
                \StringTok{"Druide"}\NormalTok{: }\StringTok{"Merlin"}\NormalTok{\}}
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(dictionnaire, index }\OperatorTok{=}\NormalTok{ [}\StringTok{"Roi"}\NormalTok{, }\StringTok{"Druide"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Roi       Arthur
## Druide    Merlin
## dtype: object
\end{lstlisting}

\subsection{Dataframes}\label{dataframes}

Les Dataframes correspondent au format de données que l'on rencontre classiquement en économie, des tableaux à deux dimensions, avec des variables en colonnes et des observations en ligne. Les colonnes et lignes des dataframes sont indexées.

\subsubsection{Création de dataframes à partir d'un dictionnaire}\label{cruxe9ation-de-dataframes-uxe0-partir-dun-dictionnaire}

Pour créer un dataframe, on peut fournir à la fonction \texttt{DataFrame()} de \texttt{pandas} un dictionnaire pouvant être transformé en \texttt{serie}. C'est le cas d'un dictionnaire dont les valeurs associées aux clés ont toutes la même longueur :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : }
\NormalTok{               [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{,}
                \DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{, }\DecValTok{67}\NormalTok{,}
                \DecValTok{68}\NormalTok{, }\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: }
\NormalTok{               [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{,}
                \DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{, }\DecValTok{135}\NormalTok{, }\DecValTok{139}\NormalTok{, }\DecValTok{142}\NormalTok{,}
                \DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{]}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     height  weight
## 0       58     115
## 1       59     117
## 2       60     120
## 3       61     123
## 4       62     126
## 5       63     129
## 6       64     132
## 7       65     135
## 8       66     139
## 9       67     142
## 10      68     146
## 11      69     150
## 12      70     154
## 13      71     159
## 14      72     164
\end{lstlisting}

La position des éléments dans le dataframe sert d'index. Comme pour les séries, les valeur sont accessibles dans l'attribut \texttt{values} et l'index dans l'attribut \texttt{index}. Les colonnes sont également indexées :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.columns)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Index(['height', 'weight'], dtype='object')
\end{lstlisting}

La méthode \texttt{head()} permet d'afficher les premières lignes (les 5 premières, par défaut). On peut modifier son paramètre \texttt{n} pour indiquer le nombre de lignes à retourner :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.head(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight
## 0      58     115
## 1      59     117
\end{lstlisting}

Lors de la création d'un dataframe à partir d'un dictionnaire, si on précise le nom des colonnes à importer par une liste de chaînes de caractères fournie au paramètre \texttt{columns} de la fonction \texttt{DataFrame}, on peut non seulement définir les colonnes à remplir mais également leur ordre d'apparition.

Par exemple, pour n'importer que la colonne \texttt{weight} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico, columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"weight"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df.head(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight
## 0     115
## 1     117
\end{lstlisting}

Et pour définir l'ordre dans lequel les colonnes apparaîtront :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico, columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"weight"}\NormalTok{, }\StringTok{"height"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df.head(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight  height
## 0     115      58
## 1     117      59
\end{lstlisting}

Si on indique un nom de colonne absent parmi les clés du dictionnaires, le dataframe résultant contiendra une colonne portant ce nom mais remplie de valeurs \texttt{NaN} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico, columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"weight"}\NormalTok{, }\StringTok{"height"}\NormalTok{, }\StringTok{"age"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df.head(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight  height  age
## 0     115      58  NaN
## 1     117      59  NaN
\end{lstlisting}

\subsubsection{Création de dataframes à partir d'une série}\label{cruxe9ation-de-dataframes-uxe0-partir-dune-suxe9rie}

Un dataframe peut être créé à partir d'une série :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan], index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{])}
\NormalTok{s.name }\OperatorTok{=} \StringTok{"nom\_variable"}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(s, columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"nom\_variable"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    nom_variable
## o           1.0
## d           4.0
## i          -1.0
## l           NaN
\end{lstlisting}

Si on n'attribue pas de nom à la série, il suffit de ne pas renseigner le paramètre \texttt{columns} de la fonction \texttt{DataFrame}. Mais dans ce cas, la colonne n'aura pas de non, juste un index numérique.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan], index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{])}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(s)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      0
## o  1.0
## d  4.0
## i -1.0
## l  NaN
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.columns.name)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## None
\end{lstlisting}

\subsubsection{Création de dataframes à partir d'une liste de dictionnaire}\label{cruxe9ation-de-dataframes-uxe0-partir-dune-liste-de-dictionnaire}

Un dataframe peut être créé à partir d'une liste de dictionnaires :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico\_1 }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"Nom"}\NormalTok{: }\StringTok{"Pendragon"}\NormalTok{,}
    \StringTok{"Prenom"}\NormalTok{: }\StringTok{"Arthur"}\NormalTok{,}
    \StringTok{"Role"}\NormalTok{: }\StringTok{"Roi de Bretagne"}
\NormalTok{\}}
\NormalTok{dico\_2 }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"Nom"}\NormalTok{: }\StringTok{"de Galles"}\NormalTok{,}
    \StringTok{"Prenom"}\NormalTok{: }\StringTok{"Perceval"}\NormalTok{,}
    \StringTok{"Role"}\NormalTok{: }\StringTok{"Chevalier du Pays de Galles"}
\NormalTok{\}}

\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame([dico\_1, dico\_2])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##          Nom    Prenom                         Role
## 0  Pendragon    Arthur              Roi de Bretagne
## 1  de Galles  Perceval  Chevalier du Pays de Galles
\end{lstlisting}

Si certaines clés sont absentes dans un ou plusieurs des dictionnaires de la liste, les valeurs correspondantes dans le dataframe seront \texttt{NaN} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico\_3 }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"Prenom"}\NormalTok{: }\StringTok{"Guenièvre"}\NormalTok{,}
    \StringTok{"Role"}\NormalTok{: }\StringTok{"Reine de Bretagne"}
\NormalTok{\}}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame([dico\_1, dico\_2, dico\_3])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##          Nom     Prenom                         Role
## 0  Pendragon     Arthur              Roi de Bretagne
## 1  de Galles   Perceval  Chevalier du Pays de Galles
## 2        NaN  Guenièvre            Reine de Bretagne
\end{lstlisting}

\subsubsection{Création de dataframes à partir d'un dictionnaire de séries}\label{cruxe9ation-de-dataframes-uxe0-partir-dun-dictionnaire-de-suxe9ries}

On peut aussi créer un dataframe à partir d'un dictionnaire de séries. Pour illustrer la méthode, créons deux dictionnaires :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PIB annuel 2017}
\CommentTok{\# En millions de dollars courants}
\NormalTok{dico\_gdp\_current }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"France"}\NormalTok{: }\FloatTok{2582501.31}\NormalTok{,}
    \StringTok{"USA"}\NormalTok{: }\FloatTok{19390604.00}\NormalTok{,}
    \StringTok{"UK"}\NormalTok{: }\FloatTok{2622433.96}
\NormalTok{\}}
\CommentTok{\# Indice annuel des prix à la consommation}
\NormalTok{dico\_cpi }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"France"}\NormalTok{: }\FloatTok{0.2}\NormalTok{,}
    \StringTok{"UK"}\NormalTok{: }\FloatTok{0.6}\NormalTok{,}
    \StringTok{"USA"}\NormalTok{: }\FloatTok{1.3}\NormalTok{,}
    \StringTok{"Germany"}\NormalTok{: }\FloatTok{0.5}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

À partir de ces deux dictionnaires, créons deux séries correspondantes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_gdp\_current }\OperatorTok{=}\NormalTok{ pd.Series(dico\_gdp\_current)}
\NormalTok{s\_cpi }\OperatorTok{=}\NormalTok{ pd.Series(dico\_cpi)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_gdp\_current : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_gdp\_current)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_gdp_current : 
##  France     2582501.31
## USA       19390604.00
## UK         2622433.96
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{s\_cpi : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_cpi)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## s_cpi : 
##  France     0.2
## UK         0.6
## USA        1.3
## Germany    0.5
## dtype: float64
\end{lstlisting}

Puis, créons un dictionnaire de séries :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico\_de\_series }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"gdp"}\NormalTok{: s\_gdp\_current,}
    \StringTok{"cpi"}\NormalTok{: s\_cpi}
\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(dico\_de\_series)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'gdp': France     2582501.31
## USA       19390604.00
## UK         2622433.96
## dtype: float64, 'cpi': France     0.2
## UK         0.6
## USA        1.3
## Germany    0.5
## dtype: float64}
\end{lstlisting}

Enfin, créons notre dataframe :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico\_de\_series)}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##                  gdp  cpi
## France    2582501.31  0.2
## Germany          NaN  0.5
## UK        2622433.96  0.6
## USA      19390604.00  1.3
\end{lstlisting}

\begin{remarque}
Le dictionnaire \texttt{dico\_gdp\_current} ne contient pas de clé \texttt{Germany}, contrairement au dictionnaire \texttt{dico\_cpi}. Lors de la création du dataframe, la valeur du PIB pour l'Allemagne a dont été assignée comme \texttt{NaN}.
\end{remarque}

\subsubsection{\texorpdfstring{Création de dataframes à partir d'un tableau \texttt{NumPy} à deux dimensions}{Création de dataframes à partir d'un tableau NumPy à deux dimensions}}\label{cruxe9ation-de-dataframes-uxe0-partir-dun-tableau-numpy-uxe0-deux-dimensions}

On peut aussi créer un dataframe à partir d'un tableau \texttt{Numpy}. Lors de la création, avec la fonction \texttt{DataFrame()} de \texttt{NumPy}, il est possible de préciser le nom des colonnes (à défaut, l'indiçage des colonnes sera numérique) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{],}
\NormalTok{    [}\DecValTok{11}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{33}\NormalTok{],}
\NormalTok{    [}\DecValTok{111}\NormalTok{, }\DecValTok{222}\NormalTok{, }\DecValTok{333}\NormalTok{],}
\NormalTok{    [}\DecValTok{1111}\NormalTok{, }\DecValTok{2222}\NormalTok{, }\DecValTok{3333}\NormalTok{]}
\NormalTok{]}
\NormalTok{tableau\_np }\OperatorTok{=}\NormalTok{ np.array(liste)}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(tableau\_np, columns}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       a     b     c
## 0     1     2     3
## 1    11    22    33
## 2   111   222   333
## 3  1111  2222  3333
\end{lstlisting}

\subsubsection{Dimensions}\label{dimensions-1}

On accède aux dimensions d'un dataframe avec l'attribut \texttt{shape}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"shape : "}\NormalTok{, df.shape)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## shape :  (4, 3)
\end{lstlisting}

On peut aussi afficher le nombre de lignes comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"shape : "}\NormalTok{, }\BuiltInTok{len}\NormalTok{(df))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## shape :  4
\end{lstlisting}

Et le nombre de colonnes :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"shape : "}\NormalTok{, }\BuiltInTok{len}\NormalTok{(df.columns))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## shape :  3
\end{lstlisting}

\subsubsection{Modification de l'index}\label{modification-de-lindex}

Comme pour les séries, on peut modifier l'index une fois que le dataframe a été créé, en venant écraser les valeurs des attributs \texttt{index} et \texttt{columns}, pour l'index des lignes et colonnes, respectivement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{]}
\NormalTok{df.columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"aa"}\NormalTok{, }\StringTok{"bb"}\NormalTok{, }\StringTok{"cc"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##      aa    bb    cc
## o     1     2     3
## d    11    22    33
## i   111   222   333
## l  1111  2222  3333
\end{lstlisting}

\section{Sélection}\label{pandas-selection}

Dans cette section, nous regardons différentes manières de sélectionner des données dans des séries et dataframes. On note deux manières bien distinctes :

\begin{itemize}
\tightlist
\item
  une première basée sur l'utiliation de crochets directement sur l'objet pour lequel on souhaite sélectionner certaines parties ;
\item
  seconde s'appuyant sur des indexeurs, accessibles en tant qu'attributs d'objets \texttt{NumPy} (\texttt{loc}, \texttt{at}, \texttt{iat}, etc.)
\end{itemize}

La seconde méthode permet d'éviter certaines confusions qui peuvent apparaître dans le cas d'index numériques.

\subsection{Pour les séries}\label{pour-les-suxe9ries}

Dans un premier temps, regardons les manières d'extraire des valeurs contenues dans des séries.

\subsubsection{Avec les crochets}\label{avec-les-crochets}

On peut utiliser l'index pour extraire les données :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan, }\FloatTok{.5}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\NormalTok{s[}\DecValTok{0}\NormalTok{] }\CommentTok{\# 1er élément de s}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## np.float64(1.0)
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{] }\CommentTok{\# du 2e élément (inclus) au 4e (non inclus)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1    4.0
## 2   -1.0
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[[}\DecValTok{0}\NormalTok{,}\DecValTok{4}\NormalTok{]] }\CommentTok{\# 1er et 5e éléments}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    1.0
## 4    0.5
## dtype: float64
\end{lstlisting}

On note que contrairement aux tableaux \texttt{numpy} ou aux listes, on ne peut pas utiliser des valeurs négatives pour l'index afin de récupérer les données en comptant leur position par rapport à la fin :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## KeyError: -2
\end{lstlisting}

Dans le cas d'un indice composé de chaînes de caractères, il est alors possible, pour extraire les données de la série, de faire référence soit au contenu de l'indice (pour faire simple, son nom), soit à sa position :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\StringTok{"o"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"La série s : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## La série s : 
##  o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}s["d"] : }\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, s[}\StringTok{"d"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s["d"] : 
##  4.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}s[1] : }\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, s[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s[1] : 
##  4.0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments o et i : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s[[}\StringTok{"o"}\NormalTok{, }\StringTok{"i"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments o et i : 
##  o    1.0
## i   -1.0
## dtype: float64
\end{lstlisting}

Par contre, dans le cas où l'indice est défini avec des valeurs numériques, pour extraire les valeurs à l'aide des crochets, ce sera par la valeur de l'indice et pas en s'appuyant sur la position :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(s[}\DecValTok{40}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 4.0
\end{lstlisting}

\subsubsection{Avec les indexeurs}\label{avec-les-indexeurs}

Pandas propose deux types d'indiçage multi-axes : \texttt{loc}, \texttt{iloc}. Le premier est principalement basé sur l'utilisation des labels des axes, tandis que le second s'appuie principalement sur les positions à l'aide d'entiers.

Pour les besoins de cette partie, créons deux séries ; une première avec un index textuel, une deuxième avec un index numérique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\NormalTok{s\_texte }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"d"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\paragraph{Extraction d'un seul élément}\label{extraction-dun-seul-uxe9luxe9ment}

Pour extraire un objet avec \texttt{loc}, on utilise le nom de l'indice :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(s\_num.loc[}\DecValTok{5}\NormalTok{], s\_texte.loc[}\StringTok{"c"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 1.0 1.0
\end{lstlisting}

Pour extraire un élément unique avec \texttt{iloc}, il suffit d'indiquer sa position :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(s\_num.iloc[}\DecValTok{1}\NormalTok{], s\_texte.iloc[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (np.float64(4.0), np.float64(4.0))
\end{lstlisting}

\paragraph{Extraction de plusieurs éléments}\label{extraction-de-plusieurs-uxe9luxe9ments}

Pour extraire plusieurs éléments avec \texttt{loc}, on utilise les noms (labels) des indices, que l'on fournit dans une liste :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux labels 5 et 4 :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.loc[[}\DecValTok{5}\NormalTok{,}\DecValTok{4}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux labels 5 et 4 :
##  5    1.0
## 4   -1.0
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux labels c et b : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.loc[[}\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux labels c et b : 
##  c    1.0
## b   -1.0
## dtype: float64
\end{lstlisting}

Pour extraire plusieurs éléments avec \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux positions 0 et 2 :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.iloc[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux positions 0 et 2 :
##  5    1.0
## 4   -1.0
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux positions 0 et 2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.iloc[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux positions 0 et 2 : 
##  c    1.0
## b   -1.0
## dtype: float64
\end{lstlisting}

\paragraph{Découpage}\label{decoupage-series}

On peut effectuer des découpages de séries, pour récupérer des éléments consécutifs :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments des labels 5 jusqu\textquotesingle{}à 4 :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.loc[}\DecValTok{5}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments des labels 5 jusqu'à 4 :
##  5    1.0
## 0    4.0
## 4   -1.0
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments des labels c à b : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.loc[}\StringTok{"c"}\NormalTok{:}\StringTok{"b"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments des labels c à b : 
##  c    1.0
## a    4.0
## b   -1.0
## dtype: float64
\end{lstlisting}

Pour extraire plusieurs éléments avec \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux positions de 0 à 2 :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux positions de 0 à 2 :
##  5    1.0
## 0    4.0
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"éléments aux positions de 0 à 2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## éléments aux positions de 0 à 2 : 
##  c    1.0
## a    4.0
## dtype: float64
\end{lstlisting}

Comme ce que l'on a vu jusqu'à présent, la valeur supérieur de la limite n'est pas incluse dans le découpage.

\paragraph{Masque}\label{masque}

On peut aussi utiliser un masque pour extraire des éléments, indifféremment en utilisant \texttt{loc} ou \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,s\_num.loc[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
##  5    1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.loc[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
##  c    1.0
## d    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.iloc[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
##  5    1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.iloc[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
##  c    1.0
## d    NaN
## dtype: float64
\end{lstlisting}

\paragraph{Quel est l'intérêt ?}\label{quel-est-lintuxe9ruxeat}

Pourquoi introduire de telles manières d'extraire les données et ne pas se contenter de l'extraction à l'aide des crochets sur les objets ? Regardons un exemple simple. Admettons que nous disposons de la série \texttt{s\_num}, avec un indice composé d'entiers n'étant pas une séquence allant de 0 au nombre d'éléments. Dans ce cas, si nous souhaitons récupérer récupérer le 2e élément, du fait de l'indice composé de valeurs numériques, nous ne pouvons pas l'obtenir en demandant \texttt{s{[}1{]}}. Pour extraire le 2e de la série, on doit savoir que son indice vaut \texttt{0} et ainsi demander :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"L\textquotesingle{}élément dont l\textquotesingle{}index vaut 0 : "}\NormalTok{, s\_num[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## L'élément dont l'index vaut 0 :  4.0
\end{lstlisting}

Pour pouvoir effectuer l'extraction en fonction de la position, il est bien pratique d'avoir cet attribut \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"L\textquotesingle{}élément en 2e position :"}\NormalTok{, s\_num.iloc[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## L'élément en 2e position : 4.0
\end{lstlisting}

\subsection{Pour les dataframes}\label{pour-les-dataframes}

À présent, regardons différentes manières d'extraire des données depuis un dataframe. Créons deux dataframes en exemple, l'une avec un index numérique ; une autre avec un index textuel :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df\_num }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\NormalTok{df\_texte }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico, index}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{, }\StringTok{"e"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"d"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df_num : 
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"df\_texte : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df_texte : 
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172
## b      61     123   31     160
## d      62     126   29     158
\end{lstlisting}

Pour faire simple, lorsqu'on veut effectuer une extraction avec les attributs \texttt{iloc}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.iloc[selection\_lignes, selection\_colonnes]}
\end{Highlighting}
\end{Shaded}

avec \texttt{selection\_lignes} :

\begin{itemize}
\tightlist
\item
  une valeur unique : \texttt{1} (seconde ligne) ;
\item
  une liste de valeurs : \texttt{{[}2,\ 1,\ 3{]}} (3e ligne, 2e ligne et 4e ligne) ;
\item
  un découpage : \texttt{{[}2:4{]}} (de la 3e ligne à la 4e ligne (non incluse)).
\end{itemize}

pour \texttt{selection\_colonnes} :

\begin{itemize}
\tightlist
\item
  une valeur unique : \texttt{1} (seconde colonne) ;
\item
  une liste de valeurs : \texttt{{[}2,\ 1,\ 3{]}} (3e colonne, 2e colonne et 4e colonne) ;
\item
  un découpage : \texttt{{[}2:4{]}} (de la 3e colonne à la 4e colonne (non incluse)).
\end{itemize}

Avec \texttt{loc}, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.loc[selection\_lignes, selection\_colonnes]}
\end{Highlighting}
\end{Shaded}

avec \texttt{selection\_lignes} :

\begin{itemize}
\tightlist
\item
  une valeur unique : \texttt{"a"} (ligne nommée \texttt{a}) ;
\item
  une liste de noms : \texttt{{[}"a",\ "c",\ "b"{]}} (lignes nommées ``a'', ``c'' et ``b'') ;
\item
  un masque : \texttt{df.{[}\textquotesingle{}a\textquotesingle{}{]}\textless{}10} (lignes pour lesquelles les valeurs du masque valent \texttt{True}).
\end{itemize}

pour \texttt{selection\_colonnes} :

\begin{itemize}
\tightlist
\item
  une valeur unique : \texttt{"a"} (colonne nommée \texttt{a}) ;
\item
  une liste de valeurs : \texttt{{[}"a",\ "c",\ "b"{]}} (colonnes nommées ``a'', ``c'' et ``b'') ;
\item
  un découpage : \texttt{{[}"a":"c"{]}} (de la colonne nommée ``a'' à la colonne nommée ``c'').
\end{itemize}

\subsubsection{Extraction d'une ligne}\label{extraction-dune-ligne}

Pour extraire une ligne d'un dataframe, on peut utiliser le nom de la ligne avec \texttt{loc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ligne nommée \textquotesingle{}e\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[}\StringTok{"e"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Ligne nommée 'e':
##  height     59
## weight    117
## age        33
## taille    156
## Name: e, dtype: int64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Ligne nommée \textquotesingle{}e\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.loc[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Ligne nommée 'e':
##  height     59
## weight    117
## age        33
## taille    156
## Name: 1, dtype: int64
\end{lstlisting}

Ou bien, sa position avec \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ligne en position 0:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.iloc[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Ligne en position 0:
##  height     58
## weight    115
## age        28
## taille    162
## Name: a, dtype: int64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Ligne en position 0:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.iloc[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Ligne en position 0:
##  height     58
## weight    115
## age        28
## taille    162
## Name: 0, dtype: int64
\end{lstlisting}

\subsubsection{Extraction de plusieurs lignes}\label{extraction-de-plusieurs-lignes}

Pour extraire plusieurs lignes d'un dataframe, on peut utiliser leur noms avec \texttt{loc} (dans un tableau) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Lignes nommées a et c :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[[}\StringTok{"a"}\NormalTok{, }\StringTok{"c"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Lignes nommées a et c :
##     height  weight  age  taille
## a      58     115   28     162
## c      60     120   31     172
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Lignes nommées 0 et 2:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.loc[[}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Lignes nommées 0 et 2:
##     height  weight  age  taille
## 0      58     115   28     162
## 2      60     120   31     172
\end{lstlisting}

Ou bien, leur position avec \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Lignes aux positions 0 et 3:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.iloc[[}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Lignes aux positions 0 et 3:
##     height  weight  age  taille
## a      58     115   28     162
## b      61     123   31     160
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Lignes aux positions 0 et 3:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.iloc[[}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Lignes aux positions 0 et 3:
##     height  weight  age  taille
## 0      58     115   28     162
## 3      61     123   31     160
\end{lstlisting}

\subsubsection{Découpage de plusieurs lignes}\label{decoupage-df-lignes}

On peut récupérer une suite de ligne en délimitant la première et la dernière à extraire en fonction de leur nom et en utilisant \texttt{loc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Lignes du label a à c:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[}\StringTok{"a"}\NormalTok{:}\StringTok{"c"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Lignes du label a à c:
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\ErrorTok{\textbackslash{}}\StringTok{Lignes du label 0 à 2:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## \Lignes du label 0 à 2:
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
\end{lstlisting}

Avec l'attribut \texttt{iloc}, c'est également possible (encore une fois, la borne supérieure n'est pas incluse) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Lignes des positions 0 à 3 (non incluse):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Lignes des positions 0 à 3 (non incluse):
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Lignes des positions 0 à 3 (non incluse):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## Lignes des positions 0 à 3 (non incluse):
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
\end{lstlisting}

\subsubsection{Masque}\label{masque-extraction-ligne}

On peut aussi utiliser un masque pour sélectionner certaines lignes. Par exemple, si on souhaite récupérer les lignes pour lesquelles la variable \texttt{height} a une valeur supérieure à 60, on utilise le masque suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{masque }\OperatorTok{=}\NormalTok{ df\_texte[}\StringTok{"height"}\NormalTok{]}\OperatorTok{\textgreater{}} \DecValTok{60}
\BuiltInTok{print}\NormalTok{(masque)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## a    False
## e    False
## c    False
## b     True
## d     True
## Name: height, dtype: bool
\end{lstlisting}

Pour filtrer :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_texte.loc[masque])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## b      61     123   31     160
## d      62     126   29     158
\end{lstlisting}

\subsubsection{Extraction d'une seule colonne}\label{extraction-dune-seule-colonne}

Pour extraire une colonne d'un dataframe, on peut utiliser des crochets et faire référence au nom de la colonne (qui est indexée par les noms) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_texte[}\StringTok{\textquotesingle{}weight\textquotesingle{}}\NormalTok{].head(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## a    115
## e    117
## Name: weight, dtype: int64
\end{lstlisting}

En ayant sélectionné une seule colonne, on obtient une série (l'index du dataframe est conservé pour la série) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(df\_texte[}\StringTok{\textquotesingle{}weight\textquotesingle{}}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'pandas.core.series.Series'>
\end{lstlisting}

On peut également extraire une colonne en faisant référence à l'attribut du dataframe portant le nom de cette colonne :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_texte.weight.head(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## a    115
## e    117
## Name: weight, dtype: int64
\end{lstlisting}

Comme pour les séries, on peut s'appuyer sur les attributs \texttt{loc} et \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colone 2 (loc):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[:,}\StringTok{"weight"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colone 2 (loc):
##  a    115
## e    117
## c    120
## b    123
## d    126
## Name: weight, dtype: int64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colonne 2 (iloc):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.iloc[:,}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colonne 2 (iloc):
##  a    115
## e    117
## c    120
## b    123
## d    126
## Name: weight, dtype: int64
\end{lstlisting}

\subsubsection{Extraction de plusieurs colonnes}\label{extraction-de-plusieurs-colonnes}

Pour extraire plusieurs colonnes, il suffit de placer les noms des colonnes dans un tableau :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_texte[[}\StringTok{"weight"}\NormalTok{, }\StringTok{"height"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight  height
## a     115      58
## e     117      59
## c     120      60
## b     123      61
## d     126      62
\end{lstlisting}

L'ordre dans lequel on appelle ces colonnes correspond à l'ordre dans lequel elles seront retournées.

À nouveau, on peut utuliser l'attribut \texttt{loc} (on utilise les deux points ici pour dire que l'on veut toutes les lignes) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colonnes de weight à height:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[:,[}\StringTok{"weight"}\NormalTok{, }\StringTok{"height"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colonnes de weight à height:
##     weight  height
## a     115      58
## e     117      59
## c     120      60
## b     123      61
## d     126      62
\end{lstlisting}

Et l'attribut \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colonnes 2 et 1 :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_num.iloc[:,[}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colonnes 2 et 1 :
##     weight  height
## 0     115      58
## 1     117      59
## 2     120      60
## 3     123      61
## 4     126      62
\end{lstlisting}

\subsubsection{Découpage de plusieurs colonnes}\label{decoupage-df-colonnes}

Pour effectuer un découpage, on peut utiliser les attributs \texttt{loc} et \texttt{iloc}. Attention, on ne place pas le nom des colonnes servant pour le découpage dans un tableau ici :

Avec \texttt{loc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colones 2 et 2:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df\_texte.loc[:, }\StringTok{"height"}\NormalTok{:}\StringTok{"age"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colones 2 et 2:
##     height  weight  age
## a      58     115   28
## e      59     117   33
## c      60     120   31
## b      61     123   31
## d      62     126   29
\end{lstlisting}

Et avec l'attribut \texttt{iloc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Colonnes de la position 0 à 2 (non incluse) :}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }
\NormalTok{      df\_texte.iloc[:, }\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Colonnes de la position 0 à 2 (non incluse) :
##     height  weight
## a      58     115
## e      59     117
## c      60     120
## b      61     123
## d      62     126
\end{lstlisting}

\subsubsection{Extraction de lignes et colonnes}\label{extraction-de-lignes-et-colonnes}

À présent que nous avons passé en revue de nombreuses manières de sélectionner une ou plusieurs lignes ou colonnes, nous pouvons également mentionner qu'il est possible de faire des sélections de colonnes et de lignes dans une même instruction.

Par exemple, avec \texttt{iloc}, sélectionnons les lignes de la position 0 à la position 2 (non incluse) et les colonnes de la position 1 à 3 (non incluse) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_texte.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight  age
## a     115   28
## e     117   33
\end{lstlisting}

Avec \texttt{loc}, sélectionnons les lignes nommées \texttt{a} et \texttt{c} et les colonnes de celle nommée \texttt{weight} jusqu'à \texttt{age}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_texte.loc[[}\StringTok{"a"}\NormalTok{, }\StringTok{"c"}\NormalTok{], }\StringTok{"weight"}\NormalTok{:}\StringTok{"age"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    weight  age
## a     115   28
## c     120   31
\end{lstlisting}

\section{Renommage des colonnes dans un dataframe}\label{renommage-des-colonnes-dans-un-dataframe}

Pour renommer une colonne dans un dataframe, \texttt{pandas} propose la méthode \texttt{rename()}. Prenons un exemple avec notre dataframe \texttt{df} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158
\end{lstlisting}

Renommons la colonne \texttt{height} en \texttt{taille}, à l'aide d'un dicionnaire précisé au paramètre \texttt{columns}, avec comme clé le nom actuel de la colonne, et en valeur le nouveau nom :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rename(index}\OperatorTok{=}\BuiltInTok{str}\NormalTok{, columns}\OperatorTok{=}\NormalTok{\{}\StringTok{"height"}\NormalTok{: }\StringTok{"taille"}\NormalTok{\}, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    taille  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158
\end{lstlisting}

Pour que le changement soit effectif, on indique \texttt{inplace=True}, sinon, la modification n'est pas apportée au dataframe.

Pour renommer plusieurs colonnes en même temps, il suffit de fournir plusieurs couples de clés valeurs dans le dictionnaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rename(index}\OperatorTok{=}\BuiltInTok{str}\NormalTok{,}
\NormalTok{          columns}\OperatorTok{=}\NormalTok{\{}\StringTok{"weight"}\NormalTok{: }\StringTok{"masse"}\NormalTok{, }\StringTok{"age"}\NormalTok{ : }\StringTok{"annees"}\NormalTok{\},}
\NormalTok{          inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    taille  masse  annees  taille
## 0      58    115      28     162
## 1      59    117      33     156
## 2      60    120      31     172
## 3      61    123      31     160
## 4      62    126      29     158
\end{lstlisting}

\section{Filtrage}\label{filtrage}

Pour effectuer une filtration des données dans un tableau, en fonction des valeurs rencontrées pour certaines variables, on utilise des masques, comme indiqué dans la Section~\ref{masque-extraction-ligne}.

Redennons quelques exemples ici, en redéfinissant notre dataframe :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158
\end{lstlisting}

L'idée consiste à créer un masque retournant une série contenant des valeurs booléennes, une par ligne. Lorsque la valeur de la ligne du masque vaut \texttt{True}, la ligne du dataframe sur lequel sera appliqué le masque sera retenue, tandis qu'elle ne le sera pas quand la valeur de la ligne du masque vaut \texttt{False}.

Regardons un exemple simple, dans lequel nous souhaitons conserver les observations uniquement pour lesquelles la valeur de la variable \texttt{age} est inférieure à 30 :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{masque }\OperatorTok{=}\NormalTok{ df[}\StringTok{"age"}\NormalTok{] }\OperatorTok{\textless{}} \DecValTok{30}
\BuiltInTok{print}\NormalTok{(masque)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0     True
## 1    False
## 2    False
## 3    False
## 4     True
## Name: age, dtype: bool
\end{lstlisting}

Il reste alors à appliquer ce masque, avec \texttt{loc}. On souhaite l'ensemble des colonnes, mais seulement quelques lignes :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.loc[masque])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 0      58     115   28     162
## 4      62     126   29     158
\end{lstlisting}

Note : cela fonctionne aussi sans \texttt{loc} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df[masque])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 0      58     115   28     162
## 4      62     126   29     158
\end{lstlisting}

Plus simplement, on peut utiliser la méthode \texttt{query()} de \texttt{pandas}. On fournit une expression booléenne à évaluer à cette méthode pour filtrer les données :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.query(}\StringTok{"age\textless{}30"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 0      58     115   28     162
## 4      62     126   29     158
\end{lstlisting}

La requête peut être un peu plus complexe, en combinant opérateurs de comparaison (c.f. Section~\ref{operateurs-comparaison}) et opérateurs logiques (c.f. Section~\ref{operateurs-logiques}). Par exemple, admettons que nous voulons filtrer les valeurs du dataframe pour ne retenir que les observations pour lesquelles la taille est inférieure ou égale à 62 et la masse strictement supérieure à 120. La requête serait alors :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.query(}\StringTok{"weight \textgreater{} 120 and height \textless{} 62"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 3      61     123   31     160
\end{lstlisting}

On peut noter que l'instruction suivante donne le même résultat :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.query(}\StringTok{"weight \textgreater{} 120"}\NormalTok{).query(}\StringTok{"height \textless{} 62"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille
## 3      61     123   31     160
\end{lstlisting}

\subsection{Test d'appartenance}\label{test-dappartenance-2}

Pour créer un masque indiquant si les valeurs d'une série ou d'un dataframe appartiennent à un ensemble, on peut utiliser la méthode \texttt{isin()}. Par exemple, retournons un masque indiquant si les valeurs de la colonne \texttt{height} de \texttt{df} sont dans l'intervalle \([59,60]\) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.height.isin(np.arange(}\DecValTok{59}\NormalTok{,}\DecValTok{61}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    False
## 1     True
## 2     True
## 3    False
## 4    False
## Name: height, dtype: bool
\end{lstlisting}

\section{Valeurs manquantes}\label{valeurs-manquantes}

En économie, il est assez fréquent de récupérer des données incomplètes. La manière dont les données manquantes sont gérées par \texttt{pandas} est le recours aux deux valeurs spéciales : \texttt{None} et \texttt{NaN}.

La valeur \texttt{None} peut être utilisée dans les tableaux \texttt{NumPy} uniquement quand le type de ces derniers est \texttt{object}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_none }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\VariableTok{None}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(tableau\_none)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [1 4 -1 None]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(tableau\_none))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Avec un tableau de type \texttt{object}, les opérations effectuées sur les données seront moins efficaces qu'avec un tableau d'un type numérique \citep[p 121]{vanderplas2016python}.

La valeur \texttt{NaN} est une valeur de nombre à virgule flottante (c.f. Section~\ref{numpy-constantes}). \texttt{NumPy} la gère différemment de \texttt{NaN}, et n'assigne passe type \texttt{object} d'emblée en présence de \texttt{NaN} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tableau\_nan }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan])}
\BuiltInTok{print}\NormalTok{(tableau\_nan)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## [ 1.  4. -1. nan]
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(tableau\_nan))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'numpy.ndarray'>
\end{lstlisting}

Avec \texttt{pandas}, ces deux valeurs, \texttt{None} et \texttt{NaN} peuvent être présentes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\VariableTok{None}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan])}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    1.0
## 1    NaN
## 2   -1.0
## 3    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(s))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <class 'pandas.core.series.Series'>
\end{lstlisting}

Cela tient aussi pour les tableaux :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, np.nan],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, np.nan, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight   age  taille
## 0    58.0     115  28.0     162
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158
\end{lstlisting}

On note toutefois que seule le type des variables pour lesquelles existent des valeurs manquantes sont passées en \texttt{float64} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.dtypes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## height    float64
## weight      int64
## age       float64
## taille      int64
## dtype: object
\end{lstlisting}

\begin{remarque}
On note que les données sont enregistrées sur un type \texttt{float64}. Lorsqu'on travaille sur un tableau ne comportant pas de valeurs manquantes, dont le type est \texttt{int} ou \texttt{bool}, si on introduit une valeur manquante, \texttt{pandas} changera le type des données en \texttt{float64} et \texttt{object}, respectivement.
\end{remarque}

\texttt{pandas} propose différentes pour manipuler les valeurs manquantes.

\subsection{Repérer les valeurs manquantes}\label{repuxe9rer-les-valeurs-manquantes}

Avec la méthode \texttt{isnull()}, un masque de booléens est retournée, indiquant \texttt{True} pour les observations dont la valeur est \texttt{NaN} ou \texttt{None} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(s.isnull())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    False
## 1     True
## 2    False
## 3     True
## dtype: bool
\end{lstlisting}

Pour savoir si une valeur n'est pas nulle, on dispose de la méthode \texttt{notnull()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(s.notnull())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0     True
## 1    False
## 2     True
## 3    False
## dtype: bool
\end{lstlisting}

\subsection{Retirer les observations avec valeurs manquantes}\label{retirer-les-observations-avec-valeurs-manquantes}

La méthode \texttt{dropna()} permet quant à elle de retirer les observations disposant de valeurs nulles :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.dropna())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight   age  taille
## 0    58.0     115  28.0     162
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
\end{lstlisting}

\subsection{Retirer les valeurs manquantes par d'autres valeurs}\label{retirer-les-valeurs-manquantes-par-dautres-valeurs}

Pour remplacer les valeurs manquantes par d'autres valeurs, \texttt{pandas} propose d'utiliser la méthode \texttt{fillna()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.fillna(}\OperatorTok{{-}}\DecValTok{9999}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight     age  taille
## 0    58.0     115    28.0     162
## 1    59.0     117    33.0     156
## 2    60.0     120    31.0     172
## 3    61.0     123 -9999.0     160
## 4 -9999.0     126    29.0     158
\end{lstlisting}

\section{Suppressions}\label{suppressions}

Pour supprimer une valeur sur un des axes d'une série ou d'un dataframe, \texttt{NumPy} propose la méthode \texttt{drop()}.

\subsection{Suppression d'éléments dans une série}\label{suppression-duxe9luxe9ments-dans-une-suxe9rie}

Pour illustrer le fonctionnement de la méthode \texttt{drop()}, créons une série avec un index numérique, une autre avec un index textuel :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\NormalTok{s\_texte }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"d"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

On peut supprimer un élément d'une série en utilisant son nom :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pour s\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.drop(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pour s_num : 
##  0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{pour s\_texte : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.drop(}\StringTok{"c"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## pour s_texte : 
##  a    4.0
## b   -1.0
## d    NaN
## dtype: float64
\end{lstlisting}

On peut aussi aller récupérer le nom en fonction de la position, en passant par un détour en utilisant la méthode \texttt{index()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(s.drop(s\_num.index[}\DecValTok{0}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## KeyError: '[5] not found in axis'
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num.index[0] : "}\NormalTok{, s\_num.index[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num.index[0] :  5
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_texte.index[0] : "}\NormalTok{, s\_texte.index[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_texte.index[0] :  c
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pour s\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.drop(s\_num.index[}\DecValTok{0}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pour s_num : 
##  0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{pour s\_texte : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.drop(s\_texte.index[}\DecValTok{0}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## pour s_texte : 
##  a    4.0
## b   -1.0
## d    NaN
## dtype: float64
\end{lstlisting}

Pour supprimer plusieurs éléments, il suffit de fournir plusieurs noms d'indice dans une liste à la méthode \texttt{drop()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pour s\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.drop([}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pour s_num : 
##  0    4.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{pour s\_texte : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.drop([}\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## pour s_texte : 
##  a    4.0
## d    NaN
## dtype: float64
\end{lstlisting}

À nouveau, on peut aller récupérer le nom en fonction de la position, en passant par un détour en utilisant la méthode \texttt{index()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(s.drop(s\_num.index[}\DecValTok{0}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## KeyError: '[5] not found in axis'
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num.index[[0,2]] : "}\NormalTok{, s\_num.index[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num.index[[0,2]] :  Index([5, 4], dtype='int64')
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_texte.index[[0,2]] : "}\NormalTok{, s\_texte.index[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_texte.index[[0,2]] :  Index(['c', 'b'], dtype='object')
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pour s\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num.drop(s\_num.index[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pour s_num : 
##  0    4.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{pour s\_texte : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_texte.drop(s\_texte.index[[}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## pour s_texte : 
##  a    4.0
## d    NaN
## dtype: float64
\end{lstlisting}

Il est possible d'utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Section~\ref{decoupage-series})

\subsection{Suppression d'éléments dans un dataframe}\label{suppression-duxe9luxe9ments-dans-un-dataframe}

Pour illustrer le fonctionnement de la méthode \texttt{drop()} sur un dataframe, créons-en un :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\NormalTok{s\_texte }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"d"}\NormalTok{])}
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, np.nan],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, np.nan, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Suppressions de lignes}\label{suppressions-de-lignes}

Pour supprimer une ligne d'un dataframe, on peut faire référence à son nom (ici, les noms sont des numéros, mais ce sont bien des labels) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer la première ligne :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(}\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer la première ligne :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158
\end{lstlisting}

Si les lignes ont des labels textuels, on peut au préalable aller les récupérer à l'aide de la méthode \texttt{index()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{label\_pos\_0 }\OperatorTok{=}\NormalTok{ df.index[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer la première ligne :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(label\_pos\_0))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer la première ligne :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158
\end{lstlisting}

Pour supprimer plusieurs lignes, on donne le nom de ces lignes dans une liste à la méthode \texttt{drop()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer les 1ère et 4e lignes :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop([}\DecValTok{0}\NormalTok{,}\DecValTok{3}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer les 1ère et 4e lignes :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 4     NaN     126  29.0     158
\end{lstlisting}

Ou encore, en indiquant les positions des lignes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{label\_pos }\OperatorTok{=}\NormalTok{ df.index[[}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{]]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer les 1ère et 4e lignes :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(label\_pos))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer les 1ère et 4e lignes :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 4     NaN     126  29.0     158
\end{lstlisting}

Il est possible d'utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Sections~\ref{decoupage-df-lignes} et \ref{decoupage-df-colonnes})

\subsubsection{Suppressions de colonnes}\label{suppressions-de-colonnes}

Pour supprimer une colonne d'un dataframe, on procède de la même manière que pour les lignes, mais en ajoutant le paramètre \texttt{axis=1} à la méthode \texttt{drop()} pour préciser que l'on s'intéresse aux colonnes :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer la première colonne :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(}\StringTok{"height"}\NormalTok{, axis}\OperatorTok{=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer la première colonne :  
##     weight   age  taille
## 0     115  28.0     162
## 1     117  33.0     156
## 2     120  31.0     172
## 3     123   NaN     160
## 4     126  29.0     158
\end{lstlisting}

On peut au préalable aller récupérer les labels des colonnes en fonction de leur position à l'aide de la méthode \texttt{columns()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{label\_pos }\OperatorTok{=}\NormalTok{ df.columns[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"label\_pos : "}\NormalTok{, label\_pos)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## label_pos :  height
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer la première colonne :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(label\_pos, axis}\OperatorTok{=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer la première colonne :  
##     weight   age  taille
## 0     115  28.0     162
## 1     117  33.0     156
## 2     120  31.0     172
## 3     123   NaN     160
## 4     126  29.0     158
\end{lstlisting}

Pour supprimer plusieurs colonnes, on donne le nom de ces colonnes dans une liste à la méthode \texttt{drop()} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer les 1ère et 4e colonnes :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop([}\StringTok{"height"}\NormalTok{, }\StringTok{"taille"}\NormalTok{], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer les 1ère et 4e colonnes :  
##     weight   age
## 0     115  28.0
## 1     117  33.0
## 2     120  31.0
## 3     123   NaN
## 4     126  29.0
\end{lstlisting}

Ou encore, en indiquant les positions des colonnes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{label\_pos }\OperatorTok{=}\NormalTok{ df.columns[[}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{]]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Supprimer les 1ère et 4e colonnes :  }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.drop(label\_pos, axis}\OperatorTok{=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## Supprimer les 1ère et 4e colonnes :  
##     weight   age
## 0     115  28.0
## 1     117  33.0
## 2     120  31.0
## 3     123   NaN
## 4     126  29.0
\end{lstlisting}

Il est possible d'utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Sections~\ref{decoupage-df-lignes} et \ref{decoupage-df-colonnes})

\section{Remplacement de valeurs}\label{remplacement-de-valeurs}

Nous allons à présent regarder comment modifier une ou plusieurs valeurs, dans le cas d'une série puis d'un dataframe.

\subsection{Pour une série}\label{pour-une-suxe9rie}

Pour modifier une valeur particulière dans une série ou dans un dataframe, on peut utiliser le symbole égale (\texttt{=}) en ayant au préalable ciblé l'emplacement de la valeur à modifier, à l'aide des techniques d'extraction expliquées dans la Section~\ref{pandas-selection}.

Par exemple, considérons la série suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num : "}\NormalTok{, s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

Modifions le deuxième élément élément de \texttt{s\_num}, pour lui donner la valeur -3 :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num.iloc[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num : "}\NormalTok{, s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num :  5    1.0
## 0   -3.0
## 4   -1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

Il est évidemment possible de modifier plusieurs valeurs à la fois.

Il suffit à nouveau de cibler les positions (on peu utiliser de nombreuses manières de le faire) et de fournir un objet de dimensions équivalentes pour venir remplacer les valeurs ciblées. Par exemple, dans notre série \texttt{s\_num}, allons remplacer les valeurs en position 1 et 3 (2e et 4e valeurs) par -10 et -9 :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num.iloc[[}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{]] }\OperatorTok{=}\NormalTok{ [}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\OperatorTok{{-}}\DecValTok{9}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 5     1.0
## 0   -10.0
## 4    -1.0
## 1    -9.0
## dtype: float64
\end{lstlisting}

\subsection{Pour un dataframe}\label{pour-un-dataframe}

Considérons le dataframe suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"ville"}\NormalTok{ : [}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{,}
                   \StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{],}
        \StringTok{"annee"}\NormalTok{: [}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{2018}\NormalTok{,}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{],}
        \StringTok{"x"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{],}
        \StringTok{"y"}\NormalTok{: [}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4
\end{lstlisting}

\subsubsection{Modifications d'une valeur particulière}\label{modifications-dune-valeur-particuliuxe8re}

Modifions la valeur de la première ligne de \texttt{df} pour la colonne \texttt{annee}, pour que celle-ci vaille 2020. Dans un premier temps, récupérons la position de la colonne \texttt{annee} dans le dataframe, à l'aide de la méthode \texttt{get\_loc()} appliquée à l'attribut \texttt{colnames} du dataframe :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pos\_annee }\OperatorTok{=}\NormalTok{ df.columns.get\_loc(}\StringTok{"annee"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"pos\_annee : "}\NormalTok{, pos\_annee)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pos_annee :  1
\end{lstlisting}

Ensuite, effectuons la modification :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.iloc[}\DecValTok{0}\NormalTok{,pos\_annee] }\OperatorTok{=} \DecValTok{2020}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4
\end{lstlisting}

\subsubsection{Modifications sur une ou plusieurs colonnes}\label{modifications-sur-une-ou-plusieurs-colonnes}

Pour modifier toutes les valeurs d'une colonne pour y placer une valeur particulière, par exemple un 2 dans la colonne \texttt{x} de \texttt{df} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.x }\OperatorTok{=} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  2  4
## 5      Paris   2019  2  4
\end{lstlisting}

On peut également modifier les valeurs de la colonne en fournissant une liste de valeurs :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.x }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  3
## 1        Aix   2019  3  3
## 2  Marseille   2018  4  2
## 3        Aix   2018  2  1
## 4      Paris   2019  1  4
## 5      Paris   2019  0  4
\end{lstlisting}

On peut donc imaginer modifier les valeurs d'une colonne en fonction des valeurs que l'on lit dans une autre colonne. Par exemple, admettons le code suivant : si la valeur de \texttt{y} vaut 2, alors celle de x vaut ``a'', si la valeur de \texttt{y} vaut 1, lors celle de \texttt{x} vaut ``b'', sinon, elle vaut \texttt{NaN}. Dans un premier temps, construisons une liste contenant les valeurs à insérer (que nous nommerons \texttt{nv\_val}), à l'aide d'une boucle. Nous allons parcourir tous les éléments de la colonne \texttt{y}, et à chaque itération ajouter à \texttt{nv\_val} la valeur obtenue en effectuant nos comparaisons :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nv\_val }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ np.arange(}\BuiltInTok{len}\NormalTok{(df.index)):}
        \ControlFlowTok{if}\NormalTok{ df.y[i] }\OperatorTok{==} \DecValTok{2}\NormalTok{:}
\NormalTok{            nv\_val.append(}\StringTok{"a"}\NormalTok{)}
        \ControlFlowTok{elif}\NormalTok{ df.y[i] }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
\NormalTok{            nv\_val.append(}\StringTok{"b"}\NormalTok{)}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            nv\_val.append(np.nan)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"nv\_val : "}\NormalTok{, nv\_val)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nv_val :  [nan, nan, 'a', 'b', nan, nan]
\end{lstlisting}

Nous sommes prêts à modifier le contenu de la colonne \texttt{x} de \texttt{df} pour le remplacer par \texttt{nv\_val} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.x }\OperatorTok{=}\NormalTok{ nv\_val}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee    x  y
## 0  Marseille   2020  NaN  3
## 1        Aix   2019  NaN  3
## 2  Marseille   2018    a  2
## 3        Aix   2018    b  1
## 4      Paris   2019  NaN  4
## 5      Paris   2019  NaN  4
\end{lstlisting}

Pour remplacer plusieurs colonnes en même temps :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[[}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{]] }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}
    \StringTok{"x"}\NormalTok{: [}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{],}
    \StringTok{"y"}\NormalTok{: [}\DecValTok{1}\NormalTok{]}\OperatorTok{*}\DecValTok{6}
\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1        Aix   2019  3  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1
\end{lstlisting}

Dans l'instruction précédente, nous avons remplacé le contenu des colonnes \texttt{x} et \texttt{y} par une vecteur de valeurs écrites à la main pour \texttt{x} et par la valeur 1 pour toutes les observations pour \texttt{y}.

\subsubsection{Modifications sur une ou plusieurs lignes}\label{modifications-sur-une-ou-plusieurs-lignes}

Pour remplacer une ligne par une valeur constante (peu d'intérêt ici) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.iloc[}\DecValTok{1}\NormalTok{,:] }\OperatorTok{=} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1          1      1  1  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1
\end{lstlisting}

Il peut être plus intéressant de remplacer une observation comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.iloc[}\DecValTok{1}\NormalTok{,:] }\OperatorTok{=}\NormalTok{ [}\StringTok{"Aix"}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1        Aix   2018  1  2
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1
\end{lstlisting}

Pour remplacer plusieurs lignes, la méthode est identique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.iloc[[}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{],:] }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\StringTok{"Aix"}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{],}
\NormalTok{    [}\StringTok{"Aix"}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1        Aix   2018  1  2
## 2  Marseille   2018  4  1
## 3        Aix   2018 -1 -1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1
\end{lstlisting}

\section{Ajout de valeurs}\label{pandas-ajout-valeurs}

Regardons à présent comment ajouter des valeurs, dans une série d'abord, puis dans un dataframe.

\subsection{Pour une série}\label{pour-une-suxe9rie-1}

Considérons la série suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, np.nan],}
\NormalTok{             index }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num : "}\NormalTok{, s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64
\end{lstlisting}

\subsubsection{Ajout d'une seule valeur dans une série}\label{ajout-dune-seule-valeur-dans-une-suxe9rie}

Pour ajouter une valeur, on utlise la méthode \texttt{concat()} de pandas. Ici, avec \texttt{s\_num}, comme l'index est manuel, nous sommes obligés de fournir une série avec une valeur pour l'index également :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num\_2 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{], index }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num\_2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num_2 : 
##  2    1
## dtype: int64
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.concat([s\_num, s\_num\_2])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num : 
##  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## 2    1.0
## dtype: float64
\end{lstlisting}

On note que la méthode \texttt{concat()} retourne une vue, et que pour répercuter l'ajout, il est nécessaire d'effectuer une nouvelle affectation.

En ayant une série avec un index numérique généré automatiquement, on peut préciser la valeur \texttt{True} pour le paramètre \texttt{ignore\_index} de la méthode \texttt{concat()} pour indiquer de ne pas tenir compte de la valeur de l'index de l'objet que l'on ajoute :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.concat([s, pd.Series([}\DecValTok{2}\NormalTok{])], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s : 
##  0    10
## 1     2
## 2     4
## 3     2
## dtype: int64
\end{lstlisting}

\subsubsection{Ajout de plusieurs valeurs dans une série}\label{ajout-de-plusieurs-valeurs-dans-une-suxe9rie}

Pour ajouter plusieurs valeurs, on utlise la méthode \texttt{concat()}. Ici, avec \texttt{s\_num}, comme l'index est manuel, nous sommes obligé de fournir une série avec une valeur pour l'index également :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_num\_2 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{], index }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{])}
\NormalTok{s\_num }\OperatorTok{=}\NormalTok{ pd.concat([s\_num, s\_num\_2])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"s\_num : "}\NormalTok{, s\_num)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## 2    1.0
## 2    1.0
## dtype: float64
\end{lstlisting}

En ayant une série avec un index numérique généré automatiquement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.concat([s, pd.Series([}\DecValTok{2}\NormalTok{])], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Pour un dataframe}\label{pour-un-dataframe-1}

Reprenons notre dataframe :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"ville"}\NormalTok{ : [}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{,}
                   \StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{],}
        \StringTok{"annee"}\NormalTok{: [}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{2018}\NormalTok{,}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{],}
        \StringTok{"x"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{],}
        \StringTok{"y"}\NormalTok{: [}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4
\end{lstlisting}

\subsubsection{Ajout d'une ligne dans un dataframe}\label{pandas-ajout-ligne-df}

Comme pour une série, pour ajouter une ligne, on utlise la méthode \texttt{concat()}. Dans un premier temps, créons un nouveau dataframe avec la ligne à ajouter :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nv\_ligne }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"2021"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{]],}
\NormalTok{                       columns }\OperatorTok{=}\NormalTok{ df.columns)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"nv\_ligne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, nv\_ligne)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nv_ligne : 
##         ville annee  x  y
## 0  Marseille  2021  2  4
\end{lstlisting}

On s'est assuré d'avoir le même nom de colonnes ici, en indiquant au paramètre \texttt{columns} de la méthode \texttt{pd.DataFrame} le nom des colonnes de \texttt{df}, c'est-à-dire \texttt{df.columns}.

Ajoutons la nouvelle ligne à \texttt{df} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.concat([df, nv\_ligne], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

À nouveau,la méthode \texttt{concat()} appliquée à un dataframe, retourne une vue et n'affecte pas l'objet.

On peut noter que lors de l'ajout d'une ligne, si le nom des colonnes n'est pas indiqué dans le même ordre que dans le dataframe dans lequel est effectué l'ajout, il faut rajouter une indication au paramètre \texttt{sort} de la méthode \texttt{concat()} :

\begin{itemize}
\tightlist
\item
  si \texttt{sort=True}, l'ordre des colonnes de la ligne ajoutée sera appliqué au dataframe de destination ;
\item
  si \texttt{sort=False}, l'odre des colonnes du dataframe de destination ne sera pas modifié.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nv\_ligne }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\StringTok{"2021"}\NormalTok{, }\StringTok{"Marseille"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{]],}
\NormalTok{                       columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"annee"}\NormalTok{, }\StringTok{"ville"}\NormalTok{, }\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"nv\_ligne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, nv\_ligne)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nv_ligne : 
##    annee      ville  x  y
## 0  2021  Marseille  2  4
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"avec sort=True : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }
\NormalTok{  pd.concat([df, nv\_ligne], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{, sort}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## avec sort=True : 
##    annee      ville  x  y
## 0  2019  Marseille  1  3
## 1  2019        Aix  2  3
## 2  2018  Marseille  2  2
## 3  2018        Aix  2  1
## 4  2019      Paris  0  4
## 5  2019      Paris  0  4
## 6  2021  Marseille  2  4
## 7  2021  Marseille  2  4
\end{lstlisting}

\subsubsection{Ajout de plusieurs lignes dans un dataframe}\label{ajout-de-plusieurs-lignes-dans-un-dataframe}

Pour ajouter plusieurs lignes, c'est exactement le même principe qu'avec une seule, il suffit juste d'ajouter un dataframe de plusieurs lignes, avec encore une fois les mêmes noms.

Les lignes à insérer :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nv\_lignes }\OperatorTok{=}\NormalTok{ pd.DataFrame([}
\NormalTok{    [}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"2022"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{],}
\NormalTok{    [}\StringTok{"Aix"}\NormalTok{, }\StringTok{"2022"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{]],}
\NormalTok{    columns }\OperatorTok{=}\NormalTok{ df.columns)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"nv\_ligne : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, nv\_lignes)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## nv_ligne : 
##         ville annee  x  y
## 0  Marseille  2022  2  4
## 1        Aix  2022  3  3
\end{lstlisting}

Puis l'insertion :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.concat([df,nv\_lignes], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Ajout d'une colonne dans un dataframe}\label{ajout-dune-colonne-dans-un-dataframe}

Pour ajouter une colonne dans un dataframe :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ numpy }\ImportTok{import}\NormalTok{ random}
\NormalTok{df[}\StringTok{"z"}\NormalTok{] }\OperatorTok{=}\NormalTok{ random.rand(}\BuiltInTok{len}\NormalTok{(df.index))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville annee  x  y         z
## 0  Marseille  2019  1  3  0.117443
## 1        Aix  2019  2  3  0.393782
## 2  Marseille  2018  2  2  0.452730
## 3        Aix  2018  2  1  0.538148
## 4      Paris  2019  0  4  0.790622
## 5      Paris  2019  0  4  0.465836
## 6  Marseille  2021  2  4  0.435332
## 7  Marseille  2022  2  4  0.569479
## 8        Aix  2022  3  3  0.969259
\end{lstlisting}

\subsubsection{Ajout de plusieurs colonnes dans un dataframe}\label{ajout-de-plusieurs-colonnes-dans-un-dataframe}

Pour ajouter plusieurs colonnes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\StringTok{"a"}\NormalTok{] }\OperatorTok{=}\NormalTok{ random.rand(}\BuiltInTok{len}\NormalTok{(df.index))}
\NormalTok{df[}\StringTok{"b"}\NormalTok{] }\OperatorTok{=}\NormalTok{ random.rand(}\BuiltInTok{len}\NormalTok{(df.index))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## df : 
##         ville annee  x  y         z         a         b
## 0  Marseille  2019  1  3  0.117443  0.040556  0.689236
## 1        Aix  2019  2  3  0.393782  0.548120  0.929546
## 2  Marseille  2018  2  2  0.452730  0.462577  0.918117
## 3        Aix  2018  2  1  0.538148  0.376472  0.975302
## 4      Paris  2019  0  4  0.790622  0.327912  0.397002
## 5      Paris  2019  0  4  0.465836  0.813529  0.262626
## 6  Marseille  2021  2  4  0.435332  0.646552  0.430151
## 7  Marseille  2022  2  4  0.569479  0.047426  0.764531
## 8        Aix  2022  3  3  0.969259  0.994958  0.599731
\end{lstlisting}

\section{Retrait des valeurs dupliquées}\label{retrait-des-valeurs-dupliquuxe9es}

Pour retirer les valeurs dupliquées dans un dataframe, \texttt{NumPy} propose la méthode \texttt{drop\_duplicates()}, qui prend plusieurs paramètres optionnels :

\begin{itemize}
\item
  \texttt{subset} : en indiquant un ou plusieurs noms de colonnes, la recherche de doublons se fait uniquement sur ces colonnes ;
\item
  \texttt{keep} : permet d'indiquer quelle observation garder en cas de doublons identifies :

  \begin{itemize}
  \tightlist
  \item
    si \texttt{keep=\textquotesingle{}first\textquotesingle{}}, tous les doublons sont retirés sauf la première occurrence,
  \item
    si \texttt{keep=\textquotesingle{}last\textquotesingle{}}, tous les doublons sont retirés sauf la dernière occurrence,
    -si \texttt{keep=\textquotesingle{}False\textquotesingle{}}, tous les doublons sont retirés ;
  \end{itemize}
\item
  \texttt{inplace} : booléen (défaut : \texttt{False}) pour indiquer si le retrait des doublons doit s'effectuer sur le dataframe ou bien si une copie doit être retournée (par défaut).
\end{itemize}

Donnons quelques exemples à l'aide de ce dataframe qui compose deux doublons quand on considère sa totalité. Si on se concentre uniquement sur les années ou les villes, ou les deux, d'autres doublons peuvent être identifiés.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"ville"}\NormalTok{ : [}\StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{,}
                   \StringTok{"Marseille"}\NormalTok{, }\StringTok{"Aix"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{],}
        \StringTok{"annee"}\NormalTok{: [}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{2018}\NormalTok{,}\DecValTok{2019}\NormalTok{, }\DecValTok{2019}\NormalTok{],}
        \StringTok{"x"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{],}
        \StringTok{"y"}\NormalTok{: [}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{],}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4
\end{lstlisting}

Pour retirer les doublons :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.drop\_duplicates())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
\end{lstlisting}

Retirer les doublons en gardant la dernière valeur des doublons identifiés :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.drop\_duplicates(keep}\OperatorTok{=}\StringTok{\textquotesingle{}last\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 5      Paris   2019  0  4
\end{lstlisting}

Pour retirer les doublons identifiés quand on se concentre sur le nom des villes, et en conservant uniquement la première valeur :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.drop\_duplicates(subset }\OperatorTok{=}\NormalTok{ [}\StringTok{"ville"}\NormalTok{], keep }\OperatorTok{=} \StringTok{\textquotesingle{}first\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 4      Paris   2019  0  4
\end{lstlisting}

Idem mais en se concentrant sur les couples (ville, annee)

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.drop\_duplicates(subset }\OperatorTok{=}\NormalTok{ [}\StringTok{"ville"}\NormalTok{, }\StringTok{"annee"}\NormalTok{], keep }\OperatorTok{=} \StringTok{\textquotesingle{}first\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
\end{lstlisting}

On note que le dataframe original n'a pas été impacté, puisque nous n'avons pas touché au paramètre \texttt{inplace}. Si à présent, nous demandons à ce que les changement soient opérés sur le dataframe plutôt que de récupérer une copie :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.drop\_duplicates(subset }\OperatorTok{=}\NormalTok{ [}\StringTok{"ville"}\NormalTok{, }\StringTok{"annee"}\NormalTok{], keep }\OperatorTok{=} \StringTok{\textquotesingle{}first\textquotesingle{}}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
\end{lstlisting}

Pour savoir si une valeur est dupliquée dans un dataframe, \texttt{NumPy} propose la méthode \texttt{duplicated()}, qui retourne un masque indiquant pour chaque observation, si elle est dupliquée ou non. Son fonctionnement est similaire à \texttt{df.drop\_duplicates()}, hormis pour le paramètre \texttt{inplace} qui n'est pas présent.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.duplicated(subset }\OperatorTok{=}\NormalTok{ [}\StringTok{"ville"}\NormalTok{], keep }\OperatorTok{=} \StringTok{\textquotesingle{}first\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    False
## 1    False
## 2     True
## 3     True
## 4    False
## dtype: bool
\end{lstlisting}

On peut utiliser la méthode \texttt{any()} par la suite pour savoir s'il existe des doublons :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.duplicated(subset }\OperatorTok{=}\NormalTok{ [}\StringTok{"ville"}\NormalTok{], keep }\OperatorTok{=} \StringTok{\textquotesingle{}first\textquotesingle{}}\NormalTok{).}\BuiltInTok{any}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## True
\end{lstlisting}

\section{Opérations}\label{opuxe9rations}

Il est souvent nécessaire de devoir effectuer des opérations sur les colonnes d'un dataframe, notamment lorsqu'il s'agit de créer une nouvelle variable.

En reprenant les principes de modification de colonnes (c.f. Section~@ref(\#pandas-ajout-valeurs)), on imagine assez facilement qu'il est possible d'appliquer les fonctions et méthodes de \texttt{NumPy} (c.f. Section~\ref{numpy-tableaux}) sur les valeurs des colonnes.

Par exemple, considérons le dataframe suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : }
\NormalTok{               [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{,}
                \DecValTok{63}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{66}\NormalTok{, }\DecValTok{67}\NormalTok{,}
                \DecValTok{68}\NormalTok{, }\DecValTok{69}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{72}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: }
\NormalTok{               [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{,}
                \DecValTok{129}\NormalTok{, }\DecValTok{132}\NormalTok{, }\DecValTok{135}\NormalTok{, }\DecValTok{139}\NormalTok{, }\DecValTok{142}\NormalTok{,}
                \DecValTok{146}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{154}\NormalTok{, }\DecValTok{159}\NormalTok{, }\DecValTok{164}\NormalTok{]}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     height  weight
## 0       58     115
## 1       59     117
## 2       60     120
## 3       61     123
## 4       62     126
## 5       63     129
## 6       64     132
## 7       65     135
## 8       66     139
## 9       67     142
## 10      68     146
## 11      69     150
## 12      70     154
## 13      71     159
## 14      72     164
\end{lstlisting}

Ajoutons la colonne \texttt{height\_2}, élevant les valeurs de la colonne \texttt{height} au carré :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\StringTok{"height\_2"}\NormalTok{] }\OperatorTok{=}\NormalTok{ df.height}\OperatorTok{**}\DecValTok{2}
\BuiltInTok{print}\NormalTok{(df.head(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  height_2
## 0      58     115      3364
## 1      59     117      3481
## 2      60     120      3600
\end{lstlisting}

À présent, ajoutons la colonne \texttt{imc}, fournissant les valeurs de l'indicateur de masse corporelle pour les individus du dataframe (\(\text{IMC} = \frac{\text{weight}}{\text{height}^2}\)) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\StringTok{"imc"}\NormalTok{] }\OperatorTok{=}\NormalTok{ df.weight }\OperatorTok{/}\NormalTok{ df.height\_2}
\BuiltInTok{print}\NormalTok{(df.head(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  height_2       imc
## 0      58     115      3364  0.034185
## 1      59     117      3481  0.033611
## 2      60     120      3600  0.033333
\end{lstlisting}

\subsection{Statistiques}\label{pandas-statistiques-df}

\texttt{pandas} propose quelques méthodes pour effectuer des statistiques descriptives pour chaque colonne ou par ligne. Pour cela, la syntaxe est la suivante (tous les paramètres ont une valeur par défaut, la liste est simplifiée ici) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dataframe.fonction\_stat(axis, skipna)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{axis} : 0 pour les lignes, 1 pour les colonnes ;
\item
  \texttt{skipna} : si \texttt{True}, exclue les valeurs manquantes pour effectuer les calculs.
\end{itemize}

Parmi les méthodes disponibles :

\begin{itemize}
\tightlist
\item
  \texttt{mean()} : moyenne ;
\item
  \texttt{mode()} : mode ;
\item
  \texttt{median()} : médiane ;
\item
  \texttt{std()} : écart-type ;
\item
  \texttt{min()} : minimum ;
\item
  \texttt{max()} : maximum
\item
  \texttt{mad()} : écart absolu à la moyenne ;
\item
  \texttt{sum()} : somme des valeurs ;
\item
  \texttt{prod()} : produit de tous les éléments ;
\item
  \texttt{count()} : comptage du nombre d'éléments.
\end{itemize}

Par exemple, pour calculer la moyenne des valeurs pour chaque colonne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, }\DecValTok{117}\NormalTok{, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
        \StringTok{"married"}\NormalTok{: [}\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{],}
        \StringTok{"city"}\NormalTok{: [}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"A"}\NormalTok{]}
\NormalTok{       \}}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\BuiltInTok{print}\NormalTok{(df.mean(numeric\_only}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## height      60.0
## weight     120.2
## age         30.4
## taille     161.6
## married      0.6
## dtype: float64
\end{lstlisting}

Si on le souhaite, on peut faire la moyenne des valeurs en colonne (sans aucun sens ici) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.mean(axis}\OperatorTok{=}\DecValTok{1}\NormalTok{, numeric\_only}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 0    72.8
## 1    73.2
## 2    76.6
## 3    75.0
## 4    75.2
## dtype: object
\end{lstlisting}

Ces fonctions peuvent s'appliquer sur une seule colonne. Par exemple, pour afficher la valeur minimum :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"min : "}\NormalTok{, df.height.}\BuiltInTok{min}\NormalTok{(numeric\_only}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## min :  58
\end{lstlisting}

Il est aussi utile de pouvoir obtenir la position des valeurs min et max ; ce qu'on peut obtenir avec les méthodes \texttt{idxmin()} et \texttt{idxmax()}, respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pos min : "}\NormalTok{, df.height.idxmin())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pos min :  0
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"pos min : "}\NormalTok{, df.height.idxmax())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## pos min :  4
\end{lstlisting}

Une méthode très pratique est \texttt{describe()}, elle permet de retourner des statistiques descriptives sur l'ensemble des colonnes numériques :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.describe())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##           height      weight        age      taille
## count   5.000000    5.000000   5.000000    5.000000
## mean   60.000000  120.200000  30.400000  161.600000
## std     1.581139    4.438468   1.949359    6.228965
## min    58.000000  115.000000  28.000000  156.000000
## 25%    59.000000  117.000000  29.000000  158.000000
## 50%    60.000000  120.000000  31.000000  160.000000
## 75%    61.000000  123.000000  31.000000  162.000000
## max    62.000000  126.000000  33.000000  172.000000
\end{lstlisting}

\section{Tri}\label{tri-2}

Il est aisé de trier un dataframe par ordre croissant ou décroissant d'une ou plusieurs de ses colonnes. Pour ce faire, on utilise la méthode \texttt{sort\_values()}. La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DataFrame.sort\_values(by, axis}\OperatorTok{=}\DecValTok{0}\NormalTok{, ascending}\OperatorTok{=}\VariableTok{True}\NormalTok{,}
\NormalTok{                      inplace}\OperatorTok{=}\VariableTok{False}\NormalTok{, kind}\OperatorTok{=}\StringTok{"quicksort"}\NormalTok{,}
\NormalTok{                      na\_position}\OperatorTok{=}\StringTok{"last"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{by} : nom ou liste de nom de la ou les colonnes utilisées pour effectuer le tri ;
\item
  \texttt{axis} : \texttt{0} pour l'index (par défaut), \texttt{1} pour les colonnes
\item
  \texttt{ascending} : booléen ou liste de booléens, quand \texttt{True} le tri est fait par valeurs croissantes (par défaut), quand \texttt{False} il est effectué par valeurs décroissantes
\item
  \texttt{inplace} : si \texttt{True}, le tri affecte le dataframe, sinon il retourne une vue ;
\item
  \texttt{kind} : choix de l'algorithme de tri (\texttt{quicksort} (par défaut), \texttt{mergesort}, \texttt{heapsort}) ;
\item
  \texttt{na\_position} : si \texttt{first}, les valeurs manquantes sont placées au début ; si \texttt{last} (par défaut), à la fin.
\end{itemize}

Donnons quelques exemples :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dico }\OperatorTok{=}\NormalTok{ \{}\StringTok{"height"}\NormalTok{ : [}\DecValTok{58}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{62}\NormalTok{],}
        \StringTok{"weight"}\NormalTok{: [}\DecValTok{115}\NormalTok{, np.nan, }\DecValTok{120}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{126}\NormalTok{],}
        \StringTok{"age"}\NormalTok{: [}\DecValTok{28}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{29}\NormalTok{],}
        \StringTok{"taille"}\NormalTok{: [}\DecValTok{162}\NormalTok{, }\DecValTok{156}\NormalTok{, }\DecValTok{172}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{158}\NormalTok{],}
        \StringTok{"married"}\NormalTok{: [}\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{, np.nan, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{],}
        \StringTok{"city"}\NormalTok{: [}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"A"}\NormalTok{]}
\NormalTok{       \} }
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(dico)}
\end{Highlighting}
\end{Shaded}

Si on trie les valeurs par ordre décroissant des valeurs de la colonne \texttt{height} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.sort\_values(by}\OperatorTok{=}\StringTok{"height"}\NormalTok{, ascending}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille married city
## 4      62   126.0   29     158    True    A
## 3      61   123.0   31     160   False    B
## 2      60   120.0   31     172     NaN    B
## 1      59     NaN   33     156    True    B
## 0      58   115.0   28     162    True    A
\end{lstlisting}

Pour effectuer un tri par ordre croissant des valeurs de \texttt{married} (rappel, \texttt{True} est interprété comme 1 et \texttt{False} comme 0), puis décoissant de \texttt{weight}, en plaçant les valeurs \texttt{NaN} en premier :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.sort\_values(by}\OperatorTok{=}\NormalTok{[}\StringTok{"married"}\NormalTok{, }\StringTok{"weight"}\NormalTok{],}
\NormalTok{               ascending}\OperatorTok{=}\NormalTok{[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{],}
\NormalTok{               na\_position}\OperatorTok{=}\StringTok{"first"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    height  weight  age  taille married city
## 2      60   120.0   31     172     NaN    B
## 3      61   123.0   31     160   False    B
## 1      59     NaN   33     156    True    B
## 4      62   126.0   29     158    True    A
## 0      58   115.0   28     162    True    A
\end{lstlisting}

On note que les valeurs \texttt{NaN} sont remontées en avant pour les sous-groupes composés en fonction des valeurs de \texttt{married}.

\section{Concaténation}\label{concatuxe9nation}

Il est fréquent d'avoir des données en provenance de plusieurs sources lorsque l'on réalise une analyse. Il est alors nécessaire de pouvoir combiner les différentes sources dans une seule. Dans cette section, nous allons nous contenter de concaténer différents dataframes entre-eux, dans des cas simples dans lesquels on sait \emph{a priori} qu'il suffit de coller deux dataframes côte-à-côte ou l'un en-dessous de l'aure. Le cas des jointures un peu plus élaborées avec appariement en fonction d'une ou plusieurs colonnes est abordé dans la Section~\ref{pandas-jointures}.

Dans un premier temps, créons deux dataframes avec le même nombre de lignes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(np.random.randn(}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{),}
\NormalTok{                   columns}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{])}
\NormalTok{x\_2 }\OperatorTok{=}\NormalTok{ pd.DataFrame(np.random.randn(}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{),}
\NormalTok{                   columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x\_1 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, x\_1)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x_1 : 
##            a         b         c         d
## 0  0.231711 -0.474710 -0.309147 -2.032396
## 1 -0.174468 -0.642475 -0.625023  1.325887
## 2  0.531255  1.275284 -0.682826 -0.948186
## 3  0.777362  0.325113 -1.203486  1.209543
## 4  0.157622 -0.293555  0.111560  0.597679
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{x\_2 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, x\_2)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## x_2 : 
##            e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318
\end{lstlisting}

Pour ``coller'' le dataframe \texttt{x\_2} à droite de \texttt{x\_1}, on peut utiliser la méthode \texttt{concat()} de \texttt{pandas}. Pour indiquer que la concaténation s'effectue sur les colonnes, on précise la valeur \texttt{1} pour le paramètre \texttt{axix} comme suit :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.concat([x\_1, x\_2], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##           a         b         c         d         e         f
## 0  0.231711 -0.474710 -0.309147 -2.032396 -1.270093  0.120949
## 1 -0.174468 -0.642475 -0.625023  1.325887 -0.193898  1.804172
## 2  0.531255  1.275284 -0.682826 -0.948186 -0.234694  0.939908
## 3  0.777362  0.325113 -1.203486  1.209543 -0.171520 -0.153055
## 4  0.157622 -0.293555  0.111560  0.597679 -0.363095 -0.067318
\end{lstlisting}

Pour coller les dataframes les uns en-dessous des autres, on peut utiliser la méthode \texttt{concat()} éaglement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_3 }\OperatorTok{=}\NormalTok{ pd.DataFrame(np.random.randn(}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{),}
\NormalTok{                   columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x\_3 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, x\_3)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x_3 : 
##            e         f
## 0  1.444721  0.325771
## 1 -0.855732 -0.697595
## 2 -0.276134 -1.258759
## 3  0.478094 -0.859764
## 4  0.571988 -0.173965
\end{lstlisting}

Rajoutons les observations de \texttt{x\_3} en-dessous de celles de \texttt{x\_2} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.concat([x\_2, x\_3], axis }\OperatorTok{=} \DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##           e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318
## 0  1.444721  0.325771
## 1 -0.855732 -0.697595
## 2 -0.276134 -1.258759
## 3  0.478094 -0.859764
## 4  0.571988 -0.173965
\end{lstlisting}

Comme on peut le voir, l'indice des lignes de \texttt{x\_2} n'a pas été modifié. Si on souhaite qu'il le soit, on peut le préciser via le paramètre \texttt{ignore\_index} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.concat([x\_2, x\_3], axis }\OperatorTok{=} \DecValTok{0}\NormalTok{, ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##           e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318
## 5  1.444721  0.325771
## 6 -0.855732 -0.697595
## 7 -0.276134 -1.258759
## 8  0.478094 -0.859764
## 9  0.571988 -0.173965
\end{lstlisting}

Si le nom des colonnes n'est pas ientique, des valeurs \texttt{NaN} seront introduites :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_4 }\OperatorTok{=}\NormalTok{ pd.DataFrame(np.random.randn(}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{),}
\NormalTok{                   columns }\OperatorTok{=}\NormalTok{ [}\StringTok{"e"}\NormalTok{, }\StringTok{"g"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"x\_4 : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, x\_4)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## x_4 : 
##            e         g
## 0  1.534900  0.872856
## 1  1.856835  0.025914
## 2  0.171984 -0.191163
## 3 -0.292936  1.655677
## 4 -0.207182 -0.686884
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.concat([x\_2, x\_4], axis }\OperatorTok{=} \DecValTok{0}\NormalTok{, sort}\OperatorTok{=}\VariableTok{False}\NormalTok{, ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##           e         f         g
## 0 -1.270093  0.120949       NaN
## 1 -0.193898  1.804172       NaN
## 2 -0.234694  0.939908       NaN
## 3 -0.171520 -0.153055       NaN
## 4 -0.363095 -0.067318       NaN
## 5  1.534900       NaN  0.872856
## 6  1.856835       NaN  0.025914
## 7  0.171984       NaN -0.191163
## 8 -0.292936       NaN  1.655677
## 9 -0.207182       NaN -0.686884
\end{lstlisting}

\section{Jointures}\label{pandas-jointures}

Il est plus fréquent d'avoir recours à des jointures un peu plus élaborées pour rassembler les différentes sources de données en une seule. \texttt{pandas} offre un moyen performant pour rassembler les données, la fonction \texttt{merge()}.

Pour illustrer les différentes jointures de cette section, créons quelques dataframes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exportations\_fr }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"country"}\NormalTok{ : }\StringTok{"France"}\NormalTok{,}
     \StringTok{"year"}\NormalTok{ : np.arange(}\DecValTok{2014}\NormalTok{, }\DecValTok{2017}\NormalTok{),}
     \StringTok{"exportations"}\NormalTok{ : [}\FloatTok{816.8192172}\NormalTok{, }\FloatTok{851.6632573}\NormalTok{, }\FloatTok{867.4014253}\NormalTok{]}
\NormalTok{    \})}

\NormalTok{importations\_fr }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"country"}\NormalTok{ : }\StringTok{"France"}\NormalTok{,}
     \StringTok{"year"}\NormalTok{ : np.arange(}\DecValTok{2015}\NormalTok{, }\DecValTok{2018}\NormalTok{),}
     \StringTok{"importations"}\NormalTok{ : [}\FloatTok{898.5242962}\NormalTok{, }\FloatTok{936.3691166}\NormalTok{, }\FloatTok{973.8762149}\NormalTok{]}
\NormalTok{    \})}

\NormalTok{exportations\_us }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"country"}\NormalTok{ : }\StringTok{"USA"}\NormalTok{,}
     \StringTok{"year"}\NormalTok{ : np.arange(}\DecValTok{2014}\NormalTok{, }\DecValTok{2017}\NormalTok{),}
     \StringTok{"exportations"}\NormalTok{ : [}\FloatTok{2208.678084}\NormalTok{, }\FloatTok{2217.733347}\NormalTok{, }\FloatTok{2210.442218}\NormalTok{]}
\NormalTok{    \})}

\NormalTok{importations\_us }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"country"}\NormalTok{ : }\StringTok{"USA"}\NormalTok{,}
     \StringTok{"year"}\NormalTok{ : np.arange(}\DecValTok{2015}\NormalTok{, }\DecValTok{2018}\NormalTok{),}
     \StringTok{"importations"}\NormalTok{ : [}\FloatTok{2827.336251}\NormalTok{, }\FloatTok{2863.264745}\NormalTok{, np.nan]}
\NormalTok{    \})}

\NormalTok{importations\_maroc }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"pays"}\NormalTok{ : }\StringTok{"Maroc"}\NormalTok{,}
     \StringTok{"annee"}\NormalTok{ : np.arange(}\DecValTok{2015}\NormalTok{, }\DecValTok{2018}\NormalTok{),}
     \StringTok{"importations"}\NormalTok{ : [}\FloatTok{46.39884177}\NormalTok{, }\FloatTok{53.52375588}\NormalTok{, }\FloatTok{56.68165748}\NormalTok{]}
\NormalTok{    \})}
\NormalTok{exportations\_maroc }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"country"}\NormalTok{ : }\StringTok{"Maroc"}\NormalTok{,}
     \StringTok{"year"}\NormalTok{ : np.arange(}\DecValTok{2014}\NormalTok{, }\DecValTok{2017}\NormalTok{),}
     \StringTok{"exportations"}\NormalTok{ : [}\FloatTok{35.50207915}\NormalTok{, }\FloatTok{37.45996653}\NormalTok{, }\FloatTok{39.38228396}\NormalTok{]}
\NormalTok{    \})}

\NormalTok{exportations }\OperatorTok{=}\NormalTok{ pd.concat([exportations\_fr, exportations\_us], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{importations }\OperatorTok{=}\NormalTok{ pd.concat([importations\_fr, importations\_us], ignore\_index}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"exportations : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, exportations)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## exportations : 
##    country  year  exportations
## 0  France  2014    816.819217
## 1  France  2015    851.663257
## 2  France  2016    867.401425
## 3     USA  2014   2208.678084
## 4     USA  2015   2217.733347
## 5     USA  2016   2210.442218
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{importations : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, importations)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## importations : 
##    country  year  importations
## 0  France  2015    898.524296
## 1  France  2016    936.369117
## 2  France  2017    973.876215
## 3     USA  2015   2827.336251
## 4     USA  2016   2863.264745
## 5     USA  2017           NaN
\end{lstlisting}

La fonction \texttt{merge()} de \texttt{pandas} nécessite de préciser la table de gauche (que l'on appellera ici \texttt{x}) via le paramètre \texttt{left} sur qui viendra s'effectuer la jointure de la table de droite (que l'on appellera ici \texttt{y}) via le paramètre \texttt{right}.

Par défaut, la fonction \texttt{merge()} réalise une jointure de type \texttt{inner}, c'est-à-dire que toutes les toutes les lignes de \texttt{x} qui trouvent une correspondance dans \texttt{y}, et toutes les colonnes de \texttt{x} et \texttt{y} seront dans le résultat de la jointure :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2     USA  2015   2827.336251   2217.733347
## 3     USA  2016   2863.264745   2210.442218
\end{lstlisting}

Si on désire changer le type de jointure, on peut modifier la valeur du paramètre \texttt{how} de la fonction \texttt{merge()}, pour lui donner une des valeurs suivantes :

\begin{itemize}
\tightlist
\item
  \texttt{left} : toutes les lignes de \texttt{x}, et toutes les colonnes de \texttt{x} et \texttt{y}. Les lignes dans \texttt{x} pour lesquelles il n'y a pas de correspondance dans \texttt{y} auront des valeurs \texttt{NaN} dans les
  nouvelles colonnes. S'il y a plusieurs correspondances dans les noms entre \texttt{x} et \texttt{y}, toutes
  les combinaisons sont retournées ;
\item
  \texttt{inner} : toutes les lignes de \texttt{x} pour lesquelles il y a des valeurs correspondantes dans \texttt{y}, et toutes les colonnes de \texttt{x} et \texttt{y}. S'il y a plusieurs correspondances dans les noms
  entre \texttt{x} et \texttt{y}, toutes les combinaisons possibles sont retournées ;
\item
  \texttt{right} : toutes les lignes de \texttt{y}, et toutes les colonnes de \texttt{y} et \texttt{x}. Les lignes dans
  \texttt{y} pour lesquelles il n'y a pas de correspondance dans \texttt{x} auront des valeurs \texttt{NaN} dans les
  nouvelles colonnes. S'il y a plusieurs correspondances dans les noms entre \texttt{y} et \texttt{x}, toutes
  les combinaisons sont retournées ;
\item
  \texttt{outer}: toutes les lignes de \texttt{x} et de \texttt{y}, et toutes les colonnes de \texttt{x} et \texttt{y}. Les lignes de \texttt{x} pour lesquelles il n'y a pas de correspondance dabs \texttt{y} et celles de \texttt{y} pour lesquelles il n'y a pas de correspondance dans \texttt{x} auront des valeurs \texttt{NaN}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"left : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations, how}\OperatorTok{=}\StringTok{"left"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## left : 
##    country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2  France  2017    973.876215           NaN
## 3     USA  2015   2827.336251   2217.733347
## 4     USA  2016   2863.264745   2210.442218
## 5     USA  2017           NaN           NaN
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{right : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations, how}\OperatorTok{=}\StringTok{"right"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## right : 
##    country  year  importations  exportations
## 0  France  2014           NaN    816.819217
## 1  France  2015    898.524296    851.663257
## 2  France  2016    936.369117    867.401425
## 3     USA  2014           NaN   2208.678084
## 4     USA  2015   2827.336251   2217.733347
## 5     USA  2016   2863.264745   2210.442218
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{outer : }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations, how}\OperatorTok{=}\StringTok{"outer"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## 
## outer : 
##    country  year  importations  exportations
## 0  France  2014           NaN    816.819217
## 1  France  2015    898.524296    851.663257
## 2  France  2016    936.369117    867.401425
## 3  France  2017    973.876215           NaN
## 4     USA  2014           NaN   2208.678084
## 5     USA  2015   2827.336251   2217.733347
## 6     USA  2016   2863.264745   2210.442218
## 7     USA  2017           NaN           NaN
\end{lstlisting}

Le paramètre \texttt{on}, qui attend un nom de colonne ou une liste de noms sert à désigner les colonnes permettant de faire la jointure. Les noms de colonnes doivent être identiques dans les deux dataframes.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations, on }\OperatorTok{=} \StringTok{"country"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##    country  year_x  importations  year_y  exportations
## 0   France    2015    898.524296    2014    816.819217
## 1   France    2015    898.524296    2015    851.663257
## 2   France    2015    898.524296    2016    867.401425
## 3   France    2016    936.369117    2014    816.819217
## 4   France    2016    936.369117    2015    851.663257
## 5   France    2016    936.369117    2016    867.401425
## 6   France    2017    973.876215    2014    816.819217
## 7   France    2017    973.876215    2015    851.663257
## 8   France    2017    973.876215    2016    867.401425
## 9      USA    2015   2827.336251    2014   2208.678084
## 10     USA    2015   2827.336251    2015   2217.733347
## 11     USA    2015   2827.336251    2016   2210.442218
## 12     USA    2016   2863.264745    2014   2208.678084
## 13     USA    2016   2863.264745    2015   2217.733347
## 14     USA    2016   2863.264745    2016   2210.442218
## 15     USA    2017           NaN    2014   2208.678084
## 16     USA    2017           NaN    2015   2217.733347
## 17     USA    2017           NaN    2016   2210.442218
\end{lstlisting}

Si le nom des colonnes devant servir à réaliser la jointure sont différents entre le dataframe de gauche et celui de droite, on indique au paramètre \texttt{left\_on} le ou les noms de colonnes du dataframe de gauche à utiliser pour la jointure ; et au paramètre \texttt{right\_on}, le ou les noms correspondants dans le dataframe de doite :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.merge(left }\OperatorTok{=}\NormalTok{ importations\_maroc, right }\OperatorTok{=}\NormalTok{ exportations\_maroc,}
\NormalTok{         left\_on}\OperatorTok{=}\NormalTok{ [}\StringTok{"pays"}\NormalTok{, }\StringTok{"annee"}\NormalTok{], right\_on }\OperatorTok{=}\NormalTok{ [}\StringTok{"country"}\NormalTok{, }\StringTok{"year"}\NormalTok{] )}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##     pays  annee  importations country  year  exportations
## 0  Maroc   2015     46.398842   Maroc  2015     37.459967
## 1  Maroc   2016     53.523756   Maroc  2016     39.382284
\end{lstlisting}

Avec le paramètre \texttt{suffixes}, on peut définir des suffixes à ajouter aux noms des colonnes lorsqu'il existe des colonnes dans \texttt{x} et dans \texttt{y} portant le même nom mais ne servant pas à la jointure. Par défaut, les suffixes (\texttt{\_x} et \texttt{\_y}) sont rajoutés.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.merge(left }\OperatorTok{=}\NormalTok{ importations, right }\OperatorTok{=}\NormalTok{ exportations,}
\NormalTok{               on }\OperatorTok{=} \StringTok{"country"}\NormalTok{,}
\NormalTok{               suffixes}\OperatorTok{=}\NormalTok{(}\StringTok{"\_gauche"}\NormalTok{, }\StringTok{"\_droite"}\NormalTok{)).head(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##   country  year_gauche  importations  year_droite  exportations
## 0  France         2015    898.524296         2014    816.819217
## 1  France         2015    898.524296         2015    851.663257
## 2  France         2015    898.524296         2016    867.401425
\end{lstlisting}

\section{Agrégation}\label{agruxe9gation}

Il arrive de vouloir agréger les valeurs d'une variable, pour passer par exemple d'une dimension
trimestrielle à annuelle. Avec des observations spatiales, cela peut aussi être le cas, comme
par exemple lorsque l'on dispose de données à l'échelle des départements et que l'on souhaite
connaître les valeurs agrégées à l'échelle des régions.

Pour illustrer les différentes opérations d'agrégation, créons un dataframe avec des des données de chômage dans différentes régions, départements et années :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"region"}\NormalTok{ : ([}\StringTok{"Bretagne"}\NormalTok{]}\OperatorTok{*}\DecValTok{4} \OperatorTok{+}\NormalTok{ [}\StringTok{"Corse"}\NormalTok{]}\OperatorTok{*}\DecValTok{2}\NormalTok{)}\OperatorTok{*}\DecValTok{2}\NormalTok{,}
     \StringTok{"departement"}\NormalTok{ : [}\StringTok{"Cotes{-}d\textquotesingle{}Armor"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{,}
                      \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{,}
                      \StringTok{"Corse{-}du{-}Sud"}\NormalTok{, }\StringTok{"Haute{-}Corse"}\NormalTok{]}\OperatorTok{*}\DecValTok{2}\NormalTok{,}
     \StringTok{"annee"}\NormalTok{ : np.repeat([}\DecValTok{2011}\NormalTok{, }\DecValTok{2010}\NormalTok{], }\DecValTok{6}\NormalTok{),}
     \StringTok{"ouvriers"}\NormalTok{ : [}\DecValTok{8738}\NormalTok{, }\DecValTok{12701}\NormalTok{, }\DecValTok{11390}\NormalTok{, }\DecValTok{10228}\NormalTok{, }\DecValTok{975}\NormalTok{, }\DecValTok{1297}\NormalTok{,}
                   \DecValTok{8113}\NormalTok{, }\DecValTok{12258}\NormalTok{, }\DecValTok{10897}\NormalTok{, }\DecValTok{9617}\NormalTok{, }\DecValTok{936}\NormalTok{, }\DecValTok{1220}\NormalTok{],}
     \StringTok{"ingenieurs"}\NormalTok{ : [}\DecValTok{1420}\NormalTok{, }\DecValTok{2530}\NormalTok{, }\DecValTok{3986}\NormalTok{, }\DecValTok{2025}\NormalTok{, }\DecValTok{259}\NormalTok{, }\DecValTok{254}\NormalTok{,}
                     \DecValTok{1334}\NormalTok{, }\DecValTok{2401}\NormalTok{, }\DecValTok{3776}\NormalTok{, }\DecValTok{1979}\NormalTok{, }\DecValTok{253}\NormalTok{, }\DecValTok{241}\NormalTok{]}
\NormalTok{    \})}
\BuiltInTok{print}\NormalTok{(chomage)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d'Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d'Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241
\end{lstlisting}

Comme nous l'avons vu précédemment (c.f. Section~\ref{pandas-statistiques-df}), on peut utiliser des méthodes permettant de calculer des statistiques simples sur l'ensemble des données. Par exemple, pour afficher la moyenne de chacune des colonnes numériques :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(chomage.mean(numeric\_only}\OperatorTok{=}\VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## annee         2010.500000
## ouvriers      7364.166667
## ingenieurs    1704.833333
## dtype: float64
\end{lstlisting}

Ce qui nous intéresse dans cette section, est d'effectuer des calculs sur des sous-groupes de données. Le principe est simple : dans un premier temps, on sépare les données en fonction de groupes identifiés (\emph{split}), puis on applique une opération sur chacun des groupes (\emph{apply}), et enfin on rassemble les résultats (\emph{combine}). Pour effectuer le regroupement, en fonction de facteurs avant d'effectuer les calculs d'agrégation, \texttt{pandas} propose la méthode \texttt{groupby()}. On lui fournit en paramètre le ou les noms de colonnes servant à effectuer les groupes.

\subsection{Agrégation selon les valeurs d'une seule colonne}\label{agruxe9gation-selon-les-valeurs-dune-seule-colonne}

Par exemple, admettons que nous souhaitons obtenir le nombre total de chomeurs ouvriers par année. Dans un premier temps, on utilise la méthode \texttt{groupby()} sur notre dataframe en indiquant que les groupes doivent être créés selon les valeurs de la colonne \texttt{annee}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(chomage.groupby(}\StringTok{"annee"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <pandas.core.groupby.generic.DataFrameGroupBy object at 0x15cdbca00>
\end{lstlisting}

Ensuite, on récupère la variable \texttt{ouvriers} :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(chomage.groupby(}\StringTok{"annee"}\NormalTok{).annee)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <pandas.core.groupby.generic.SeriesGroupBy object at 0x15d241580>
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ou bien}
\BuiltInTok{print}\NormalTok{(chomage.groupby(}\StringTok{"annee"}\NormalTok{)[}\StringTok{"annee"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## <pandas.core.groupby.generic.SeriesGroupBy object at 0x15d288d90>
\end{lstlisting}

Et enfin, on peut effectuer le calcul sur chaque sous-groupe et afficher le résultat :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(chomage.groupby(}\StringTok{"annee"}\NormalTok{)[}\StringTok{"ouvriers"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## annee
## 2010    43041
## 2011    45329
## Name: ouvriers, dtype: int64
\end{lstlisting}

Si on veut effectuer ce calcul pour plusieurs colonnes, par exemple \texttt{ouvriers} et \texttt{ingenieurs}, il suffit de sélectionner \emph{a priori} la variale de regroupement et les variables pour lesquelles on désire effectuer le calcul :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage.loc[:,[}\StringTok{"annee"}\NormalTok{, }\StringTok{"ouvriers"}\NormalTok{, }\StringTok{"ingenieurs"}\NormalTok{]].groupby(}\StringTok{"annee"}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##        ouvriers  ingenieurs
## annee                      
## 2010      43041        9984
## 2011      45329       10474
\end{lstlisting}

\subsection{Agrégation selon les valeurs de plusieurs colonnes}\label{agruxe9gation-selon-les-valeurs-de-plusieurs-colonnes}

À présent, admettons que l'on souhaite effectuer une agrégation en fonction de l'année et de la région. Il s'agit simplement de donner une liste contenant les noms des colonnes utilisées pour créer les différents groupes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage.loc[:,[}\StringTok{"annee"}\NormalTok{, }\StringTok{"region"}\NormalTok{,}
               \StringTok{"ouvriers"}\NormalTok{, }\StringTok{"ingenieurs"}\NormalTok{]].groupby([}\StringTok{"annee"}\NormalTok{,}
                                                   \StringTok{"region"}\NormalTok{]).}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##                 ouvriers  ingenieurs
## annee region                        
## 2010  Bretagne     40885        9490
##       Corse         2156         494
## 2011  Bretagne     43057        9961
##       Corse         2272         513
\end{lstlisting}

\section{Stacking et unstacking}\label{stacking-et-unstacking}

À compléter un jour

\section{Exportation et importation de données}\label{exportation-et-importation-de-donnuxe9es}

\texttt{pandas} offre de nombreuses fonctions pour importer et exporter des données dans différents formats.

\subsection{Exportation des données}\label{exportation-des-donnuxe9es}

\subsubsection{Exportation de données tabulaires}\label{exportation-de-donnuxe9es-tabulaires}

\paragraph{Vers un fichier CSV \{pandas-export\_csv\}}\label{vers-un-fichier-csv-pandas-export_csv}

Pour exporter des données tabulaires, comme celles contenues dans un dataframe, \texttt{NumPy} propose la méthode \texttt{to\_csv()}, qui accepte de nombreuses spécifications. Regardons quelques-unes d'entre-elles qui me semblent les plus courantes :

\begin{longtable}[]{@{}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2424}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7576}}@{}}
\caption{\label{tab:pandasto-csv} Paramètres principaux de la fonction \texttt{to\_csv}}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Paramètre
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedleft
Paramètre
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{path\_or\_buf} & chemin vers le fichier \\
\texttt{sep} & caractère de séparation des champs \\
\texttt{decimal} & Caractère à utiliser pour le séparateur de décimales \\
\texttt{na\_rep} & représentation à utiliser pour les valeurs manquantes \\
\texttt{header} & indique si le nom des colonnes doit être exporté (\texttt{True} par défaut) \\
\texttt{index} & indique si le nom des lignes doit être exporté (\texttt{True} par défaut) \\
\texttt{mode} & mode d'écriture python (c.f. Tableau~\ref{tab:open-mode-ouverture}, par défaut \texttt{w}) \\
\texttt{encoding} & encodage des caractères (\texttt{utf-8} par défaut) \\
\texttt{compression} & compression à utiliser pour le fichier de destination (\texttt{gzip}, \texttt{bz2}, \texttt{zip}, \texttt{xz}) \\
\texttt{line\_terminator} & caractère de fin de ligne \\
\texttt{quotechar} & Caractère utilisé pour mettre les champs entre \emph{quotes} \\
\texttt{chunksize} & (entier) nombre de lignes à écrire à la fois \\
\texttt{date\_format} & format de dates pour les objets \texttt{datetime} \\
\end{longtable}

Admettons que nous souhaitons exporter le contenu du dataframe \texttt{chomage} vers un fichier CSV dont les champs sont séparés par des points-virgules, et en n'exportant pas l'index :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chomage }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    \{}\StringTok{"region"}\NormalTok{ : ([}\StringTok{"Bretagne"}\NormalTok{]}\OperatorTok{*}\DecValTok{4} \OperatorTok{+}\NormalTok{ [}\StringTok{"Corse"}\NormalTok{]}\OperatorTok{*}\DecValTok{2}\NormalTok{)}\OperatorTok{*}\DecValTok{2}\NormalTok{,}
     \StringTok{"departement"}\NormalTok{ : [}\StringTok{"Cotes{-}d\textquotesingle{}Armor"}\NormalTok{, }\StringTok{"Finistere"}\NormalTok{,}
                      \StringTok{"Ille{-}et{-}Vilaine"}\NormalTok{, }\StringTok{"Morbihan"}\NormalTok{,}
                      \StringTok{"Corse{-}du{-}Sud"}\NormalTok{, }\StringTok{"Haute{-}Corse"}\NormalTok{]}\OperatorTok{*}\DecValTok{2}\NormalTok{,}
     \StringTok{"annee"}\NormalTok{ : np.repeat([}\DecValTok{2011}\NormalTok{, }\DecValTok{2010}\NormalTok{], }\DecValTok{6}\NormalTok{),}
     \StringTok{"ouvriers"}\NormalTok{ : [}\DecValTok{8738}\NormalTok{, }\DecValTok{12701}\NormalTok{, }\DecValTok{11390}\NormalTok{, }\DecValTok{10228}\NormalTok{, }\DecValTok{975}\NormalTok{, }\DecValTok{1297}\NormalTok{,}
                   \DecValTok{8113}\NormalTok{, }\DecValTok{12258}\NormalTok{, }\DecValTok{10897}\NormalTok{, }\DecValTok{9617}\NormalTok{, }\DecValTok{936}\NormalTok{, }\DecValTok{1220}\NormalTok{],}
     \StringTok{"ingenieurs"}\NormalTok{ : [}\DecValTok{1420}\NormalTok{, }\DecValTok{2530}\NormalTok{, }\DecValTok{3986}\NormalTok{, }\DecValTok{2025}\NormalTok{, }\DecValTok{259}\NormalTok{, }\DecValTok{254}\NormalTok{,}
                     \DecValTok{1334}\NormalTok{, }\DecValTok{2401}\NormalTok{, }\DecValTok{3776}\NormalTok{, }\DecValTok{1979}\NormalTok{, }\DecValTok{253}\NormalTok{, }\DecValTok{241}\NormalTok{]}
\NormalTok{    \})}
\BuiltInTok{print}\NormalTok{(chomage)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d'Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d'Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241
\end{lstlisting}

Pour l'exportation :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.csv"}
\NormalTok{chomage.to\_csv(chemin, decimal}\OperatorTok{=}\StringTok{";"}\NormalTok{, index}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si on désire que le fichier CSV soit compressé dans un fichier \texttt{gzip}, on le nomme avec l'extention \texttt{.csv.gz} et on ajoute la valeur \texttt{gzip} au paramètre \texttt{compression} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.csv.gz"}
\NormalTok{chomage.to\_csv(chemin, decimal}\OperatorTok{=}\StringTok{";"}\NormalTok{, index}\OperatorTok{=}\VariableTok{False}\NormalTok{, compression}\OperatorTok{=}\StringTok{"gzip"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\paragraph{Vers un fichier HDF5}\label{vers-un-fichier-hdf5}

Pour enregistrer les données d'un dataframe dans un fichier HDF5 utilisant HDFStore, \texttt{pandas} propose la méthode \texttt{to\_hdf()} qui fonctionne de manière similaire à la fonction \texttt{to\_csv()} (cf.~Section~@ref(pandas-export\_csv)). Make sure to install the module \texttt{tables} first (\texttt{pip\ install\ tables}).

Il est nécessaire de spécifier le paramètre \texttt{path\_or\_buf} pour indiquer le chemin et le paramètre \texttt{key} pour identifier l'objet à enregistrer dans le fichier.

La syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.h5"}
\NormalTok{chomage.to\_hdf(chemin, key}\OperatorTok{=}\StringTok{"base\_chomage"}\NormalTok{, index}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ValueError: numpy.dtype size changed, may indicate binary incompatibility. Expected 96 from C header, got 88 from PyObject
\end{lstlisting}

\section{Importation des données}\label{importation-des-donnuxe9es}

\texttt{pandas} propose de nombreuses fonctions pour importer des données. Dans cette version des notes de cours, nous allons en aborder 3 : \texttt{read\_csv()}, pour lire des fichiers CSV ; \texttt{read\_excel()}, pour lire des fichiers Excel ; et \texttt{read\_hdf()} pour lire des fichiers HDF5.

Dans la prochaine version, des ajouts sur \texttt{read\_html()}, \texttt{read\_fwf()}, \texttt{read\_stata()}, \texttt{read\_json()}.

\subsection{Fichiers CSV}\label{pandas-importation-csv}

Pour importer des données depuis un fichier CSV, \texttt{pandas} propose la fonction \texttt{read\_csv()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.csv"}
\NormalTok{chomage }\OperatorTok{=}\NormalTok{ pd.read\_csv(chemin, decimal}\OperatorTok{=}\StringTok{";"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il est possible de fournir une URL pointant vers un fichier CSV comme chemin, la fonction \texttt{read\_csv()}.

Parmi les paramètres que l'on utilise fréquemment :

\begin{itemize}
\tightlist
\item
  \texttt{sep}, \texttt{delimiter} : séparateur de champs ;
\item
  \texttt{decimal} : séparateur de décimales ;
\item
  \texttt{header} : numéro(s) de ligne(s) à utiliser comme en-tête des données ;
\item
  \texttt{skiprows} : numéro(s) de ligne(s) à sauter au début ;
\item
  \texttt{skipfooter} : numéro(s) de ligne(s) à sauter à la fin ;
\item
  \texttt{nrows} : nombre de ligne à lire ;
\item
  \texttt{na\_values} : chaînes de caractères supplémentaires à considérer comme valeurs manquantes (en plus de \texttt{\#N/A}, \texttt{\#N/A\ N/A}, \texttt{\#NA}, \texttt{-1.\#IND}, \texttt{-1.\#QNAN}, \texttt{-NaN}, \texttt{-nan}, \texttt{1.\#IND}, \texttt{1.\#QNAN}, \texttt{N/A}, \texttt{NA}, \texttt{NULL}, \texttt{NaN}, \texttt{n/a}, \texttt{nan}, \texttt{null}) ;
\item
  \texttt{quotechar} : caractère de \emph{quote} ;
\item
  \texttt{encoding} : encodage des caractères (défaut \texttt{utf-8}).
\end{itemize}

\subsection{Fichiers Excel}\label{pandas-importation-excel}

Pour importer des fichiers Excel, \texttt{pandas} propose la fonction \texttt{read\_excel()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.xlsx"}
\NormalTok{chomage }\OperatorTok{=}\NormalTok{ pd.read\_excel(chemin, skiprows}\OperatorTok{=}\DecValTok{2}\NormalTok{, header}\OperatorTok{=}\DecValTok{1}\NormalTok{, sheet\_name }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ImportError: Missing optional dependency 'openpyxl'.  Use pip or conda to install openpyxl.
\end{lstlisting}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(chomage)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d'Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d'Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241
\end{lstlisting}

Parmi les paramètres fréquemment utilisés :

\begin{itemize}
\tightlist
\item
  \texttt{header} : numéro de ligne à utiliser comme en-tête ;
\item
  \texttt{sheet} : nom ou numéro de feuille (attention à l'index qui commence à 0) ;
\item
  \texttt{skiprows} : nombre de lignes à sauter au début ;
\item
  \texttt{thousands} : séparateur de milliers.
\end{itemize}

\subsection{Fichiers HDF5}\label{pandas-importation-hdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chemin }\OperatorTok{=} \StringTok{"./fichiers\_exemples/chomage.h5"}
\BuiltInTok{print}\NormalTok{(pd.read\_hdf(chemin, }\StringTok{"base\_chomage"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ValueError: numpy.dtype size changed, may indicate binary incompatibility. Expected 96 from C header, got 88 from PyObject
\end{lstlisting}

\section{Exercice}\label{exercice-8}

\begin{exframe}
\textbf{Exercice 1 : Importation et exportation}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Télécharger à la main le fichier csv à l'adresse suivante : \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.csv} et le placer dans le répertoire courant. Importer son contenu dans Python.
\item
  Importer à nouveau les données dans Python, mais en fournissant cette fois le l'url directement à la fonction d'importation.
\item
  À présent, importer le contenu du fichier disponible à l'adresse \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_decim.csv}. Le séparateur de champs est un point virgule
  et le séparateur décimal est une virgule.
\item
  Importer le contenu du fichier \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h.csv}. Le nom des colonnes n'est pas présent.
\item
  Importer le contenu du fichier \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h_s.csv}. La première ligne n'est pas à importer.
\item
  Importer le contenu de la première feuille du fichier Excel \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx}.
\item
  Importer le contenu de la seconde feuille (\texttt{notes\_h\_s}) du fichier Excel disponible ici : \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx}. La première ligne est un commentaire à ne pas considérer durant l'importaiton.
\item
  Exporter le contenu de l'objet contenant les notes de la question précédente au format csv (virgule
  en séparateur de champs, point en séparateur décimal, ne pas conserver le numéro des
  lignes).
\end{enumerate}

\textbf{Exercice 2 : Manipulation de tableaux de données}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  À l'aide de la fonction \texttt{read\_excel()} de la librairie \texttt{pandas}, importer le contenu de la feuille intitulée \texttt{notes\_2012} du fichier Excel disponible à l'adresse suivante : \url{http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_etudiants.xlsx} et le stocker dans une variable que l'on nommera notes\_2012.
\item
  Afficher les 6 premières lignes du jeu de données, puis les dimensions du tableau.
\item
  Conserver uniquement la colonne \texttt{note\_stat} du tableau de données \texttt{notes\_2012} dans un objet que l'on appellera \texttt{tmp}.
\item
  Conserver uniquement les colonnes \texttt{num\_etudiant}, \texttt{note\_stat} et \texttt{note\_macro} dans un objet nommé \texttt{tmp}.
\item
  Remplacer le contenu de \texttt{tmp} par les observations de \texttt{notes\_2012} pour lesquelles l'individu a obtenu une note de stat supérieure (strictement) à 10.
\item
  Remplacer le contenu de tmp par les observations de \texttt{notes\_2012} pour lesquelles l'individu a obtenu une note de stats comprise dans l'intervalle (10, 15).
\item
  Regarder s'il y a des doublons dans le tableau de données \texttt{notees\_2012} ; le cas échéant, les retirer du tableau.
\item
  Afficher le type des données de la colonne \texttt{num\_etudiant}, puis afficher le type de toutes les colonnes de notes\_2012.
\item
  Ajouter au tableau \texttt{notes\_2012} les colonnes suivantes :
\end{enumerate}

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\tightlist
\item
  \texttt{note\_stat\_maj} : la note de stat (\texttt{note\_stat}) majorée d'un point,
\item
  \texttt{note\_macro\_maj} : la note de macro (\texttt{note\_macro}) majorée de trois points (le faire en deux étapes : d'abord deux points en plus, puis un point).
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\tightlist
\item
  Renommer la colonne year en annee.
\item
  Depuis le fichier \texttt{notes\_etudiants.xlsx} (c.f. question 1), importer le contenu des feuilles \texttt{notes\_2013}, \texttt{notes\_2014} et \texttt{prenoms} et le stocker dans les objets \texttt{notes\_2013}, \texttt{notes\_2014} et \texttt{prenoms}, respectivement.
\item
  Empiler le contenu des tableaux de données \texttt{notes\_2012}, \texttt{notes\_2013} et \texttt{notes\_2014} dans un objet que l'on nommera \texttt{notes}.
\item
  Fusionner les tableaux \texttt{notes} et \texttt{prenoms} à l'aide d'une jointure gauche, de manière à rajouter les informations contenues dans le tableau prenoms aux observations de notes. La jointure doit se faire par le numéro d'étudiant et l'année, l'objet final viendra remplacer le contenu de notes.
\item
  Trier le tableau notes par années croissantes et notes de macro décroissantes.
\item
  Créer une colonne \texttt{apres\_2012} qui prend la valeur \texttt{True} si l'observation concerne une note attribuée après 2012.
\item
  En effectuant des regroupements sur le dataframe \texttt{notes} calculer :
\end{enumerate}

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\tightlist
\item
  la moyenne et l'écart-type annuels des notes pour chacune des deux matières,
\item
  la moyenne et l'écart-type annuels et par sexe des notes pour chacune des deux matières.
\end{enumerate}
\end{exframe}

\chapter{Visualisation de données}\label{visualisation-de-donnuxe9es}

Dans ce chapitre, nous allons explorer les rudiments de la visualisation de données avec la librairie \texttt{Matplotlib}.

Pour le moment, ces notes ne parleront pas des graphiques dynamiques que l'on peut réaliser en lien avec des librairies JavaScript, comme D3.js. Dans une prochaine version également, nous verrons comment réaliser des graphiques avec \texttt{seaborn} (\url{https://seaborn.pydata.org/}).

Pour avoir accès rapidement à un type de graphique que l'on souhaite réaliser, on peut se référencer à cette excellente gallerie : \url{https://python-graph-gallery.com/}.

Les adeptes du logiciel et langage de programmation R seront heureux de pouvoir retrouver une grammaire graphique comme celle proposée par le \href{https://ggplot2.tidyverse.org/}{\emph{package} R \texttt{ggplot2}} introduit par Hadley Wickham. En effet, il existe une librairie Python nommée \texttt{ggplot} : \url{http://ggplot.yhathq.com/}.

Pour explorer graphiquement ses données, il peut être intéressant d'investir un peu de temps dans la librairie \texttt{Altair} (\url{https://altair-viz.github.io/}). Pour une introduction en vidéo : \url{https://www.youtube.com/watch?v=aRxahWy-ul8}.

\section{Graphiques avec matplotlib}\label{graphiques-avec-matplotlib}

Pour utiliser les fonctionnalités offertes par \texttt{matplotlib} (\url{https://matplotlib.org/}), il est nécessaire de charger certains modules. Le plus commun est le sous-module \texttt{pyplot}, auquel on attribue fréquemment l'alias \texttt{plt} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\end{Highlighting}
\end{Shaded}

Pour réaliser un graphique avec la fonction \texttt{pyplot}, on commence par créer une figure en définissant sa zone, puis on ajoute et / ou modifie ses éléments à l'aide de fonctions offertes par \texttt{pyplot}.

Pour illustrer les fonctionnalités de \texttt{matplotlib}, nous allons avoir besoin de générer des valeurs, à l'aide de la librairie \texttt{numpy}, que l'on charge :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

\subsection{Géométries}\label{guxe9omuxe9tries}

\subsubsection{Lignes}\label{matplotlib-plot}

Pour tracer des lignes sur un repère cartésien, on utilise la fonction \texttt{plot()}, à qui on fournit les coordonnées en abscisses et en ordonnées en premiers paramètres. On définit avec le troisième paramètre la géométrie.

Par défaut, la géométrie réalisée est une courbe bleue :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.plot(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_1} \end{center}

Une fois le graphique affiché, on peut le refermer avec la fonction \texttt{close()} :

De la même manière, on peut préciser la gémoétrie comme suit :

Pour ajouter une courbe sur le graphique, on fait appel plusieurs fois à la fonction \texttt{plot()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_2 }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.plot(x, y, }\StringTok{"{-}"}\NormalTok{)}
\NormalTok{plt.plot(x, y\_2, }\StringTok{"{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_2_courbes} \end{center}

\paragraph{Paramètres esthétiques}\label{paramuxe8tres-esthuxe9tiques}

\subparagraph{Couleur de lignes}\label{couleur-de-lignes}

Pour modifier la couleur d'une ligne, on utilise le paramètre \texttt{color} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{"red"}\NormalTok{)}
\NormalTok{plt.plot(x, y\_2, color}\OperatorTok{=}\StringTok{"\#00FF00"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_couleur} \end{center}

Commme on peut le constater, la référence à la couleur peut se faire en faisant appel à son nom (la liste des couleurs disposant d'un nom est accessibles sur la \href{https://matplotlib.org/examples/color/named_colors.html}{documentation de matplotlib}). On peut aussi utiliser un code hexadécimal pour faire référence à une couleur.

\begin{remarque}
Il peut être intéressant, lorsque l'on choisit des couleurs, de penser à l'utilisation ensuite : est-ce pour l'écran ? Pour l'impression en niveaux de gris ? On peut également se demander si le choix effectué ne gênera pas la compréhension pour les daltoniens (qui sont environ 4\% en France). Le site web \href{http://colorbrewer2.org/}{Color Brewer} propose des choix de couleurs en fonctions de caractéristiques souhaitées comme celles mentionnées.
\end{remarque}

\subparagraph{Épaisseur des lignes}\label{uxe9paisseur-des-lignes}

L'apaisseur des lignes peut être modifiée à l'aide du paramètre \texttt{linewidth}, à qui l'on fournit une valeur numérique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_epaisseur} \end{center}

\subparagraph{Type de lignes}\label{type-de-lignes}

Pour changer de type de ligne, on modifie le troisième paramètre de la fonction. On l'a vu, par défaut, une ligne est tracée, ce qui revient à indiquer comme troisième paramètre : \texttt{\textquotesingle{}-\textquotesingle{}}. Le Tableau~\ref{tab:fmt-lignes} indique les différents format possibles pour la ligne.

\begin{longtable}[]{@{}rr@{}}
\caption{\label{tab:fmt-lignes} Formats des lignes}\tabularnewline
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-} & Ligne pleine \\
\texttt{-\/-} & Tirets \\
\texttt{-.} & Points et tirets \\
\texttt{:} & Pointillés \\
\end{longtable}

Par exemple, pour avoir une interpolation linéraire effectuée entre nos points avec une représentation graphique effectuée à l'aide de tirets :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, }\StringTok{"{-}{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_tirets} \end{center}

On peut aussi spécifier le type de ligne à l'aide du paramètre \texttt{linestyle}, en lui indiquant une des valeurs renseignées dans le Tableau~\ref{tab:fmt-lignes-2}

\begin{longtable}[]{@{}rr@{}}
\caption{\label{tab:fmt-lignes-2} Formats des lignes via le paramètre \texttt{linestyle}}\tabularnewline
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-} ou \texttt{solid} & Ligne pleine \\
\texttt{-\/-} ou \texttt{dashed} & Tirets \\
\texttt{-.} ou \texttt{dashdot} & Points et tirets \\
\texttt{:} ou \texttt{dotted} & Pointillés \\
\texttt{None} & Aucune ligne de tracée \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, linestyle}\OperatorTok{=}\StringTok{"dashed"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_linestyle} \end{center}

\subparagraph{Marqueurs}\label{marqueurs}

Le Tableau~\ref{tab:fmt-lignes-marqueurs} indique quant à lui des formats que l'on peut spécifier comme marqueurs à chaque point présent sur la courbe.

\begin{longtable}[]{@{}rr@{}}
\caption{\label{tab:fmt-lignes-marqueurs} Formats des lignes}\tabularnewline
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Valeur & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{.} & Points \\
\texttt{,} & Pixels \\
\texttt{o} & Cercles vides \\
\texttt{v} & Triangles pointant vers le bas \\
\texttt{\^{}} & Triangles pointant vers le haut \\
\texttt{\textless{}} & Triangles pointant vers la gauche \\
\texttt{\textgreater{}} & Triangles pointant vers la droite \\
\texttt{1} & `tri\_down' \\
\texttt{2} & `tri\_up' \\
\texttt{3} & `tri\_left' \\
\texttt{4} & `tri\_right' \\
\texttt{s} & Carré \\
\texttt{p} & Pentagone \\
\texttt{*} & Astérisque \\
\texttt{h} & Hexagone 1 \\
\texttt{H} & Hexagone 2 \\
\texttt{+} & Symbole plus \\
\texttt{x} & Symbole multiplier \\
\texttt{D} & Losange \\
\texttt{d} & Losange fin \\
\texttt{\textbar{}} & Ligne verticale \\
\texttt{\_} & Ligne horizontale \\
\end{longtable}

Par exemple, avec des cercles vides :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, }\StringTok{"o"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_cercles} \end{center}

On peut noter qu'il est possible de combiner les types de lignesdu Tableau~\ref{tab:fmt-lignes} avec des types de marqueurs du Tableau~\ref{tab:fmt-lignes-marqueurs} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, }\StringTok{"{-}{-}v"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_tirets_triangles} \end{center}

Pour contrôler de manière plus précise les marqueurs, on peut utiliser les paramètres suivants :

\begin{itemize}
\tightlist
\item
  \texttt{marker} : renseigne le type de marqueur (c.f. Tableau~\ref{tab:fmt-lignes-marqueurs}) ;
\item
  \texttt{markerfacecolor} : la couleur désirée pour les marqueurs ;
\item
  \texttt{markersize} : taille des marqueurs.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, markerfacecolor }\OperatorTok{=} \StringTok{"red"}\NormalTok{, markersize }\OperatorTok{=} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/lignes_marqueurs} \end{center}

\subsubsection{Nuage de points}\label{nuage-de-points}

Un des graphiques que l'on rencontre très fréquemment est le nuage de points. Pour en réaliser un, on peut faire appel à la fonction \texttt{scatter()}, à qui l'on indique les cordonnées (x,y) des points ainsi que quelques paramètres optionnels de forme ou d'esthétisme.

\begin{remarque}
\href{https://matplotlib.org/2.0.2/api/pyplot_api.html\#matplotlib.pyplot.scatter}{La documentation en ligne} de la fonction \texttt{scatter()} mentionne que la fonction \texttt{plot()} (c.f. Section~\ref{matplotlib-plot}) est plus rapide pour effectuer des nuages de points dans lesquels la couleur ou la taille des points de varie.
\end{remarque}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.scatter(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/scatter_1} \end{center}

Pour changer la forme des marqueurs, on l'indique via le paramètre \texttt{marker} (c.f. Tableau~\ref{tab:fmt-lignes-marqueurs} pour les valeurs possibles) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.scatter(x, y, marker}\OperatorTok{=}\StringTok{"+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/scatter_2} \end{center}

\subsubsection{Taille et couleur}\label{taille-et-couleur}

La taille des points est ajustable via le paramètre \texttt{s}, tandis que la couleur se modifie via le paramètre \texttt{color} (ou par son alias \texttt{c}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.scatter(x, y, marker}\OperatorTok{=}\StringTok{"+"}\NormalTok{, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{, s }\OperatorTok{=} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/scatter_3} \end{center}

On peut associer une couleur et une taille spécifiques à chaque point :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{30}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{30}\NormalTok{)}
\NormalTok{z }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{30}\NormalTok{)}
\NormalTok{couleurs }\OperatorTok{=}\NormalTok{ np.random.choice([}\StringTok{"blue"}\NormalTok{, }\StringTok{"black"}\NormalTok{, }\StringTok{"red"}\NormalTok{], }\DecValTok{30}\NormalTok{)}
\NormalTok{plt.scatter(x, y, marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, color }\OperatorTok{=}\NormalTok{ couleurs, s }\OperatorTok{=}\NormalTok{ z}\OperatorTok{*}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/scatter_bubble} \end{center}

\subsubsection{Histogrammes}\label{histogrammes}

Pour réaliser un histogramme avec \texttt{pyplot}, on utilise la fonction \texttt{hist()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.randn(}\DecValTok{1000}\NormalTok{)}
\NormalTok{plt.hist(x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/histogramme} \end{center}

On peut préciser avec le paramètre \texttt{bins} soit le nombre de classes, soit leurs bornes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(x, bins}\OperatorTok{=}\DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/histogramme_bins} \end{center}

Et avec les bornes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bins }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\FloatTok{.1}\NormalTok{)}
\NormalTok{plt.hist(x, bins}\OperatorTok{=}\NormalTok{bins)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/histogramme_bins_2} \end{center}

L'orientation se change via le paramètre \texttt{orientation}, en indiquant soit \texttt{\textquotesingle{}vertical\textquotesingle{}} (par dédaut), soit \texttt{\textquotesingle{}horizontal\textquotesingle{}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(x, orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/histogramme_orientation} \end{center}

\paragraph{Paramètres esthétiques}\label{paramuxe8tres-esthuxe9tiques-1}

Pour changer la couleur de remplissage, on utilise le paramètre \texttt{color} ; pour ajouter une couleur délimitant les barres, on utilise le paramètre \texttt{edgecolor} ; pour définir l'épaisseur du contour, on utilise le paramètre \texttt{linewidth} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.randn(}\DecValTok{1000}\NormalTok{)}
\NormalTok{plt.hist(x, color }\OperatorTok{=} \StringTok{"\#00FF00"}\NormalTok{, edgecolor}\OperatorTok{=}\StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth}\OperatorTok{=}\FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/histogramme_esthetiques} \end{center}

\subsubsection{Diagrammes en bâtons}\label{diagrammes-en-buxe2tons}

Pour réaliser des diagrammes en bâtons, \texttt{pyplot} propose la fonction \texttt{bar()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays }\OperatorTok{=}\NormalTok{ [}\StringTok{"France"}\NormalTok{, }\StringTok{"Italie"}\NormalTok{, }\StringTok{"Belgique"}\NormalTok{, }\StringTok{"Allemagne"}\NormalTok{]}
\NormalTok{chomage }\OperatorTok{=}\NormalTok{ [}\FloatTok{9.3}\NormalTok{, }\FloatTok{9.7}\NormalTok{, }\FloatTok{6.5}\NormalTok{, }\FloatTok{3.4}\NormalTok{]}
\NormalTok{plt.bar(pays, chomage)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/barplot} \end{center}

Pour un diagramme horizontal, on utilise la fonction \texttt{barh()} de la même manière :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.barh(pays, chomage)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/barplot_h} \end{center}

\paragraph{Plusieurs séries sur un diagramme en bâtons}\label{plusieurs-suxe9ries-sur-un-diagramme-en-buxe2tons}

Pour comparer plusieurs séries côte-à-côte, il est nécessaire d'emprunter des notions qui ne seront introduites qu'à la Section~\ref{pyplot-elements-graphiques} (le code est fourni ici plutôt comme un aide-mémoire pour effectuer ce genre de graphiques).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays }\OperatorTok{=}\NormalTok{ [}\StringTok{"France"}\NormalTok{, }\StringTok{"Italie"}\NormalTok{, }\StringTok{"Belgique"}\NormalTok{, }\StringTok{"Allemagne"}\NormalTok{]}
\NormalTok{chomage\_f }\OperatorTok{=}\NormalTok{ [}\FloatTok{9.1}\NormalTok{, }\FloatTok{11.2}\NormalTok{, }\FloatTok{6.4}\NormalTok{, }\FloatTok{2.9}\NormalTok{]}
\NormalTok{chomage\_h }\OperatorTok{=}\NormalTok{ [}\FloatTok{9.5}\NormalTok{, }\DecValTok{9}\NormalTok{, }\FloatTok{6.6}\NormalTok{, }\FloatTok{3.8}\NormalTok{]}
\CommentTok{\# Position sur l\textquotesingle{}axe des x pour chaque étiquette}
\NormalTok{position }\OperatorTok{=}\NormalTok{ np.arange(}\BuiltInTok{len}\NormalTok{(pays))}
\CommentTok{\# Largeur des barres}
\NormalTok{largeur }\OperatorTok{=} \FloatTok{.35}

\CommentTok{\# Création de la figure et d\textquotesingle{}un set de sous{-}graphiques}
\NormalTok{fig, ax }\OperatorTok{=}\NormalTok{ plt.subplots()}
\NormalTok{r1 }\OperatorTok{=}\NormalTok{ ax.bar(position }\OperatorTok{{-}}\NormalTok{ largeur}\OperatorTok{/}\DecValTok{2}\NormalTok{, chomage\_f, largeur)}
\NormalTok{r2 }\OperatorTok{=}\NormalTok{ ax.bar(position }\OperatorTok{+}\NormalTok{ largeur}\OperatorTok{/}\DecValTok{2}\NormalTok{, chomage\_h, largeur)}

\CommentTok{\# Modification des marques sur l\textquotesingle{}axe des x et de leurs étiquettes}
\NormalTok{ax.set\_xticks(position)}
\NormalTok{ax.set\_xticklabels(pays)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/barplot_mulltiples} \end{center}

\paragraph{Diagrammes en bâtons empilés}\label{diagrammes-en-buxe2tons-empiluxe9s}

Pour empiler les valeurs des séries, on préciser à l'aide du paramètre \texttt{bottom} la valeur de départ pour la série :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays }\OperatorTok{=}\NormalTok{ [}\StringTok{"France"}\NormalTok{, }\StringTok{"Italie"}\NormalTok{, }\StringTok{"Belgique"}\NormalTok{, }\StringTok{"Allemagne"}\NormalTok{]}
\NormalTok{nb\_chomeurs\_f }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.307}\NormalTok{, }\FloatTok{1.185}\NormalTok{, }\FloatTok{.577}\NormalTok{, }\FloatTok{.148}\NormalTok{]}
\NormalTok{nb\_chomeurs\_h }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.46}\NormalTok{, }\FloatTok{1.338}\NormalTok{, }\FloatTok{.878}\NormalTok{, }\FloatTok{.179}\NormalTok{]}

\NormalTok{plt.bar(pays, nb\_chomeurs\_f)}
\NormalTok{plt.bar(pays, nb\_chomeurs\_h, bottom }\OperatorTok{=}\NormalTok{ nb\_chomeurs\_f)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/barplot_stack} \end{center}

\paragraph{Paramètres esthetiques}\label{paramuxe8tres-esthetiques}

Pour changer la couleur de remplissage, on utilise le paramètre \texttt{color} ; pour la couleur du contour, on renseigne le paramètre \texttt{edgecolor} ; pour la largeur du contour, on s'appuie sur le paramètre \texttt{linewidth} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays }\OperatorTok{=}\NormalTok{ [}\StringTok{"France"}\NormalTok{, }\StringTok{"Italie"}\NormalTok{, }\StringTok{"Belgique"}\NormalTok{, }\StringTok{"Allemagne"}\NormalTok{]}
\NormalTok{nb\_chomeurs\_f }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.307}\NormalTok{, }\FloatTok{1.185}\NormalTok{, }\FloatTok{.577}\NormalTok{, }\FloatTok{.148}\NormalTok{]}
\NormalTok{nb\_chomeurs\_h }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.46}\NormalTok{, }\FloatTok{1.338}\NormalTok{, }\FloatTok{.878}\NormalTok{, }\FloatTok{.179}\NormalTok{]}

\NormalTok{plt.bar(pays, nb\_chomeurs\_f, color }\OperatorTok{=} \StringTok{"purple"}\NormalTok{,}
\NormalTok{        edgecolor }\OperatorTok{=} \StringTok{"black"}\NormalTok{, linewidth }\OperatorTok{=} \FloatTok{1.5}\NormalTok{)}
\NormalTok{plt.bar(pays, nb\_chomeurs\_h, bottom }\OperatorTok{=}\NormalTok{ nb\_chomeurs\_f)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/barplot_esthetiques} \end{center}

\subsubsection{Boxplots}\label{boxplots}

Pour réaliser une boîte à moustaches (ou \emph{boxplot}), \texttt{pyplot} offre la fonction \texttt{boxplot()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.randn(}\DecValTok{1000}\NormalTok{)}
\NormalTok{plt.boxplot(x)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'whiskers': [<matplotlib.lines.Line2D object at 0x15e873fd0>, <matplotlib.lines.Line2D object at 0x15e8afdf0>], 'caps': [<matplotlib.lines.Line2D object at 0x15e8af070>, <matplotlib.lines.Line2D object at 0x15e8af3d0>], 'boxes': [<matplotlib.lines.Line2D object at 0x15e873370>], 'medians': [<matplotlib.lines.Line2D object at 0x15e8afac0>], 'fliers': [<matplotlib.lines.Line2D object at 0x15e8aff10>], 'means': []}
\end{lstlisting}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/boxplot} \end{center}

En renseigant à \texttt{False} la valeur du paramètre \texttt{vert}, le boxplot est tracé horizontalement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.boxplot(x, vert }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'whiskers': [<matplotlib.lines.Line2D object at 0x15e833820>, <matplotlib.lines.Line2D object at 0x15e833e80>], 'caps': [<matplotlib.lines.Line2D object at 0x15e833a60>, <matplotlib.lines.Line2D object at 0x15e83afd0>], 'boxes': [<matplotlib.lines.Line2D object at 0x15e833a30>], 'medians': [<matplotlib.lines.Line2D object at 0x15e83a1f0>], 'fliers': [<matplotlib.lines.Line2D object at 0x15e83a310>], 'means': []}
\end{lstlisting}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/boxplot_horizontal} \end{center}

\subsection{Plusieurs graphiques sur une figure}\label{plusieurs-graphiques-sur-une-figure}

Pour placer des graphiques les uns à côté des autres, on utilise la fonction \texttt{subplot()}. Les graphiques seront placés comme dans une matrice, avec un nombre de lignes \texttt{n\_lignes} et un nombre de colonnes \texttt{n\_colones}. On peut indiquer les dimensions de cette matrice en paramètres de la fonction \texttt{subplot()}, à l'aide de la syntaxe suivante :

où \texttt{courant} indique l'indice du graphique actif. Voyons à travers un exemple le fonctionnement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{x}\OperatorTok{**}\DecValTok{2}
\CommentTok{\# Matrice de dimension 3x2 de graphiques}

\CommentTok{\# Ligne 1, colonne 1}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{)}

\CommentTok{\# Ligne 1, colonne 2}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"orange"}\NormalTok{)}

\CommentTok{\# Ligne 2, colonne 1}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"yellow"}\NormalTok{)}

\CommentTok{\# Ligne 2, colonne 2}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"green"}\NormalTok{)}

\CommentTok{\# Ligne 3, colonne 1}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"blue"}\NormalTok{)}

\CommentTok{\# Ligne 3, colonne 2}
\NormalTok{plt.subplot(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{plt.plot(x, y, color }\OperatorTok{=} \StringTok{"violet"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/subplot} \end{center}

Rappelons-nous que les matrices sont remplies lignes par lignes en Python, ce qui permet de bien comprendre la valeur du numéro de graphique actif.

En utilisant la fonction \texttt{subplots()} (attention au ``s'' final du nom de la fonction qui la différencie de la précédente), il est possible de produire une matrice de graphiques également, en procédant de la manière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f, ax\_arr }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"orange"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"yellow"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"green"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/subplots} \end{center}

Cette manière de procéder offre l'avantage de préciser facilement le partage d'axes entre les différents sous-graphiques, via les paramètres \texttt{sharex} et \texttt{sharey} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f, ax\_arr }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, sharey}\OperatorTok{=}\VariableTok{True}\NormalTok{, sharex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"orange"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"yellow"}\NormalTok{)}
\NormalTok{ax\_arr[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{].plot(x, y, color }\OperatorTok{=} \StringTok{"green"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/subplots_share} \end{center}

\subsection{Éléments de graphiques}\label{pyplot-elements-graphiques}

Jusqu'ici, nous avons regardé comment créer différentes géométries, mais nous n'avons pas touché aux axes, à leurs valeurs ou étiquettes (sauf lors de l'exemple non expliqué des diagrammes côte-à-côte), ou encore modifié les légendes ou titres.

\subsubsection{Titre}\label{titre}

Pour ajouter un titre au graphique, on peut utiliser la fonction title() :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{y\_2 }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{y}
\NormalTok{plt.plot(x, y)}
\NormalTok{plt.plot(x, y\_2)}
\NormalTok{plt.title(}\StringTok{"Représentation graphique de $y = x\^{}2$ }\CharTok{\textbackslash{}n}\StringTok{et de $y = {-}x\^{}2$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_titre} \end{center}

\subsubsection{Axes}\label{axes}

Les fonctions \texttt{xlabel()} et \texttt{ylabel()} permettent d'ajouter des étiquettes aux axes :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.plot(x, y)}
\NormalTok{plt.xlabel(}\StringTok{"Valeurs de $x$"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Valeurs de $y$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_axes_label} \end{center}

\paragraph{Limites}\label{limites}

Pour contrôler les limites des axes, on utilise la fonction \texttt{axis()}, en précisant les paramètres \texttt{xmin}, \texttt{xmax}, \texttt{ymax}, \texttt{ymin} et \texttt{ymax}, désignant, respectivement, les bornes inférieures et supérieures de l'axe des absisses et les borenes inférieures et supérieures de l'axe des ordonnées :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.axis(xmin }\OperatorTok{=} \DecValTok{0}\NormalTok{, xmax }\OperatorTok{=} \DecValTok{5}\NormalTok{, ymin }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, ymax }\OperatorTok{=} \DecValTok{30}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## (np.float64(0.0), np.float64(5.0), np.float64(-1.0), np.float64(30.0))
\end{lstlisting}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_axes_limites} \end{center}

\paragraph{Marques et étiquettes}\label{marques-et-uxe9tiquettes}

Les fonctions \texttt{xticks()} et \texttt{yticks()} permettent d'obtenir ou de modifier les marques de l'axe des abscisses et de l'axe des ordonnées, respectivement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.plot(x, y)}\OperatorTok{;}
\NormalTok{plt.xticks(np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, step }\OperatorTok{=} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_ticks} \end{center}

Il peut être pratique de récupérer les positions et les étiquettes d'un graphique pour pouvoir les modifier, par exemple pour définir l'espacement entre chaque marque :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}
\NormalTok{locs\_x, labels\_x }\OperatorTok{=}\NormalTok{ plt.xticks()}
\NormalTok{locs\_y, labels\_y }\OperatorTok{=}\NormalTok{ plt.yticks()}
\NormalTok{loc\_x\_new }\OperatorTok{=}\NormalTok{ np.arange(locs\_x[}\DecValTok{0}\NormalTok{], locs\_x[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], step }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\NormalTok{loc\_y\_new }\OperatorTok{=}\NormalTok{ np.arange(locs\_y[}\DecValTok{0}\NormalTok{], locs\_y[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], step }\OperatorTok{=} \DecValTok{10}\NormalTok{)}

\NormalTok{plt.xticks(loc\_x\_new)}\OperatorTok{;}
\NormalTok{plt.yticks(loc\_y\_new)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_ticks_2} \end{center}

On peut également modifier les étiquettes des marques :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}
\NormalTok{locs\_x, labels\_x }\OperatorTok{=}\NormalTok{ plt.xticks()}
\NormalTok{locs\_y, labels\_y }\OperatorTok{=}\NormalTok{ plt.yticks()}
\NormalTok{loc\_x\_new }\OperatorTok{=}\NormalTok{ np.arange(locs\_x[}\DecValTok{0}\NormalTok{], locs\_x[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], step }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\NormalTok{loc\_y\_new }\OperatorTok{=}\NormalTok{ np.arange(locs\_y[}\DecValTok{0}\NormalTok{], locs\_y[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], step }\OperatorTok{=} \DecValTok{10}\NormalTok{)}

\NormalTok{labels\_x\_new }\OperatorTok{=} \BuiltInTok{list}\NormalTok{()}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(locs\_x)):}
\NormalTok{        labels\_x\_new.append(}\StringTok{"x : "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(locs\_x[i]))}

\NormalTok{plt.xticks(loc\_x\_new, labels\_x\_new)}\OperatorTok{;}
\NormalTok{plt.yticks(loc\_y\_new)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## ValueError: The number of FixedLocator locations (5), usually from a call to set_ticks, does not match the number of labels (10).
\end{lstlisting}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_ticks_3} \end{center}

\paragraph{Grilles}\label{grilles}

Pour rajouter une grille, on utilise la fonction \texttt{grid()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.plot(x, y)}\OperatorTok{;}
\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_grid} \end{center}

Le paramètre \texttt{axis} permet de définir si l'on désire une grille pour les deux axes (\texttt{both}, par défaut), uniquement pour les abscisses (\texttt{x}), ou uniquement pour les ordonnées (\texttt{y}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}\OperatorTok{;}
\NormalTok{plt.grid(axis }\OperatorTok{=} \StringTok{"y"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_grid_y} \end{center}

On peut paraméter les lignes majeures ou mineurs de la grille :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}\OperatorTok{;}
\NormalTok{plt.minorticks\_on()}\OperatorTok{;}
\NormalTok{plt.grid(which }\OperatorTok{=} \StringTok{"major"}\NormalTok{, axis }\OperatorTok{=} \StringTok{"y"}\NormalTok{, color }\OperatorTok{=} \StringTok{"black"}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.grid(which }\OperatorTok{=} \StringTok{"minor"}\NormalTok{, axis }\OperatorTok{=} \StringTok{"y"}\NormalTok{, color }\OperatorTok{=} \StringTok{"red"}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{"{-}{-}"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_grid_minor} \end{center}

\subsubsection{Légendes}\label{luxe9gendes}

Lorsque l'on désire ajouter une légende, on précise l'étiquette de celle-ci au paramètre \texttt{label} dans l'appel de la fonction \texttt{plot}, puis on fait appel à la fonction \texttt{legend()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{y\_2 }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{3}
\NormalTok{plt.plot(x, y, label }\OperatorTok{=} \StringTok{"carré ($x\^{}2$)"}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.plot(x, y\_2, label }\OperatorTok{=} \StringTok{"cube ($x\^{}3$)"}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.legend()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_legende} \end{center}

Pour préciser la position de la légende, on peut s'appuyer sur le paramètre \texttt{loc} dans la fonction \texttt{legend()}, en indiquant une valeur telle que reportée dans le Tableau~\ref{tab:pyplot-legendes-loc}.

Chaîne \textbar{} Code \textbar{} Description \textbar{}\\
-----------: \textbar{} \textbar{} -----------: \textbar{} ------------------------------------------------:\textbar{}\\
\texttt{best} \textbar{} \texttt{0} \textbar{} Laisser Python optimiser le positonnement \textbar{}\\
\texttt{upper\ right} \textbar{} \texttt{1} \textbar{} En haut à droite \textbar{}\\
\texttt{upper\ left} \textbar{} \texttt{2} \textbar{} En haut à gauche \textbar{}\\
\texttt{lower\ left} \textbar{} \texttt{3} \textbar{} En bas à gauche \textbar{}\\
\texttt{lower\ right} \textbar{} \texttt{4} \textbar{} En bas à droite \textbar{}\\
\texttt{right} \textbar{} \texttt{5} \textbar{} À droite \textbar{}\\
\texttt{center\ left} \textbar{} \texttt{6} \textbar{} Centré au milieu à gauche \textbar{}\\
\texttt{center\ right} \textbar{} \texttt{7} \textbar{} Centré au milieu à droite \textbar{}\\
\texttt{lower\ center} \textbar{} \texttt{8} \textbar{} Centré en bas \textbar{}\\
\texttt{upper\ center} \textbar{} \texttt{9} \textbar{} Centré en haut \textbar{}\\
\texttt{center} \textbar{} \texttt{10} \textbar{} Centré \textbar{}

Table: \label{tab:pyplot-legendes-loc} Formats des lignes

Par exemple, pour centrer la légende au milieu, en bas du graphique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{y\_2 }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{3}
\NormalTok{plt.plot(x, y, label }\OperatorTok{=} \StringTok{"carré ($x\^{}2$)"}\NormalTok{)}
\NormalTok{plt.plot(x, y\_2, label }\OperatorTok{=} \StringTok{"cube ($x\^{}3$)"}\NormalTok{)}
\NormalTok{plt.legend(loc }\OperatorTok{=} \StringTok{"lower center"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=9.03in]{figs/pyplot/plot_legende_pos} \end{center}

\subsection{Dimensions}\label{dimensions-2}

Pour définir les dimensions d'une figure, on renseigne le paramètre \texttt{figsize} de la fonction \texttt{figure()}. On lui fournit un n-uplet d'entiers dont le premier élément correspond à la longueur et le second la hauteur (les valeurs sont en pouces) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{plt.figure(figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{6}\NormalTok{))}
\NormalTok{plt.plot(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=13.89in]{figs/pyplot/plot_size} \end{center}

\subsection{Enregistrement}\label{enregistrement}

Pour sauvegarder un grapgique, on peut utiliser la fonction \texttt{plt.savefig()}. On précise le chemin vers le fichier à créer, en indiquant l'extension du fichier désiré (\emph{e.g.}, \texttt{png} ou \texttt{pdf}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}
\NormalTok{y\_2 }\OperatorTok{=}\NormalTok{ x}\OperatorTok{**}\DecValTok{3}
\NormalTok{plt.figure(figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{6}\NormalTok{))}
\NormalTok{plt.plot(x, y, label }\OperatorTok{=} \StringTok{"carré ($x\^{}2$)"}\NormalTok{)}
\NormalTok{plt.plot(x, y\_2, label }\OperatorTok{=} \StringTok{"cube ($x\^{}3$)"}\NormalTok{)}
\NormalTok{plt.legend(loc }\OperatorTok{=} \StringTok{"lower center"}\NormalTok{)}
\NormalTok{plt.savefig(}\StringTok{"test.pdf"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

L'extension indiquée (dans l'exemple présent, \texttt{pdf}) détermine le format de fichier en sortie. On peut utiliser les extensions indiquées dans les clés du dictionnaire retourné par l'instruction suivante (les valeurs donnant une description du type de fichier) :

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(fig.canvas.get\_supported\_filetypes())}
\end{Highlighting}
\end{Shaded}

\begin{lstlisting}
## {'eps': 'Encapsulated Postscript', 'jpg': 'Joint Photographic Experts Group', 'jpeg': 'Joint Photographic Experts Group', 'pdf': 'Portable Document Format', 'pgf': 'PGF code for LaTeX', 'png': 'Portable Network Graphics', 'ps': 'Postscript', 'raw': 'Raw RGBA bitmap', 'rgba': 'Raw RGBA bitmap', 'svg': 'Scalable Vector Graphics', 'svgz': 'Scalable Vector Graphics', 'tif': 'Tagged Image File Format', 'tiff': 'Tagged Image File Format', 'webp': 'WebP Image Format'}
\end{lstlisting}

\section{Graphiques avec seaborn}\label{graphiques-avec-seaborn}

Cette section sera à compléter.

\url{https://seaborn.pydata.org/}

\chapter{References}\label{references}

\bibliography{biblio.bib}

\end{document}
