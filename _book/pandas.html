<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Python pour les économistes</title>
  <meta name="description" content="Python pour les économistes">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Python pour les économistes" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Python pour les économistes" />
  
  
  

<meta name="author" content="Ewen Gallic">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="numpy.html">
<link rel="next" href="visualisation-de-donnees.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="styles/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="propos-liminaires.html"><a href="propos-liminaires.html"><i class="fa fa-check"></i>Propos liminaires</a><ul>
<li class="chapter" data-level="0.1" data-path="propos-liminaires.html"><a href="propos-liminaires.html#objectifs"><i class="fa fa-check"></i><b>0.1</b> Objectifs</a></li>
<li class="chapter" data-level="0.2" data-path="propos-liminaires.html"><a href="propos-liminaires.html#a-qui-sadressent-ces-notes"><i class="fa fa-check"></i><b>0.2</b> À qui s’adressent ces notes ?</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="introduction.html"><a href="introduction.html#historique"><i class="fa fa-check"></i><b>1.1</b> Historique</a></li>
<li class="chapter" data-level="1.2" data-path="introduction.html"><a href="introduction.html#versions"><i class="fa fa-check"></i><b>1.2</b> Versions</a></li>
<li class="chapter" data-level="1.3" data-path="introduction.html"><a href="introduction.html#espace-de-travail"><i class="fa fa-check"></i><b>1.3</b> Espace de travail</a><ul>
<li class="chapter" data-level="1.3.1" data-path="introduction.html"><a href="introduction.html#python-dans-un-terminal"><i class="fa fa-check"></i><b>1.3.1</b> Python dans un terminal</a></li>
<li class="chapter" data-level="1.3.2" data-path="introduction.html"><a href="introduction.html#ipython"><i class="fa fa-check"></i><b>1.3.2</b> IPython</a></li>
<li class="chapter" data-level="1.3.3" data-path="introduction.html"><a href="introduction.html#spyder"><i class="fa fa-check"></i><b>1.3.3</b> Spyder</a></li>
<li class="chapter" data-level="1.3.4" data-path="introduction.html"><a href="introduction.html#jupyter"><i class="fa fa-check"></i><b>1.3.4</b> Jupyter</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="introduction.html"><a href="introduction.html#les-variables"><i class="fa fa-check"></i><b>1.4</b> Les variables</a><ul>
<li class="chapter" data-level="1.4.1" data-path="introduction.html"><a href="introduction.html#assignation-et-suppression"><i class="fa fa-check"></i><b>1.4.1</b> Assignation et suppression</a></li>
<li class="chapter" data-level="1.4.2" data-path="introduction.html"><a href="introduction.html#conventions-de-nommage"><i class="fa fa-check"></i><b>1.4.2</b> Conventions de nommage</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="introduction.html"><a href="introduction.html#les-commentaires"><i class="fa fa-check"></i><b>1.5</b> Les commentaires</a></li>
<li class="chapter" data-level="1.6" data-path="introduction.html"><a href="introduction.html#les-modules-et-les-packages"><i class="fa fa-check"></i><b>1.6</b> Les modules et les packages</a></li>
<li class="chapter" data-level="1.7" data-path="introduction.html"><a href="introduction.html#laide"><i class="fa fa-check"></i><b>1.7</b> L’aide</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="types-de-donnees.html"><a href="types-de-donnees.html"><i class="fa fa-check"></i><b>2</b> Types de données</a><ul>
<li class="chapter" data-level="2.1" data-path="types-de-donnees.html"><a href="types-de-donnees.html#chaines-de-caracteres"><i class="fa fa-check"></i><b>2.1</b> Chaînes de caractères</a><ul>
<li class="chapter" data-level="2.1.1" data-path="types-de-donnees.html"><a href="types-de-donnees.html#type-chaines-concatenation"><i class="fa fa-check"></i><b>2.1.1</b> Concaténation de chaînes</a></li>
<li class="chapter" data-level="2.1.2" data-path="types-de-donnees.html"><a href="types-de-donnees.html#indexation-et-extraction"><i class="fa fa-check"></i><b>2.1.2</b> Indexation et extraction</a></li>
<li class="chapter" data-level="2.1.3" data-path="types-de-donnees.html"><a href="types-de-donnees.html#methodes-disponibles-avec-les-chaines-de-caracteres"><i class="fa fa-check"></i><b>2.1.3</b> Méthodes disponibles avec les chaînes de caractères</a></li>
<li class="chapter" data-level="2.1.4" data-path="types-de-donnees.html"><a href="types-de-donnees.html#conversion-chaines-caracteres"><i class="fa fa-check"></i><b>2.1.4</b> Conversion en chaînes de caractères</a></li>
<li class="chapter" data-level="2.1.5" data-path="types-de-donnees.html"><a href="types-de-donnees.html#exercice"><i class="fa fa-check"></i><b>2.1.5</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="types-de-donnees.html"><a href="types-de-donnees.html#valeurs-numeriques"><i class="fa fa-check"></i><b>2.2</b> Valeurs numériques</a><ul>
<li class="chapter" data-level="2.2.1" data-path="types-de-donnees.html"><a href="types-de-donnees.html#entiers"><i class="fa fa-check"></i><b>2.2.1</b> Entiers</a></li>
<li class="chapter" data-level="2.2.2" data-path="types-de-donnees.html"><a href="types-de-donnees.html#nombre-a-virgule-flottante"><i class="fa fa-check"></i><b>2.2.2</b> Nombre à virgule flottante</a></li>
<li class="chapter" data-level="2.2.3" data-path="types-de-donnees.html"><a href="types-de-donnees.html#nombres-complexes"><i class="fa fa-check"></i><b>2.2.3</b> Nombres complèxes</a></li>
<li class="chapter" data-level="2.2.4" data-path="types-de-donnees.html"><a href="types-de-donnees.html#conversions"><i class="fa fa-check"></i><b>2.2.4</b> Conversions</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="types-de-donnees.html"><a href="types-de-donnees.html#booleens"><i class="fa fa-check"></i><b>2.3</b> Booléens</a></li>
<li class="chapter" data-level="2.4" data-path="types-de-donnees.html"><a href="types-de-donnees.html#objet-vide"><i class="fa fa-check"></i><b>2.4</b> Objet vide</a></li>
<li class="chapter" data-level="2.5" data-path="types-de-donnees.html"><a href="types-de-donnees.html#dates-et-temps"><i class="fa fa-check"></i><b>2.5</b> Dates et temps</a><ul>
<li class="chapter" data-level="2.5.1" data-path="types-de-donnees.html"><a href="types-de-donnees.html#module-datetime"><i class="fa fa-check"></i><b>2.5.1</b> Module datetime</a></li>
<li class="chapter" data-level="2.5.2" data-path="types-de-donnees.html"><a href="types-de-donnees.html#module-pytz"><i class="fa fa-check"></i><b>2.5.2</b> Module <code>pytz</code></a></li>
<li class="chapter" data-level="2.5.3" data-path="types-de-donnees.html"><a href="types-de-donnees.html#exercices"><i class="fa fa-check"></i><b>2.5.3</b> Exercices</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="structures.html"><a href="structures.html"><i class="fa fa-check"></i><b>3</b> Structures</a><ul>
<li class="chapter" data-level="3.1" data-path="structures.html"><a href="structures.html#structures-listes"><i class="fa fa-check"></i><b>3.1</b> Listes</a><ul>
<li class="chapter" data-level="3.1.1" data-path="structures.html"><a href="structures.html#structure-liste-extraction"><i class="fa fa-check"></i><b>3.1.1</b> Extraction des éléments</a></li>
<li class="chapter" data-level="3.1.2" data-path="structures.html"><a href="structures.html#modification"><i class="fa fa-check"></i><b>3.1.2</b> Modification</a></li>
<li class="chapter" data-level="3.1.3" data-path="structures.html"><a href="structures.html#test-dappartenance"><i class="fa fa-check"></i><b>3.1.3</b> Test d’appartenance</a></li>
<li class="chapter" data-level="3.1.4" data-path="structures.html"><a href="structures.html#copie-de-liste"><i class="fa fa-check"></i><b>3.1.4</b> Copie de liste</a></li>
<li class="chapter" data-level="3.1.5" data-path="structures.html"><a href="structures.html#tri"><i class="fa fa-check"></i><b>3.1.5</b> Tri</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="structures.html"><a href="structures.html#n-uplets-tuples"><i class="fa fa-check"></i><b>3.2</b> N-uplets (Tuples)</a><ul>
<li class="chapter" data-level="3.2.1" data-path="structures.html"><a href="structures.html#extraction-des-elements"><i class="fa fa-check"></i><b>3.2.1</b> Extraction des éléments</a></li>
<li class="chapter" data-level="3.2.2" data-path="structures.html"><a href="structures.html#modification-1"><i class="fa fa-check"></i><b>3.2.2</b> Modification</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="structures.html"><a href="structures.html#structure-ensembles"><i class="fa fa-check"></i><b>3.3</b> Ensembles</a><ul>
<li class="chapter" data-level="3.3.1" data-path="structures.html"><a href="structures.html#modifications"><i class="fa fa-check"></i><b>3.3.1</b> Modifications</a></li>
<li class="chapter" data-level="3.3.2" data-path="structures.html"><a href="structures.html#test-dappartenance-1"><i class="fa fa-check"></i><b>3.3.2</b> Test d’appartenance</a></li>
<li class="chapter" data-level="3.3.3" data-path="structures.html"><a href="structures.html#copie-densemble"><i class="fa fa-check"></i><b>3.3.3</b> Copie d’ensemble</a></li>
<li class="chapter" data-level="3.3.4" data-path="structures.html"><a href="structures.html#conversion-en-liste"><i class="fa fa-check"></i><b>3.3.4</b> Conversion en liste</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="structures.html"><a href="structures.html#type-dict"><i class="fa fa-check"></i><b>3.4</b> Dictionnaires</a><ul>
<li class="chapter" data-level="3.4.1" data-path="structures.html"><a href="structures.html#extraction-des-elements-1"><i class="fa fa-check"></i><b>3.4.1</b> Extraction des éléments</a></li>
<li class="chapter" data-level="3.4.2" data-path="structures.html"><a href="structures.html#cles-et-valeurs"><i class="fa fa-check"></i><b>3.4.2</b> Clés et valeurs</a></li>
<li class="chapter" data-level="3.4.3" data-path="structures.html"><a href="structures.html#recherche-dappartenance"><i class="fa fa-check"></i><b>3.4.3</b> Recherche d’appartenance</a></li>
<li class="chapter" data-level="3.4.4" data-path="structures.html"><a href="structures.html#modification-2"><i class="fa fa-check"></i><b>3.4.4</b> Modification</a></li>
<li class="chapter" data-level="3.4.5" data-path="structures.html"><a href="structures.html#copie-de-dictionnaire"><i class="fa fa-check"></i><b>3.4.5</b> Copie de dictionnaire</a></li>
<li class="chapter" data-level="3.4.6" data-path="structures.html"><a href="structures.html#exercice-1"><i class="fa fa-check"></i><b>3.4.6</b> Exercice</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="operateurs.html"><a href="operateurs.html"><i class="fa fa-check"></i><b>4</b> Opérateurs</a><ul>
<li class="chapter" data-level="4.1" data-path="operateurs.html"><a href="operateurs.html#operateurs-arithmetiques"><i class="fa fa-check"></i><b>4.1</b> Opérateurs arithmétiques</a><ul>
<li class="chapter" data-level="4.1.1" data-path="operateurs.html"><a href="operateurs.html#addition"><i class="fa fa-check"></i><b>4.1.1</b> Addition</a></li>
<li class="chapter" data-level="4.1.2" data-path="operateurs.html"><a href="operateurs.html#soustraction"><i class="fa fa-check"></i><b>4.1.2</b> Soustraction</a></li>
<li class="chapter" data-level="4.1.3" data-path="operateurs.html"><a href="operateurs.html#multiplication"><i class="fa fa-check"></i><b>4.1.3</b> Multiplication</a></li>
<li class="chapter" data-level="4.1.4" data-path="operateurs.html"><a href="operateurs.html#division"><i class="fa fa-check"></i><b>4.1.4</b> Division</a></li>
<li class="chapter" data-level="4.1.5" data-path="operateurs.html"><a href="operateurs.html#modulo"><i class="fa fa-check"></i><b>4.1.5</b> Modulo</a></li>
<li class="chapter" data-level="4.1.6" data-path="operateurs.html"><a href="operateurs.html#puissance"><i class="fa fa-check"></i><b>4.1.6</b> Puissance</a></li>
<li class="chapter" data-level="4.1.7" data-path="operateurs.html"><a href="operateurs.html#ordre"><i class="fa fa-check"></i><b>4.1.7</b> Ordre</a></li>
<li class="chapter" data-level="4.1.8" data-path="operateurs.html"><a href="operateurs.html#operateurs-mathematiques-sur-des-chaines-de-caracteres"><i class="fa fa-check"></i><b>4.1.8</b> Opérateurs mathématiques sur des chaînes de caractères</a></li>
<li class="chapter" data-level="4.1.9" data-path="operateurs.html"><a href="operateurs.html#operateurs-mathematiques-sur-des-listes-ou-des-n-uplets"><i class="fa fa-check"></i><b>4.1.9</b> Opérateurs mathématiques sur des listes ou des n-uplets</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="operateurs.html"><a href="operateurs.html#operateurs-comparaison"><i class="fa fa-check"></i><b>4.2</b> Opérateurs de comparaison</a><ul>
<li class="chapter" data-level="4.2.1" data-path="operateurs.html"><a href="operateurs.html#egalite-inegalite"><i class="fa fa-check"></i><b>4.2.1</b> Égalité, inégalité</a></li>
<li class="chapter" data-level="4.2.2" data-path="operateurs.html"><a href="operateurs.html#inferiorite-et-superiorite-stricts-ou-larges"><i class="fa fa-check"></i><b>4.2.2</b> Infériorité et supériorité, stricts ou larges</a></li>
<li class="chapter" data-level="4.2.3" data-path="operateurs.html"><a href="operateurs.html#inclusion-et-exclusion"><i class="fa fa-check"></i><b>4.2.3</b> Inclusion et exclusion</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="operateurs.html"><a href="operateurs.html#operateurs-logiques"><i class="fa fa-check"></i><b>4.3</b> Opérateurs logiques</a><ul>
<li class="chapter" data-level="4.3.1" data-path="operateurs.html"><a href="operateurs.html#et-logique"><i class="fa fa-check"></i><b>4.3.1</b> Et logique</a></li>
<li class="chapter" data-level="4.3.2" data-path="operateurs.html"><a href="operateurs.html#ou-logique"><i class="fa fa-check"></i><b>4.3.2</b> Ou logique</a></li>
<li class="chapter" data-level="4.3.3" data-path="operateurs.html"><a href="operateurs.html#non-logique"><i class="fa fa-check"></i><b>4.3.3</b> Non logique</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="operateurs.html"><a href="operateurs.html#quelques-fonctions"><i class="fa fa-check"></i><b>4.4</b> Quelques fonctions</a></li>
<li class="chapter" data-level="4.5" data-path="operateurs.html"><a href="operateurs.html#quelques-constantes"><i class="fa fa-check"></i><b>4.5</b> Quelques constantes</a></li>
<li class="chapter" data-level="4.6" data-path="operateurs.html"><a href="operateurs.html#exercice-2"><i class="fa fa-check"></i><b>4.6</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html"><i class="fa fa-check"></i><b>5</b> Chargement et sauvegarde de données</a><ul>
<li class="chapter" data-level="5.1" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#charger-donnees"><i class="fa fa-check"></i><b>5.1</b> Charger des données</a><ul>
<li class="chapter" data-level="5.1.1" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#import-fichiers-texte"><i class="fa fa-check"></i><b>5.1.1</b> Fichiers textes</a></li>
<li class="chapter" data-level="5.1.2" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#importation-fichiers-csv"><i class="fa fa-check"></i><b>5.1.2</b> Fichiers CSV</a></li>
<li class="chapter" data-level="5.1.3" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#fichier-json"><i class="fa fa-check"></i><b>5.1.3</b> Fichier JSON</a></li>
<li class="chapter" data-level="5.1.4" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#fichiers-excel"><i class="fa fa-check"></i><b>5.1.4</b> Fichiers Excel</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#exporter-des-donnees"><i class="fa fa-check"></i><b>5.2</b> Exporter des données</a><ul>
<li class="chapter" data-level="5.2.1" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#fichiers-textes"><i class="fa fa-check"></i><b>5.2.1</b> Fichiers textes</a></li>
<li class="chapter" data-level="5.2.2" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#fichiers-csv"><i class="fa fa-check"></i><b>5.2.2</b> Fichiers CSV</a></li>
<li class="chapter" data-level="5.2.3" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#fichier-json-1"><i class="fa fa-check"></i><b>5.2.3</b> Fichier JSON</a></li>
<li class="chapter" data-level="5.2.4" data-path="chargement-et-sauvegarde-de-donnees.html"><a href="chargement-et-sauvegarde-de-donnees.html#exercice-3"><i class="fa fa-check"></i><b>5.2.4</b> Exercice</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="conditions.html"><a href="conditions.html"><i class="fa fa-check"></i><b>6</b> Conditions</a><ul>
<li class="chapter" data-level="6.1" data-path="conditions.html"><a href="conditions.html#les-instructions-conditionnelles-if"><i class="fa fa-check"></i><b>6.1</b> Les instructions conditionnelles <code>if</code></a></li>
<li class="chapter" data-level="6.2" data-path="conditions.html"><a href="conditions.html#les-instructions-conditionnelles-if-else"><i class="fa fa-check"></i><b>6.2</b> Les instructions conditionnelles <code>if-else</code></a></li>
<li class="chapter" data-level="6.3" data-path="conditions.html"><a href="conditions.html#les-instructions-conditionnelles-if-elif"><i class="fa fa-check"></i><b>6.3</b> Les instructions conditionnelles <code>if-elif</code></a></li>
<li class="chapter" data-level="6.4" data-path="conditions.html"><a href="conditions.html#exercice-4"><i class="fa fa-check"></i><b>6.4</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="boucles.html"><a href="boucles.html"><i class="fa fa-check"></i><b>7</b> Boucles</a><ul>
<li class="chapter" data-level="7.1" data-path="boucles.html"><a href="boucles.html#boucles-avec-while"><i class="fa fa-check"></i><b>7.1</b> Boucles avec <code>while()</code></a></li>
<li class="chapter" data-level="7.2" data-path="boucles.html"><a href="boucles.html#boucles-avec-for"><i class="fa fa-check"></i><b>7.2</b> Boucles avec <code>for()</code></a></li>
<li class="chapter" data-level="7.3" data-path="boucles.html"><a href="boucles.html#exercice-5"><i class="fa fa-check"></i><b>7.3</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="fonctions.html"><a href="fonctions.html"><i class="fa fa-check"></i><b>8</b> Fonctions</a><ul>
<li class="chapter" data-level="8.1" data-path="fonctions.html"><a href="fonctions.html#definition"><i class="fa fa-check"></i><b>8.1</b> Définition</a><ul>
<li class="chapter" data-level="8.1.1" data-path="fonctions.html"><a href="fonctions.html#ajout-dune-description"><i class="fa fa-check"></i><b>8.1.1</b> Ajout d’une description</a></li>
<li class="chapter" data-level="8.1.2" data-path="fonctions.html"><a href="fonctions.html#parametres-dune-fonction"><i class="fa fa-check"></i><b>8.1.2</b> Paramètres d’une fonction</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="fonctions.html"><a href="fonctions.html#portee"><i class="fa fa-check"></i><b>8.2</b> Portée</a></li>
<li class="chapter" data-level="8.3" data-path="fonctions.html"><a href="fonctions.html#fonctions-lambda"><i class="fa fa-check"></i><b>8.3</b> Fonctions lambda</a></li>
<li class="chapter" data-level="8.4" data-path="fonctions.html"><a href="fonctions.html#retour-de-plusieurs-valeurs"><i class="fa fa-check"></i><b>8.4</b> Retour de plusieurs valeurs</a></li>
<li class="chapter" data-level="8.5" data-path="fonctions.html"><a href="fonctions.html#exercice-6"><i class="fa fa-check"></i><b>8.5</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="numpy.html"><a href="numpy.html"><i class="fa fa-check"></i><b>9</b> Introduction à Numpy</a><ul>
<li class="chapter" data-level="9.1" data-path="numpy.html"><a href="numpy.html#numpy-tableaux"><i class="fa fa-check"></i><b>9.1</b> Tableaux</a><ul>
<li class="chapter" data-level="9.1.1" data-path="numpy.html"><a href="numpy.html#creation"><i class="fa fa-check"></i><b>9.1.1</b> Création</a></li>
<li class="chapter" data-level="9.1.2" data-path="numpy.html"><a href="numpy.html#dimensions"><i class="fa fa-check"></i><b>9.1.2</b> Dimensions</a></li>
<li class="chapter" data-level="9.1.3" data-path="numpy.html"><a href="numpy.html#extraction-des-elements-dun-tableau"><i class="fa fa-check"></i><b>9.1.3</b> Extraction des éléments d’un tableau</a></li>
<li class="chapter" data-level="9.1.4" data-path="numpy.html"><a href="numpy.html#modification-3"><i class="fa fa-check"></i><b>9.1.4</b> Modification</a></li>
<li class="chapter" data-level="9.1.5" data-path="numpy.html"><a href="numpy.html#copie-de-tableau"><i class="fa fa-check"></i><b>9.1.5</b> Copie de tableau</a></li>
<li class="chapter" data-level="9.1.6" data-path="numpy.html"><a href="numpy.html#tri-1"><i class="fa fa-check"></i><b>9.1.6</b> Tri</a></li>
<li class="chapter" data-level="9.1.7" data-path="numpy.html"><a href="numpy.html#transposition-tableau"><i class="fa fa-check"></i><b>9.1.7</b> Transposition</a></li>
<li class="chapter" data-level="9.1.8" data-path="numpy.html"><a href="numpy.html#operations-tableaux"><i class="fa fa-check"></i><b>9.1.8</b> Opérations sur les tableaux</a></li>
<li class="chapter" data-level="9.1.9" data-path="operateurs.html"><a href="operateurs.html#operateurs-logiques"><i class="fa fa-check"></i><b>9.1.9</b> Opérateurs logiques</a></li>
<li class="chapter" data-level="9.1.10" data-path="numpy.html"><a href="numpy.html#quelques-constantes-numpy-constantes"><i class="fa fa-check"></i><b>9.1.10</b> Quelques constantes {numpy-constantes}</a></li>
<li class="chapter" data-level="9.1.11" data-path="numpy.html"><a href="numpy.html#fonctions-universelles"><i class="fa fa-check"></i><b>9.1.11</b> Fonctions universelles</a></li>
<li class="chapter" data-level="9.1.12" data-path="numpy.html"><a href="numpy.html#methodes-et-fonctions-mathematiques-et-statistiques"><i class="fa fa-check"></i><b>9.1.12</b> Méthodes et fonctions mathématiques et statistiques</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="numpy.html"><a href="numpy.html#generation-de-nombres-pseudo-aleatoires"><i class="fa fa-check"></i><b>9.2</b> Génération de nombres pseudo-aléatoires</a></li>
<li class="chapter" data-level="9.3" data-path="numpy.html"><a href="numpy.html#exercice-7"><i class="fa fa-check"></i><b>9.3</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="pandas.html"><a href="pandas.html"><i class="fa fa-check"></i><b>10</b> Manipulation de données avec <code>pandas</code></a><ul>
<li class="chapter" data-level="10.1" data-path="pandas.html"><a href="pandas.html#structures-1"><i class="fa fa-check"></i><b>10.1</b> Structures</a><ul>
<li class="chapter" data-level="10.1.1" data-path="pandas.html"><a href="pandas.html#series"><i class="fa fa-check"></i><b>10.1.1</b> Séries</a></li>
<li class="chapter" data-level="10.1.2" data-path="pandas.html"><a href="pandas.html#dataframes"><i class="fa fa-check"></i><b>10.1.2</b> Dataframes</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="pandas.html"><a href="pandas.html#pandas-selection"><i class="fa fa-check"></i><b>10.2</b> Sélection</a><ul>
<li class="chapter" data-level="10.2.1" data-path="pandas.html"><a href="pandas.html#pour-les-series"><i class="fa fa-check"></i><b>10.2.1</b> Pour les séries</a></li>
<li class="chapter" data-level="10.2.2" data-path="pandas.html"><a href="pandas.html#pour-les-dataframes"><i class="fa fa-check"></i><b>10.2.2</b> Pour les dataframes</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="pandas.html"><a href="pandas.html#renommage-des-colonnes-dans-un-dataframe"><i class="fa fa-check"></i><b>10.3</b> Renommage des colonnes dans un dataframe</a></li>
<li class="chapter" data-level="10.4" data-path="pandas.html"><a href="pandas.html#filtrage"><i class="fa fa-check"></i><b>10.4</b> Filtrage</a><ul>
<li class="chapter" data-level="10.4.1" data-path="pandas.html"><a href="pandas.html#test-dappartenance-2"><i class="fa fa-check"></i><b>10.4.1</b> Test d’appartenance</a></li>
</ul></li>
<li class="chapter" data-level="10.5" data-path="pandas.html"><a href="pandas.html#valeurs-manquantes"><i class="fa fa-check"></i><b>10.5</b> Valeurs manquantes</a><ul>
<li class="chapter" data-level="10.5.1" data-path="pandas.html"><a href="pandas.html#reperer-les-valeurs-manquantes"><i class="fa fa-check"></i><b>10.5.1</b> Repérer les valeurs manquantes</a></li>
<li class="chapter" data-level="10.5.2" data-path="pandas.html"><a href="pandas.html#retirer-les-observations-avec-valeurs-manquantes"><i class="fa fa-check"></i><b>10.5.2</b> Retirer les observations avec valeurs manquantes</a></li>
<li class="chapter" data-level="10.5.3" data-path="pandas.html"><a href="pandas.html#retirer-les-valeurs-manquantes-par-dautres-valeurs"><i class="fa fa-check"></i><b>10.5.3</b> Retirer les valeurs manquantes par d’autres valeurs</a></li>
</ul></li>
<li class="chapter" data-level="10.6" data-path="pandas.html"><a href="pandas.html#suppressions"><i class="fa fa-check"></i><b>10.6</b> Suppressions</a><ul>
<li class="chapter" data-level="10.6.1" data-path="pandas.html"><a href="pandas.html#suppression-delements-dans-une-serie"><i class="fa fa-check"></i><b>10.6.1</b> Suppression d’éléments dans une série</a></li>
<li class="chapter" data-level="10.6.2" data-path="pandas.html"><a href="pandas.html#suppression-delements-dans-un-dataframe"><i class="fa fa-check"></i><b>10.6.2</b> Suppression d’éléments dans un dataframe</a></li>
</ul></li>
<li class="chapter" data-level="10.7" data-path="pandas.html"><a href="pandas.html#remplacement-de-valeurs"><i class="fa fa-check"></i><b>10.7</b> Remplacement de valeurs</a><ul>
<li class="chapter" data-level="10.7.1" data-path="pandas.html"><a href="pandas.html#pour-une-serie"><i class="fa fa-check"></i><b>10.7.1</b> Pour une série</a></li>
<li class="chapter" data-level="10.7.2" data-path="pandas.html"><a href="pandas.html#pour-un-dataframe"><i class="fa fa-check"></i><b>10.7.2</b> Pour un dataframe</a></li>
</ul></li>
<li class="chapter" data-level="10.8" data-path="pandas.html"><a href="pandas.html#pandas-ajout-valeurs"><i class="fa fa-check"></i><b>10.8</b> Ajout de valeurs</a><ul>
<li class="chapter" data-level="10.8.1" data-path="pandas.html"><a href="pandas.html#pour-une-serie-1"><i class="fa fa-check"></i><b>10.8.1</b> Pour une série</a></li>
<li class="chapter" data-level="10.8.2" data-path="pandas.html"><a href="pandas.html#pour-un-dataframe-1"><i class="fa fa-check"></i><b>10.8.2</b> Pour un dataframe</a></li>
</ul></li>
<li class="chapter" data-level="10.9" data-path="pandas.html"><a href="pandas.html#retrait-des-valeurs-dupliquees"><i class="fa fa-check"></i><b>10.9</b> Retrait des valeurs dupliquées</a></li>
<li class="chapter" data-level="10.10" data-path="pandas.html"><a href="pandas.html#operations"><i class="fa fa-check"></i><b>10.10</b> Opérations</a><ul>
<li class="chapter" data-level="10.10.1" data-path="pandas.html"><a href="pandas.html#statistiques-pandas-statistiques-df"><i class="fa fa-check"></i><b>10.10.1</b> Statistiques {pandas-statistiques-df}</a></li>
</ul></li>
<li class="chapter" data-level="10.11" data-path="pandas.html"><a href="pandas.html#tri-2"><i class="fa fa-check"></i><b>10.11</b> Tri</a></li>
<li class="chapter" data-level="10.12" data-path="pandas.html"><a href="pandas.html#concatenation"><i class="fa fa-check"></i><b>10.12</b> Concaténation</a></li>
<li class="chapter" data-level="10.13" data-path="pandas.html"><a href="pandas.html#pandas-jointures"><i class="fa fa-check"></i><b>10.13</b> Jointures</a></li>
<li class="chapter" data-level="10.14" data-path="pandas.html"><a href="pandas.html#agregation"><i class="fa fa-check"></i><b>10.14</b> Agrégation</a><ul>
<li class="chapter" data-level="10.14.1" data-path="pandas.html"><a href="pandas.html#agregation-selon-les-valeurs-dune-seule-colonne"><i class="fa fa-check"></i><b>10.14.1</b> Agrégation selon les valeurs d’une seule colonne</a></li>
<li class="chapter" data-level="10.14.2" data-path="pandas.html"><a href="pandas.html#agregation-selon-les-valeurs-de-plusieurs-colonnes"><i class="fa fa-check"></i><b>10.14.2</b> Agrégation selon les valeurs de plusieurs colonnes</a></li>
</ul></li>
<li class="chapter" data-level="10.15" data-path="pandas.html"><a href="pandas.html#stacking-et-unstacking"><i class="fa fa-check"></i><b>10.15</b> Stacking et unstacking</a></li>
<li class="chapter" data-level="10.16" data-path="pandas.html"><a href="pandas.html#exportation-et-importation-de-donnees"><i class="fa fa-check"></i><b>10.16</b> Exportation et importation de données</a><ul>
<li class="chapter" data-level="10.16.1" data-path="pandas.html"><a href="pandas.html#exportation-des-donnees"><i class="fa fa-check"></i><b>10.16.1</b> Exportation des données</a></li>
</ul></li>
<li class="chapter" data-level="10.17" data-path="pandas.html"><a href="pandas.html#importation-des-donnees"><i class="fa fa-check"></i><b>10.17</b> Importation des données</a><ul>
<li class="chapter" data-level="10.17.1" data-path="pandas.html"><a href="pandas.html#pandas-importation-csv"><i class="fa fa-check"></i><b>10.17.1</b> Fichiers CSV</a></li>
<li class="chapter" data-level="10.17.2" data-path="pandas.html"><a href="pandas.html#pandas-importation-excel"><i class="fa fa-check"></i><b>10.17.2</b> Fichiers Excel</a></li>
<li class="chapter" data-level="10.17.3" data-path="pandas.html"><a href="pandas.html#pandas-importation-hdf"><i class="fa fa-check"></i><b>10.17.3</b> Fichiers HDF5</a></li>
</ul></li>
<li class="chapter" data-level="10.18" data-path="pandas.html"><a href="pandas.html#exercice-8"><i class="fa fa-check"></i><b>10.18</b> Exercice</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="visualisation-de-donnees.html"><a href="visualisation-de-donnees.html"><i class="fa fa-check"></i><b>11</b> Visualisation de données</a></li>
<li class="chapter" data-level="12" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>12</b> References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Python pour les économistes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="pandas" class="section level1">
<h1><span class="header-section-number">10</span> Manipulation de données avec <code>pandas</code></h1>
<p><code>pandas</code> est une librairie open-source basée sur <code>NumPy</code> fournissant des structures de données facile à manipuler, et des outils d’analyse de données. Le lecteur familier avec les fonctions de base du langage <code>R</code> retrouvera de nombreuses fonctionnalités similaires avec <code>pandas</code>.</p>
<p>Pour avoir accès aux fonctionnalités de <code>pandas</code>, il est coutume de charger la librairie en lui accordant l’alias <code>pd</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd</code></pre></div>
<p>Nous allons également utiliser des fonctions de <code>numpy</code> (c.f. Section <a href="numpy.html#numpy">9</a>). Assurons-nous de charger cette librairie, si ce n’est pas déjà fait :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np</code></pre></div>
<div id="structures-1" class="section level2">
<h2><span class="header-section-number">10.1</span> Structures</h2>
<p>Nous allons nous pencher sur deux types de structures, les séries (<code>serie</code>) et les dataframes (<code>DataFrame</code>).</p>
<div id="series" class="section level3">
<h3><span class="header-section-number">10.1.1</span> Séries</h3>
<p>Les séries sont des tableaux à une dimension de données indexées.</p>
<div id="creation-de-series-a-partir-dun-dictionnaire" class="section level4">
<h4><span class="header-section-number">10.1.1.1</span> Création de séries à partir d’un dictionnaire</h4>
<p>Pour en créer,on peut définir une liste, puis appliquer la fonction <code>Series</code> de <code>pandas</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan, .<span class="dv">5</span>, <span class="dv">1</span>])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## 0    1.0
## 1    4.0
## 2   -1.0
## 3    NaN
## 4    0.5
## 5    1.0
## dtype: float64</code></pre>
<p>L’affichage précédent montre que la série <code>s</code> créée contient à la fois les données et un index associé. L’attribut <code>values</code> permet d’afficher les valeurs qui sont stockées dans un tableau <code>numpy</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;valeur de s : &quot;</span>, s.values)</code></pre></div>
<pre><code>## valeur de s :  [ 1.   4.  -1.   nan  0.5  1. ]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;type des valeurs de s : &quot;</span>, <span class="bu">type</span>(s.values))</code></pre></div>
<pre><code>## type des valeurs de s :  &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<p>L’indice est quand à lui stocké dans une structure spécifique de <code>pandas</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;index de s : &quot;</span>, s.index)</code></pre></div>
<pre><code>## index de s :  RangeIndex(start=0, stop=6, step=1)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;type de l&#39;index de s : &quot;</span>, <span class="bu">type</span>(s.index))</code></pre></div>
<pre><code>## type de l&#39;index de s :  &lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;</code></pre>
<p>Il est possible d’attribuer un nom à la série ainsi qu’à l’index :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s.name <span class="op">=</span> <span class="st">&quot;ma_serie&quot;</span>
s.name <span class="op">=</span> <span class="st">&quot;nom_index&quot;</span>
<span class="bu">print</span>(<span class="st">&quot;nom de la série : </span><span class="sc">{}</span><span class="st"> , nom de l&#39;index : </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(s.name, s.index.name))</code></pre></div>
<pre><code>## nom de la série : nom_index , nom de l&#39;index : None</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;série s : </span><span class="ch">\n</span><span class="st">&quot;</span>, s)</code></pre></div>
<pre><code>## série s : 
##  0    1.0
## 1    4.0
## 2   -1.0
## 3    NaN
## 4    0.5
## 5    1.0
## Name: nom_index, dtype: float64</code></pre>
</div>
<div id="definition-de-lindex" class="section level4">
<h4><span class="header-section-number">10.1.1.2</span> Définition de l’index</h4>
<p>L’index peut être défini par l’utilisateur, au moment de la création de la série :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64</code></pre>
<p>On peut définir l’indice avec des valeurs numériques également, sans être forcé de respecter un ordre précis :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">40</span>, <span class="dv">2</span>, <span class="dv">3</span>])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## 4     1.0
## 40    4.0
## 2    -1.0
## 3     NaN
## dtype: float64</code></pre>
<p>L’index peut être modifié par la suite, en venant écraser l’attribut <code>index</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s.index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>]
<span class="bu">print</span>(<span class="st">&quot;Série s : </span><span class="ch">\n</span><span class="st">&quot;</span>, s)</code></pre></div>
<pre><code>## Série s : 
##  o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64</code></pre>
</div>
<div id="creation-de-series-particulieres" class="section level4">
<h4><span class="header-section-number">10.1.1.3</span> Création de séries particulières</h4>
<p>Il existe une petite astuce pour créer des séries avec une valeur répétée, qui consiste à fournir un scalaire à la fonction <code>Series</code> de <code>NumPy</code> et un index dont la longueur correspondra au nombre de fois où le scalaire sera répété :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series(<span class="dv">5</span>, index <span class="op">=</span> [np.arange(<span class="dv">4</span>)])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## 0    5
## 1    5
## 2    5
## 3    5
## dtype: int64</code></pre>
<p>On peut créer une série à partir d’un dictionnaire :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dictionnaire <span class="op">=</span> {<span class="st">&quot;Roi&quot;</span>: <span class="st">&quot;Arthur&quot;</span>,
                <span class="st">&quot;Chevalier_pays_galles&quot;</span>: <span class="st">&quot;Perceval&quot;</span>,
                <span class="st">&quot;Druide&quot;</span>: <span class="st">&quot;Merlin&quot;</span>}
s <span class="op">=</span> pd.Series(dictionnaire)
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## Roi                        Arthur
## Chevalier_pays_galles    Perceval
## Druide                     Merlin
## dtype: object</code></pre>
<p>Comme on le note dans la sortie précédente, les clés du dictionnaire ont été utilisées pour l’index. Lors de la création de la série, on peut préciser au paramètre clé des valeurs spécifiques : cela aura pour conséquence de ne récupérer que les observations correspondant à ces clés :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dictionnaire <span class="op">=</span> {<span class="st">&quot;Roi&quot;</span>: <span class="st">&quot;Arthur&quot;</span>,
                <span class="st">&quot;Chevalier_pays_galles&quot;</span>: <span class="st">&quot;Perceval&quot;</span>,
                <span class="st">&quot;Druide&quot;</span>: <span class="st">&quot;Merlin&quot;</span>}
s <span class="op">=</span> pd.Series(dictionnaire, index <span class="op">=</span> [<span class="st">&quot;Roi&quot;</span>, <span class="st">&quot;Druide&quot;</span>])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## Roi       Arthur
## Druide    Merlin
## dtype: object</code></pre>
</div>
</div>
<div id="dataframes" class="section level3">
<h3><span class="header-section-number">10.1.2</span> Dataframes</h3>
<p>Les Dataframes correspondent au format de données que l’on rencontre classiquement en économie, des tableaux à deux dimensions, avec des variables en colonnes et des observations en ligne. Les colonnes et lignes des dataframes sont indexées.</p>
<div id="creation-de-dataframes-a-partir-dun-dictionnaire" class="section level4">
<h4><span class="header-section-number">10.1.2.1</span> Création de dataframes à partir d’un dictionnaire</h4>
<p>Pour créer un dataframe, on peut fournir à la fonction <code>DataFrame()</code> de <code>pandas</code> un dictionnaire pouvant être transformé en <code>serie</code>. C’est le cas d’un dictionnaire dont les valeurs associées aux clés ont toutes la même longueur :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : 
               [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>,
                <span class="dv">63</span>, <span class="dv">64</span>, <span class="dv">65</span>, <span class="dv">66</span>, <span class="dv">67</span>,
                <span class="dv">68</span>, <span class="dv">69</span>, <span class="dv">70</span>, <span class="dv">71</span>, <span class="dv">72</span>],
        <span class="st">&quot;weight&quot;</span>: 
               [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>,
                <span class="dv">129</span>, <span class="dv">132</span>, <span class="dv">135</span>, <span class="dv">139</span>, <span class="dv">142</span>,
                <span class="dv">146</span>, <span class="dv">150</span>, <span class="dv">154</span>, <span class="dv">159</span>, <span class="dv">164</span>]
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##     height  weight
## 0       58     115
## 1       59     117
## 2       60     120
## 3       61     123
## 4       62     126
## 5       63     129
## 6       64     132
## 7       65     135
## 8       66     139
## 9       67     142
## 10      68     146
## 11      69     150
## 12      70     154
## 13      71     159
## 14      72     164</code></pre>
<p>La position des éléments dans le dataframe sert d’index. Comme pour les séries, les valeur sont accessibles dans l’attribut <code>values</code> et l’index dans l’attribut <code>index</code>. Les colonnes sont également indexées :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.columns)</code></pre></div>
<pre><code>## Index([&#39;height&#39;, &#39;weight&#39;], dtype=&#39;object&#39;)</code></pre>
<p>La méthode <code>head()</code> permet d’afficher les premières lignes (les 5 premières, par défaut). On peut modifier son paramètre <code>n</code> pour indiquer le nombre de lignes à retourner :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.head(<span class="dv">2</span>)</code></pre></div>
<p>Lors de la création d’un dataframe à partir d’un dictionnaire, si on précise le nom des colonnes à importer par une liste de chaînes de caractères fournie au paramètree <code>columns</code> de la fonction <code>DataFrame</code>, on peut non seulement définir les colonnes à remplir mais également leur ordre d’apparition.</p>
<p>Par exemple, pour n’importer que la colonne <code>weight</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> pd.DataFrame(dico, columns <span class="op">=</span> [<span class="st">&quot;weight&quot;</span>])
<span class="bu">print</span>(df.head(<span class="dv">2</span>))</code></pre></div>
<pre><code>##    weight
## 0     115
## 1     117</code></pre>
<p>Et pour définir l’ordre dans lequel les colonnes apparaîtront :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> pd.DataFrame(dico, columns <span class="op">=</span> [<span class="st">&quot;weight&quot;</span>, <span class="st">&quot;height&quot;</span>])
<span class="bu">print</span>(df.head(<span class="dv">2</span>))</code></pre></div>
<pre><code>##    weight  height
## 0     115      58
## 1     117      59</code></pre>
<p>Si on indique un nom de colonne absent parmi les clés du dictionnaires, le dataframe résultant contiendra une colonne portant ce nom mais remplie de valeurs <code>NaN</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> pd.DataFrame(dico, columns <span class="op">=</span> [<span class="st">&quot;weight&quot;</span>, <span class="st">&quot;height&quot;</span>, <span class="st">&quot;age&quot;</span>])
<span class="bu">print</span>(df.head(<span class="dv">2</span>))</code></pre></div>
<pre><code>##    weight  height  age
## 0     115      58  NaN
## 1     117      59  NaN</code></pre>
</div>
<div id="creation-de-dataframes-a-partir-dune-serie" class="section level4">
<h4><span class="header-section-number">10.1.2.2</span> Création de dataframes à partir d’une série</h4>
<p>Un dataframe peut être créé à partir d’une série :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan], index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>])
s.name <span class="op">=</span> <span class="st">&quot;nom_variable&quot;</span>
df <span class="op">=</span> pd.DataFrame(s, columns <span class="op">=</span> [<span class="st">&quot;nom_variable&quot;</span>])
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    nom_variable
## o           1.0
## d           4.0
## i          -1.0
## l           NaN</code></pre>
<p>Si on n’attribue pas de nom à la série, il suffit de ne pas renseigner le paramètre <code>columns</code> de la fonction <code>DataFrame</code>. Mais dans ce cas, la colonne n’aura pas de non, juste un index numérique.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan], index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>])
df <span class="op">=</span> pd.DataFrame(s)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##      0
## o  1.0
## d  4.0
## i -1.0
## l  NaN</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.columns.name)</code></pre></div>
<pre><code>## None</code></pre>
</div>
<div id="creation-de-dataframes-a-partir-dune-liste-de-dictionnaire" class="section level4">
<h4><span class="header-section-number">10.1.2.3</span> Création de dataframes à partir d’une liste de dictionnaire</h4>
<p>Un dataframe peut être créé à partir d’une liste de dictionnaires :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico_1 <span class="op">=</span> {
    <span class="st">&quot;Nom&quot;</span>: <span class="st">&quot;Pendragon&quot;</span>,
    <span class="st">&quot;Prenom&quot;</span>: <span class="st">&quot;Arthur&quot;</span>,
    <span class="st">&quot;Role&quot;</span>: <span class="st">&quot;Roi de Bretagne&quot;</span>
}
dico_2 <span class="op">=</span> {
    <span class="st">&quot;Nom&quot;</span>: <span class="st">&quot;de Galles&quot;</span>,
    <span class="st">&quot;Prenom&quot;</span>: <span class="st">&quot;Perceval&quot;</span>,
    <span class="st">&quot;Role&quot;</span>: <span class="st">&quot;Chevalier du Pays de Galles&quot;</span>
}
df <span class="op">=</span> pd.DataFrame([dico_1, dico_2])
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##          Nom    Prenom                         Role
## 0  Pendragon    Arthur              Roi de Bretagne
## 1  de Galles  Perceval  Chevalier du Pays de Galles</code></pre>
<p>Si certaines clés sont absentes dans un ou plusieurs des dictionnaires de la liste, les valeurs correspondantes dans le dataframe seront <code>NaN</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico_3 <span class="op">=</span> {
    <span class="st">&quot;Prenom&quot;</span>: <span class="st">&quot;Guenièvre&quot;</span>,
    <span class="st">&quot;Role&quot;</span>: <span class="st">&quot;Reine de Bretagne&quot;</span>
}
df <span class="op">=</span> pd.DataFrame([dico_1, dico_2, dico_3])
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##          Nom             ...                                      Role
## 0  Pendragon             ...                           Roi de Bretagne
## 1  de Galles             ...               Chevalier du Pays de Galles
## 2        NaN             ...                         Reine de Bretagne
## 
## [3 rows x 3 columns]</code></pre>
</div>
<div id="creation-de-dataframes-a-partir-dun-dictionnaire-de-series" class="section level4">
<h4><span class="header-section-number">10.1.2.4</span> Création de dataframes à partir d’un dictionnaire de séries</h4>
<p>On peut aussi créer un dataframe à partir d’un dictionnaire de séries. Pour illustrer la méthode, créons deux dictionnaires :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># PIB annuel 2017</span>
<span class="co"># En millions de dollars courants</span>
dico_gdp_current <span class="op">=</span> {
    <span class="st">&quot;France&quot;</span>: <span class="fl">2582501.31</span>,
    <span class="st">&quot;USA&quot;</span>: <span class="fl">19390604.00</span>,
    <span class="st">&quot;UK&quot;</span>: <span class="fl">2622433.96</span>
}
<span class="co"># Indice annuel des prix à la consommation</span>
dico_cpi <span class="op">=</span> {
    <span class="st">&quot;France&quot;</span>: <span class="fl">0.2</span>,
    <span class="st">&quot;UK&quot;</span>: <span class="fl">0.6</span>,
    <span class="st">&quot;USA&quot;</span>: <span class="fl">1.3</span>,
    <span class="st">&quot;Germany&quot;</span>: <span class="fl">0.5</span>
}</code></pre></div>
<p>À partir de ces deux dictionnaires, créons deux séries correspondantes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_gdp_current <span class="op">=</span> pd.Series(dico_gdp_current)
s_cpi <span class="op">=</span> pd.Series(dico_cpi)
<span class="bu">print</span>(<span class="st">&quot;s_gdp_current : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_gdp_current)</code></pre></div>
<pre><code>## s_gdp_current : 
##  France     2582501.31
## USA       19390604.00
## UK         2622433.96
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">s_cpi : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_cpi)</code></pre></div>
<pre><code>## 
## s_cpi : 
##  France     0.2
## UK         0.6
## USA        1.3
## Germany    0.5
## dtype: float64</code></pre>
<p>Puis, créons un dictionnaire de séries :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico_de_series <span class="op">=</span> {
    <span class="st">&quot;gdp&quot;</span>: s_gdp_current,
    <span class="st">&quot;cpi&quot;</span>: s_cpi
}
<span class="bu">print</span>(dico_de_series)</code></pre></div>
<pre><code>## {&#39;gdp&#39;: France     2582501.31
## USA       19390604.00
## UK         2622433.96
## dtype: float64, &#39;cpi&#39;: France     0.2
## UK         0.6
## USA        1.3
## Germany    0.5
## dtype: float64}</code></pre>
<p>Enfin, créons notre dataframe :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.DataFrame(dico_de_series)
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>##                  gdp  cpi
## France    2582501.31  0.2
## Germany          NaN  0.5
## UK        2622433.96  0.6
## USA      19390604.00  1.3</code></pre>

<div class="remarque">
<p>Le dictionnaire <code>dico_gdp_current</code> ne contient pas de clé <code>Germany</code>, contrairement au dictionnaire <code>dico_cpi</code>. Lors de la création du dataframe, la valeur du PIB pour l’Allemagne a dont été assignée comme <code>NaN</code>.</p>
</div>

</div>
<div id="creation-de-dataframes-a-partir-dun-tableau-numpy-a-deux-dimensions" class="section level4">
<h4><span class="header-section-number">10.1.2.5</span> Création de dataframes à partir d’un tableau <code>NumPy</code> à deux dimensions</h4>
<p>On peut aussi créer un dataframe à partir d’un tableau <code>Numpy</code>. Lors de la création, avec la fonction <code>DataFrame()</code> de <code>NumPy</code>, il est possible de préciser le nom des colonnes (à défaut, l’indiçage des colonnes sera numérique) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">liste <span class="op">=</span> [
    [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],
    [<span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>],
    [<span class="dv">111</span>, <span class="dv">222</span>, <span class="dv">333</span>],
    [<span class="dv">1111</span>, <span class="dv">2222</span>, <span class="dv">3333</span>]
]
tableau_np <span class="op">=</span> np.array(tableau)
<span class="bu">print</span>(df <span class="op">=</span> pd.DataFrame(tableau_np,
                  columns <span class="op">=</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>]))</code></pre></div>
<pre><code>## ValueError: Shape of passed values is (2, 3), indices imply (3, 3)
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 2, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/frame.py&quot;, line 379, in __init__
##     copy=copy)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/frame.py&quot;, line 536, in _init_ndarray
##     return create_block_manager_from_blocks([values], [columns, index])
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/internals.py&quot;, line 4866, in create_block_manager_from_blocks
##     construction_error(tot_items, blocks[0].shape[1:], axes, e)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/internals.py&quot;, line 4843, in construction_error
##     passed, implied))</code></pre>
</div>
<div id="dimensions-1" class="section level4">
<h4><span class="header-section-number">10.1.2.6</span> Dimensions</h4>
<p>On accède aux dimensions d’un dataframe avec l’attribut <code>shape</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;shape : &quot;</span>, df.shape)</code></pre></div>
<pre><code>## shape :  (3, 3)</code></pre>
<p>On peut aussi afficher le nombre de lignes comme suit :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;shape : &quot;</span>, <span class="bu">len</span>(df))</code></pre></div>
<pre><code>## shape :  3</code></pre>
<p>Et le nombre de colonnes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;shape : &quot;</span>, <span class="bu">len</span>(df.columns))</code></pre></div>
<pre><code>## shape :  3</code></pre>
</div>
<div id="modification-de-lindex" class="section level4">
<h4><span class="header-section-number">10.1.2.7</span> Modification de l’index</h4>
<p>Comme pour les séries, on peut modifier l’index une fois que le dataframe a été créé, en venant écraser les valeurs des attributs <code>index</code> et <code>columns</code>, pour l’index des lignes et colonnes, respectivement :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>]</code></pre></div>
<pre><code>## ValueError: Length mismatch: Expected axis has 3 elements, new values have 4 elements
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py&quot;, line 4385, in __setattr__
##     return object.__setattr__(self, name, value)
##   File &quot;pandas/_libs/properties.pyx&quot;, line 69, in pandas._libs.properties.AxisProperty.__set__
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py&quot;, line 645, in _set_axis
##     self._data.set_axis(axis, labels)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/internals.py&quot;, line 3323, in set_axis
##     &#39;values have {new} elements&#39;.format(old=old_len, new=new_len))</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.columns <span class="op">=</span> [<span class="st">&quot;aa&quot;</span>, <span class="st">&quot;bb&quot;</span>, <span class="st">&quot;cc&quot;</span>]
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##           aa             ...                                        cc
## 0  Pendragon             ...                           Roi de Bretagne
## 1  de Galles             ...               Chevalier du Pays de Galles
## 2        NaN             ...                         Reine de Bretagne
## 
## [3 rows x 3 columns]</code></pre>
</div>
</div>
</div>
<div id="pandas-selection" class="section level2">
<h2><span class="header-section-number">10.2</span> Sélection</h2>
<p>Dans cette section, nous regardons différentes manières de sélectionner des données dans des séries et dataframes. On note deux manières bien distinctes :</p>
<ul>
<li>une première basée sur l’utiliation de crochets directement sur l’objet pour lequel on souhaite sélectionner certaines parties ;</li>
<li>seconde s’appuyant sur des indexeurs, accessibles en tant qu’attributs d’objets <code>NumPy</code> (<code>loc</code>, <code>at</code>, <code>iat</code>, etc.)</li>
</ul>
<p>La seconde méthode permet d’éviter certaines confusions qui peuvent apparaître dans le cas d’index numériques.</p>
<div id="pour-les-series" class="section level3">
<h3><span class="header-section-number">10.2.1</span> Pour les séries</h3>
<p>Dans un premier temps, regardons les manières d’extraire des valeurs contenues dans des séries.</p>
<div id="avec-les-crochets" class="section level4">
<h4><span class="header-section-number">10.2.1.1</span> Avec les crochets</h4>
<p>On peut utiliser l’index pour extraire les données :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan, .<span class="dv">5</span>, <span class="dv">1</span>])
s[<span class="dv">0</span>] <span class="co"># 1er élément de s</span>
s[<span class="dv">1</span>:<span class="dv">3</span>] <span class="co"># du 2e élément (inclus) au 4e (non inclus)</span>
s[[<span class="dv">0</span>,<span class="dv">4</span>]] <span class="co"># 1er et 5e éléments</span></code></pre></div>
<p>On note que contrairement aux tableaux <code>numpy</code> ou aux listes, on ne peut pas utiliser des valeurs négatives pour l’index afin de récupérer les données en comptant leur position par rapport à la fin :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s[<span class="op">-</span><span class="dv">2</span>]</code></pre></div>
<pre><code>## KeyError: -2
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/series.py&quot;, line 766, in __getitem__
##     result = self.index.get_value(self, key)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/indexes/base.py&quot;, line 3103, in get_value
##     tz=getattr(series.dtype, &#39;tz&#39;, None))
##   File &quot;pandas/_libs/index.pyx&quot;, line 106, in pandas._libs.index.IndexEngine.get_value
##   File &quot;pandas/_libs/index.pyx&quot;, line 114, in pandas._libs.index.IndexEngine.get_value
##   File &quot;pandas/_libs/index.pyx&quot;, line 162, in pandas._libs.index.IndexEngine.get_loc
##   File &quot;pandas/_libs/hashtable_class_helper.pxi&quot;, line 958, in pandas._libs.hashtable.Int64HashTable.get_item
##   File &quot;pandas/_libs/hashtable_class_helper.pxi&quot;, line 964, in pandas._libs.hashtable.Int64HashTable.get_item</code></pre>
<p>Dans le cas d’un indice composé de chaînes de caractères, il est alors possible, pour extraire les données de la série, de faire référence soit au contenu de l’indice (pour faire simple, son nom), soit à sa position :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="st">&quot;o&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;l&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;La série s : </span><span class="ch">\n</span><span class="st">&quot;</span>, s)</code></pre></div>
<pre><code>## La série s : 
##  o    1.0
## d    4.0
## i   -1.0
## l    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&#39;s[&quot;d&quot;] : </span><span class="ch">\n</span><span class="st">&#39;</span>, s[<span class="st">&quot;d&quot;</span>])</code></pre></div>
<pre><code>## s[&quot;d&quot;] : 
##  4.0</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&#39;s[1] : </span><span class="ch">\n</span><span class="st">&#39;</span>, s[<span class="dv">1</span>])</code></pre></div>
<pre><code>## s[1] : 
##  4.0</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments o et i : </span><span class="ch">\n</span><span class="st">&quot;</span>, s[[<span class="st">&quot;o&quot;</span>, <span class="st">&quot;i&quot;</span>]])</code></pre></div>
<pre><code>## éléments o et i : 
##  o    1.0
## i   -1.0
## dtype: float64</code></pre>
<p>Par contre, dans le cas où l’indice est défini avec des valeurs numériques, pour extraire les valeurs à l’aide des crochets, ce sera par la valeur de l’indice et pas en s’appuyant sur la position :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">40</span>, <span class="dv">2</span>, <span class="dv">3</span>])
<span class="bu">print</span>(s[<span class="dv">40</span>])</code></pre></div>
<pre><code>## 4.0</code></pre>
</div>
<div id="avec-les-indexeurs" class="section level4">
<h4><span class="header-section-number">10.2.1.2</span> Avec les indexeurs</h4>
<p>Pandas propose deux types d’indiçage multi-axes : <code>loc</code>, <code>iloc</code>. Le premier est principalement basé sur l’utilisation des labels des axes, tandis que le second s’appuie principalement sur les positions à l’aide d’entiers.</p>
<p>Pour les besoins de cette partie, créons deux séries ; une première avec un index textuel, une deuxième avec un index numérique :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>])
s_texte <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>])</code></pre></div>
<div id="extraction-dun-seul-element" class="section level5">
<h5><span class="header-section-number">10.2.1.2.1</span> Extraction d’un seul élément</h5>
<p>Pour extraire un objet avec <code>loc</code>, on utilise le nom de l’indice :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(s_num.loc[<span class="dv">5</span>], s_texte.loc[<span class="st">&quot;c&quot;</span>])</code></pre></div>
<pre><code>## 1.0 1.0</code></pre>
<p>Pour extraire un élément unique avec <code>iloc</code>, il suffit d’indiquer sa position :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(s_num.iloc[<span class="dv">1</span>], s_texte.iloc[<span class="dv">1</span>])</code></pre></div>
</div>
<div id="extraction-de-plusieurs-elements" class="section level5">
<h5><span class="header-section-number">10.2.1.2.2</span> Extraction de plusieurs éléments</h5>
<p>Pour extraire plusieurs éléments avec <code>loc</code>, on utilise les noms (labels) des indices, que l’on fournit dans une liste :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux labels 5 et 4 :</span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.loc[[<span class="dv">5</span>,<span class="dv">4</span>]])</code></pre></div>
<pre><code>## éléments aux labels 5 et 4 :
##  5    1.0
## 4   -1.0
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux labels c et b : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.loc[[<span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>]])</code></pre></div>
<pre><code>## éléments aux labels c et b : 
##  c    1.0
## b   -1.0
## dtype: float64</code></pre>
<p>Pour extraire plusieurs éléments avec <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux positions 0 et 2 :</span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.iloc[[<span class="dv">0</span>,<span class="dv">2</span>]])</code></pre></div>
<pre><code>## éléments aux positions 0 et 2 :
##  5    1.0
## 4   -1.0
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux positions 0 et 2 : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.iloc[[<span class="dv">0</span>,<span class="dv">2</span>]])</code></pre></div>
<pre><code>## éléments aux positions 0 et 2 : 
##  c    1.0
## b   -1.0
## dtype: float64</code></pre>
</div>
<div id="decoupage-series" class="section level5">
<h5><span class="header-section-number">10.2.1.2.3</span> Découpage</h5>
<p>On peut effectuer des découpages de séries, pour récupérer des éléments consécutifs :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments des labels 5 jusqu&#39;à 4 :</span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.loc[<span class="dv">5</span>:<span class="dv">4</span>])</code></pre></div>
<pre><code>## éléments des labels 5 jusqu&#39;à 4 :
##  5    1.0
## 0    4.0
## 4   -1.0
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments des labels c à b : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.loc[<span class="st">&quot;c&quot;</span>:<span class="st">&quot;b&quot;</span>])</code></pre></div>
<pre><code>## éléments des labels c à b : 
##  c    1.0
## a    4.0
## b   -1.0
## dtype: float64</code></pre>
<p>Pour extraire plusieurs éléments avec <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux positions de 0 à 2 :</span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.iloc[<span class="dv">0</span>:<span class="dv">2</span>])</code></pre></div>
<pre><code>## éléments aux positions de 0 à 2 :
##  5    1.0
## 0    4.0
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;éléments aux positions de 0 à 2 : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.iloc[<span class="dv">0</span>:<span class="dv">2</span>])</code></pre></div>
<pre><code>## éléments aux positions de 0 à 2 : 
##  c    1.0
## a    4.0
## dtype: float64</code></pre>
<p>Comme ce que l’on a vu jusqu’à présent, la valeur supérieur de la limite n’est pas incluse dans le découpage.</p>
</div>
<div id="masque" class="section level5">
<h5><span class="header-section-number">10.2.1.2.4</span> Masque</h5>
<p>On peut aussi utiliser un masque pour extraire des éléments, indifféremment en utilisant <code>loc</code> ou <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,s_num.loc[[<span class="va">True</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>]])</code></pre></div>
<pre><code>## 
##  5    1.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.loc[[<span class="va">True</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>]])</code></pre></div>
<pre><code>## 
##  c    1.0
## d    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.iloc[[<span class="va">True</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>]])</code></pre></div>
<pre><code>## 
##  5    1.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.iloc[[<span class="va">True</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>]])</code></pre></div>
<pre><code>## 
##  c    1.0
## d    NaN
## dtype: float64</code></pre>
</div>
<div id="quel-est-linteret" class="section level5">
<h5><span class="header-section-number">10.2.1.2.5</span> Quel est l’intérêt ?</h5>
<p>Pourquoi introduir de telles manières d’extraire les données et ne pas se contenter de l’extraction à l’aide des crochers sur les objets ? Regardons un exemple simple. Admettons que nous disposons de la série <code>s_num</code>, avec un indice composé d’entiers n’étant pas une séquence allant de 0 au nombre d’éléments. Dans ce cas, si nous souhaitons récupérer récupérer le 2e élément, du fait de l’indice composé de valeurs numériques, nous ne pouvons pas l’obtenir en demandant <code>s[1]</code>. Pour extraire le 2e de la série, on doit savoir que son indice vaut <code>0</code> et ainsi demander :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;L&#39;élément dont l&#39;index vaut 0 : &quot;</span>, s_num[<span class="dv">0</span>])</code></pre></div>
<pre><code>## L&#39;élément dont l&#39;index vaut 0 :  4.0</code></pre>
<p>Pour pouvoir effectuer l’extraction en fonction de la position, il est bien pratique d’avoir cet attribut <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;L&#39;élément en 2e position :&quot;</span>, s_num.iloc[<span class="dv">1</span>])</code></pre></div>
<pre><code>## L&#39;élément en 2e position : 4.0</code></pre>
</div>
</div>
</div>
<div id="pour-les-dataframes" class="section level3">
<h3><span class="header-section-number">10.2.2</span> Pour les dataframes</h3>
<p>À présent, regardons différentes manières d’extraire des données depuis un dataframe. Créons deux dataframes en exemple, l’une avec un index numérique ; une autre avec un index textuel :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
       } 
df_num <span class="op">=</span> pd.DataFrame(dico)
df_texte <span class="op">=</span> pd.DataFrame(dico, index<span class="op">=</span>[<span class="st">&quot;a&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;df_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, df_num)</code></pre></div>
<pre><code>## df_num : 
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;df_texte : </span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte)</code></pre></div>
<pre><code>## df_texte : 
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172
## b      61     123   31     160
## d      62     126   29     158</code></pre>
<p>Pour faire simple, lorsqu’on veut effectuer une extraction avec les attributs <code>iloc</code>, la syntaxe est la suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.iloc[selection_lignes, selection_colonnes]</code></pre></div>
<p>avec <code>selection_lignes</code> :</p>
<ul>
<li>une valeur unique : <code>1</code> (seconde ligne) ;</li>
<li>une liste de valeurs : <code>[2, 1, 3]</code> (3e ligne, 2e ligne et 4e ligne) ;</li>
<li>un découpage : <code>[2:4]</code> (de la 3e ligne à la 4e ligne (non incluse)).</li>
</ul>
<p>pour <code>selection_colonnes</code> :</p>
<ul>
<li>une valeur unique : <code>1</code> (seconde colonne) ;</li>
<li>une liste de valeurs : <code>[2, 1, 3]</code> (3e colonne, 2e colonne et 4e colonne) ;</li>
<li>un découpage : <code>[2:4]</code> (de la 3e colonne à la 4e colonne (non incluse)).</li>
</ul>
<p>Avec <code>loc</code>, la syntaxe est la suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.loc[selection_lignes, selection_colonnes]</code></pre></div>
<p>avec <code>selection_lignes</code> :</p>
<ul>
<li>une valeur unique : <code>&quot;a&quot;</code> (ligne nommée <code>a</code>) ;</li>
<li>une liste de noms : <code>[&quot;a&quot;, &quot;c&quot;, &quot;b&quot;]</code> (lignes nommées “a”, “c” et “b”) ;</li>
<li>un masque : <code>df.['a']&lt;10</code> (lignes pour lesquelles les valeurs du masque valent <code>True</code>).</li>
</ul>
<p>pour <code>selection_colonnes</code> :</p>
<ul>
<li>une valeur unique : <code>a</code> (colonne nommée <code>a</code>) ;</li>
<li>une liste de valeurs : <code>[&quot;a&quot;, &quot;c&quot;, &quot;b&quot;]</code> (colonnes nommées “a”, “c” et “b”) ;</li>
<li>un découpage : <code>[&quot;a&quot;:&quot;c&quot;]</code> (de la colonne nommée “a” à la colonne nommée “c”).</li>
</ul>
<div id="extraction-dune-ligne" class="section level4">
<h4><span class="header-section-number">10.2.2.1</span> Extraction d’une ligne</h4>
<p>Pour extraire une ligne d’un dataframe, on peut utiliser le nom de la ligne avec <code>loc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Ligne nommée &#39;e&#39;:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[<span class="st">&quot;e&quot;</span>])</code></pre></div>
<pre><code>## Ligne nommée &#39;e&#39;:
##  height     59
## weight    117
## age        33
## taille    156
## Name: e, dtype: int64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Ligne nommée &#39;e&#39;:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.loc[<span class="dv">1</span>])</code></pre></div>
<pre><code>## 
## Ligne nommée &#39;e&#39;:
##  height     59
## weight    117
## age        33
## taille    156
## Name: 1, dtype: int64</code></pre>
<p>Ou bien, sa position avec <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Ligne en position 0:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.iloc[<span class="dv">0</span>])</code></pre></div>
<pre><code>## Ligne en position 0:
##  height     58
## weight    115
## age        28
## taille    162
## Name: a, dtype: int64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Ligne en position 0:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.iloc[<span class="dv">0</span>])</code></pre></div>
<pre><code>## 
## Ligne en position 0:
##  height     58
## weight    115
## age        28
## taille    162
## Name: 0, dtype: int64</code></pre>
</div>
<div id="extraction-de-plusieurs-lignes" class="section level4">
<h4><span class="header-section-number">10.2.2.2</span> Extraction de plusieurs lignes</h4>
<p>Pour extraire plusieurs lignes d’un dataframe, on peut utiliser leur noms avec <code>loc</code> (dans un tableau) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Lignes nommées a et c :</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[[<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>]])</code></pre></div>
<pre><code>## Lignes nommées a et c :
##     height  weight  age  taille
## a      58     115   28     162
## c      60     120   31     172</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Lignes nommées 0 et 2:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.loc[[<span class="dv">0</span>, <span class="dv">2</span>]])</code></pre></div>
<pre><code>## 
## Lignes nommées 0 et 2:
##     height  weight  age  taille
## 0      58     115   28     162
## 2      60     120   31     172</code></pre>
<p>Ou bien, leur position avec <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Lignes aux positions 0 et 3:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.iloc[[<span class="dv">0</span>, <span class="dv">3</span>]])</code></pre></div>
<pre><code>## Lignes aux positions 0 et 3:
##     height  weight  age  taille
## a      58     115   28     162
## b      61     123   31     160</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Lignes aux positions 0 et 3:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.iloc[[<span class="dv">0</span>, <span class="dv">3</span>]])</code></pre></div>
<pre><code>## 
## Lignes aux positions 0 et 3:
##     height  weight  age  taille
## 0      58     115   28     162
## 3      61     123   31     160</code></pre>
</div>
<div id="decoupage-df-lignes" class="section level4">
<h4><span class="header-section-number">10.2.2.3</span> Découpage de plusieurs lignes</h4>
<p>On peut récupérer une suite de ligne en délimitant la première et la dernière à extraire en fonction de leur nom et en utilisant <code>loc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Lignes du label a à c:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[<span class="st">&quot;a&quot;</span>:<span class="st">&quot;c&quot;</span>])</code></pre></div>
<pre><code>## Lignes du label a à c:
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;\Lignes du label 0 à 2:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.loc[<span class="dv">0</span>:<span class="dv">2</span>])</code></pre></div>
<pre><code>## \Lignes du label 0 à 2:
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172</code></pre>
<p>Avec l’attribut <code>iloc</code>, c’est également possible (encore une fois, la borne supérieure n’est pas incluse) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Lignes des positions 0 à 3 (non incluse):</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.iloc[<span class="dv">0</span>:<span class="dv">3</span>])</code></pre></div>
<pre><code>## Lignes des positions 0 à 3 (non incluse):
##     height  weight  age  taille
## a      58     115   28     162
## e      59     117   33     156
## c      60     120   31     172</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Lignes des positions 0 à 3 (non incluse):</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.iloc[<span class="dv">0</span>:<span class="dv">3</span>])</code></pre></div>
<pre><code>## 
## Lignes des positions 0 à 3 (non incluse):
##     height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172</code></pre>
</div>
<div id="masque-extraction-ligne" class="section level4">
<h4><span class="header-section-number">10.2.2.4</span> Masque</h4>
<p>On peut aussi utiliser un masque pour sélectionner certaines lignes. Par exemple, si on souhaite récupérer les lignes pour lesquelles la variable <code>height</code> a une valeur supérieure à 60, on utilise le masque suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">masque <span class="op">=</span> df_texte[<span class="st">&quot;height&quot;</span>]<span class="op">&gt;</span> <span class="dv">60</span>
<span class="bu">print</span>(masque)</code></pre></div>
<pre><code>## a    False
## e    False
## c    False
## b     True
## d     True
## Name: height, dtype: bool</code></pre>
<p>Pour filtrer :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df_texte.loc[masque])</code></pre></div>
<pre><code>##    height  weight  age  taille
## b      61     123   31     160
## d      62     126   29     158</code></pre>
</div>
<div id="extraction-dune-seule-colonne" class="section level4">
<h4><span class="header-section-number">10.2.2.5</span> Extraction d’une seule colonne</h4>
<p>Pour extraire une colonne d’un dataframe, on peut utiliser des crochets et faire référence au nom de la colonne (qui est indexée par les noms) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df_texte[<span class="st">&#39;weight&#39;</span>].head(<span class="dv">2</span>))</code></pre></div>
<pre><code>## a    115
## e    117
## Name: weight, dtype: int64</code></pre>
<p>En ayant sélectionné une seule colonne, on obtient une série (l’index du dataframe est conservé pour la série) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="bu">type</span>(df_texte[<span class="st">&#39;weight&#39;</span>]))</code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre>
<p>On peut également extraire une colonne en faisant référence à l’attribut du dataframe portant le nom de cette colonne :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df_texte.weight.head(<span class="dv">2</span>))</code></pre></div>
<pre><code>## a    115
## e    117
## Name: weight, dtype: int64</code></pre>
<p>Comme pour les séries, on peut s’appuyer sur les attributs <code>loc</code> et <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colone 2 (loc):</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[:,<span class="st">&quot;weight&quot;</span>])</code></pre></div>
<pre><code>## Colone 2 (loc):
##  a    115
## e    117
## c    120
## b    123
## d    126
## Name: weight, dtype: int64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colonne 2 (iloc):</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.iloc[:,<span class="dv">1</span>])</code></pre></div>
<pre><code>## Colonne 2 (iloc):
##  a    115
## e    117
## c    120
## b    123
## d    126
## Name: weight, dtype: int64</code></pre>
</div>
<div id="extraction-de-plusieurs-colonnes" class="section level4">
<h4><span class="header-section-number">10.2.2.6</span> Extraction de plusieurs colonnes</h4>
<p>Pour extraire plusieurs colonnes, il suffit de placer les noms des colonnes dans un tableau :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df_texte[[<span class="st">&quot;weight&quot;</span>, <span class="st">&quot;height&quot;</span>]])</code></pre></div>
<pre><code>##    weight  height
## a     115      58
## e     117      59
## c     120      60
## b     123      61
## d     126      62</code></pre>
<p>L’ordre dans lequel on appelle ces colonnes correspond à l’ordre dans lequel elles seront retournées.</p>
<p>À nouveau, on peut utuliser l’attribut <code>loc</code> (on utilise les deux points ici pour dire que l’on veut toutes les lignes) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colonnes de weight à height:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[:,[<span class="st">&quot;weight&quot;</span>, <span class="st">&quot;height&quot;</span>]])</code></pre></div>
<pre><code>## Colonnes de weight à height:
##     weight  height
## a     115      58
## e     117      59
## c     120      60
## b     123      61
## d     126      62</code></pre>
<p>Et l’attribut <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colonnes 2 et 1 :</span><span class="ch">\n</span><span class="st">&quot;</span>, df_num.iloc[:,[<span class="dv">1</span>,<span class="dv">0</span>]])</code></pre></div>
<pre><code>## Colonnes 2 et 1 :
##     weight  height
## 0     115      58
## 1     117      59
## 2     120      60
## 3     123      61
## 4     126      62</code></pre>
</div>
<div id="decoupage-df-colonnes" class="section level4">
<h4><span class="header-section-number">10.2.2.7</span> Découpage de plusieurs colonnes</h4>
<p>Pour effectuer un découpage, on peut utiliser les attributs <code>loc</code> et <code>iloc</code>. Attention, on ne place pas le nom des colonnes servant pour le découpage dans un tableau ici :</p>
<p>Avec <code>loc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colones 2 et 2:</span><span class="ch">\n</span><span class="st">&quot;</span>, df_texte.loc[:, <span class="st">&quot;height&quot;</span>:<span class="st">&quot;age&quot;</span>])</code></pre></div>
<pre><code>## Colones 2 et 2:
##     height  weight  age
## a      58     115   28
## e      59     117   33
## c      60     120   31
## b      61     123   31
## d      62     126   29</code></pre>
<p>Et avec l’attribut <code>iloc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Colonnes de la position 0 à 2 (non incluse) :</span><span class="ch">\n</span><span class="st">&quot;</span>, 
      df_texte.iloc[:, <span class="dv">0</span>:<span class="dv">2</span>])</code></pre></div>
<pre><code>## Colonnes de la position 0 à 2 (non incluse) :
##     height  weight
## a      58     115
## e      59     117
## c      60     120
## b      61     123
## d      62     126</code></pre>
</div>
<div id="extraction-de-lignes-et-colonnes" class="section level4">
<h4><span class="header-section-number">10.2.2.8</span> Extraction de lignes et colonnes</h4>
<p>À présent que nous avons passé en revue de nombreuses manières de sélectionner une ou plusieurs lignes ou colonnes, nous pouvons également mentionner qu’il est possible de faire des sélections de colonnes et de lignes dans une même instruction.</p>
<p>Par exemple, avec <code>iloc</code>, sélectionnons les lignes de la position 0 à la position 2 (non incluse) et les colonnes de la position 1 à 3 (non incluse) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df_texte.iloc[<span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">3</span>])</code></pre></div>
<pre><code>##    weight  age
## a     115   28
## e     117   33</code></pre>
<p>Avec <code>loc</code>, sélectionnons les lignes nommées <code>a</code> et <code>c</code> et les colonnes de celle nommée <code>weight</code> jusqu’à <code>age</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df_texte.loc[[<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>], <span class="st">&quot;weight&quot;</span>:<span class="st">&quot;age&quot;</span>]</code></pre></div>
</div>
</div>
</div>
<div id="renommage-des-colonnes-dans-un-dataframe" class="section level2">
<h2><span class="header-section-number">10.3</span> Renommage des colonnes dans un dataframe</h2>
<p>Pour renommer une colonne dans un dataframe, <code>pandas</code> propose la méthode <code>rename()</code>. Prenons un exemple avec notre dataframe <code>df</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158</code></pre>
<p>Renommons la colonne <code>height</code> en <code>taille</code>, à l’aide d’un dicionnaire précisé au paramètre <code>columns</code>, avec comme clé le nom actuel de la colonne, et en valeur le nouveau nom :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.rename(index<span class="op">=</span><span class="bu">str</span>, columns<span class="op">=</span>{<span class="st">&quot;height&quot;</span>: <span class="st">&quot;taille&quot;</span>}, inplace<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    taille  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158</code></pre>
<p>Pour que le changement soit effectif, on indique <code>inplace=True</code>, sinon, la modification n’est pas apportée au dataframe.</p>
<p>Pour renommer plusieurs colonnes en même temps, il suffit de fournir plusieurs couples de clés valeurs dans le dictionnaire :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.rename(index<span class="op">=</span><span class="bu">str</span>,
          columns<span class="op">=</span>{<span class="st">&quot;weight&quot;</span>: <span class="st">&quot;masse&quot;</span>, <span class="st">&quot;age&quot;</span> : <span class="st">&quot;annees&quot;</span>},
          inplace<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    taille  masse  annees  taille
## 0      58    115      28     162
## 1      59    117      33     156
## 2      60    120      31     172
## 3      61    123      31     160
## 4      62    126      29     158</code></pre>
</div>
<div id="filtrage" class="section level2">
<h2><span class="header-section-number">10.4</span> Filtrage</h2>
<p>Pour effectuer une filtration des données dans un tableau, en fonction des valeurs rencontrées pour certaines variables, on utilise des masques, comme indiqué dans la Section <a href="pandas.html#masque-extraction-ligne">10.2.2.4</a>.</p>
<p>Redennons quelques exemples ici, en redéfinissant notre dataframe :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    height  weight  age  taille
## 0      58     115   28     162
## 1      59     117   33     156
## 2      60     120   31     172
## 3      61     123   31     160
## 4      62     126   29     158</code></pre>
<p>L’idée consiste à créer un masque retournant une série contenant des valeurs booléennes, une par ligne. Lorsque la valeur de la ligne du masque vaut <code>True</code>, la ligne du dataframe sur lequel sera appliqué le masque sera retenue, tandis qu’elle ne le sera pas quand la valeur de la ligne du masque vaut <code>False</code>.</p>
<p>Regardons un exemple simple, dans lequel nous souhaitons conserver les observations uniquement pour lesquelles la valeur de la variable <code>age</code> est inférieure à 30 :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">masque <span class="op">=</span> df[<span class="st">&quot;age&quot;</span>] <span class="op">&lt;</span> <span class="dv">30</span>
<span class="bu">print</span>(masque)</code></pre></div>
<pre><code>## 0     True
## 1    False
## 2    False
## 3    False
## 4     True
## Name: age, dtype: bool</code></pre>
<p>Il reste alors à appliquer ce masque, avec <code>loc</code>. On souhaite l’ensemble des colonnes, mais seulement quelques lignes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.loc[masque])</code></pre></div>
<pre><code>##    height  weight  age  taille
## 0      58     115   28     162
## 4      62     126   29     158</code></pre>
<p>Note : cela fonctionne aussi sans <code>loc</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df[masque])</code></pre></div>
<pre><code>##    height  weight  age  taille
## 0      58     115   28     162
## 4      62     126   29     158</code></pre>
<p>Plus simplement, on peut utiliser la méthode <code>query()</code> de <code>pandas</code>. On fournit une expression booléenne à évaluer à cette méthode pour filtrer les données :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.query(age<span class="op">&lt;</span><span class="dv">30</span>))</code></pre></div>
<pre><code>## NameError: name &#39;age&#39; is not defined
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<p>La requête peut être un peu plus complexe, en combinant opérateurs de comparaison (c.f. Section <a href="operateurs.html#operateurs-comparaison">4.2</a>) et opérateurs logiques (c.f. Section <a href="operateurs.html#operateurs-logiques">4.3</a>). Par exemple, admettons que nous voulons filtrer les valeurs du dataframe pour ne retenir que les observations pour lesquelles la taille est inférieure ou égale à 62 et la masse strictement supérieure à 120. La requête serait alors :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.query(<span class="st">&quot;weight &gt; 120 and height &lt; 62&quot;</span>))</code></pre></div>
<pre><code>##    height  weight  age  taille
## 3      61     123   31     160</code></pre>
<p>On peut noter que l’instruction suivante donne le même résultat :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.query(<span class="st">&quot;weight &gt; 120&quot;</span>).query(<span class="st">&quot;height &lt; 62&quot;</span>))</code></pre></div>
<pre><code>##    height  weight  age  taille
## 3      61     123   31     160</code></pre>
<div id="test-dappartenance-2" class="section level3">
<h3><span class="header-section-number">10.4.1</span> Test d’appartenance</h3>
<p>Pour créer un masque indiquant si les valeurs d’une série ou d’un dataframe appartiennent à un ensemble, on peut utiliser la méthode <code>isin()</code>. Par exemple, retournons un masque indiquant si les valeurs de la colonne <code>height</code> de <code>df</code> sont dans l’intervalle <span class="math inline">\([59,60]\)</span> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.height.isin(np.arange(<span class="dv">59</span>,<span class="dv">61</span>))</code></pre></div>
</div>
</div>
<div id="valeurs-manquantes" class="section level2">
<h2><span class="header-section-number">10.5</span> Valeurs manquantes</h2>
<p>En économie, il est assez fréquent de récupérer des données incomplètes. La manière dont les données manquantes sont gérées par <code>pandas</code> est le recours aux deux valeurs spéciales : <code>None</code> et <code>NaN</code>.</p>
<p>La valeur <code>None</code> peut être utilisée dans les tableaux <code>NumPy</code> uniquement quand le type de ces derniers est <code>object</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tableau_none <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="va">None</span>])
<span class="bu">print</span>(tableau_none)</code></pre></div>
<pre><code>## [1 4 -1 None]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="bu">type</span>(tableau_none))</code></pre></div>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<p>Avec un tableau de type <code>object</code>, les opérations effectuées sur les données seront moins efficaces qu’avec un tableau d’un type numérique <span class="citation">(VanderPlas <a href="#ref-vanderplas2016python">2016</a>, p 121)</span>.</p>
<p>La valeur <code>NaN</code> est une valeur de nombre à virgule flottante (c.f. Section <a href="#numpy-constantes"><strong>??</strong></a>). <code>NumPy</code> la gère différemment de <code>NaN</code>, et n’assigne passe type <code>object</code> d’emblée en présence de <code>NaN</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tableau_nan <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan])
<span class="bu">print</span>(tableau_nan)</code></pre></div>
<pre><code>## [ 1.  4. -1. nan]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="bu">type</span>(tableau_nan))</code></pre></div>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<p>Avec <code>pandas</code>, ces deux valeurs, <code>None</code> et <code>NaN</code> peuvent être présentes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="va">None</span>, <span class="op">-</span><span class="dv">1</span>, np.nan])
<span class="bu">print</span>(s)</code></pre></div>
<pre><code>## 0    1.0
## 1    NaN
## 2   -1.0
## 3    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="bu">type</span>(s))</code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre>
<p>Cela tient aussi pour les tableaux :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, np.nan],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, np.nan, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    height  weight   age  taille
## 0    58.0     115  28.0     162
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158</code></pre>
<p>On note toutefois que seule le type des variables pour lesquelles existent des valeurs manquantes sont passées en <code>float64</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.dtypes)</code></pre></div>
<pre><code>## height    float64
## weight      int64
## age       float64
## taille      int64
## dtype: object</code></pre>

<div class="remarque">
On note que les données sont enregistrées sur un type <code>float64</code>. Lorsqu’on travaille sur un tableau ne comportant pas de valeurs manquantes, dont le type est <code>int</code> ou <code>bool</code>, si on introduit une valeur manquante, <code>pandas</code> changera le type des données en <code>float64</code> et <code>object</code>, respectivement.
</div>

<p><code>pandas</code> propose différentes pour manipuler les valeurs manquantes.</p>
<div id="reperer-les-valeurs-manquantes" class="section level3">
<h3><span class="header-section-number">10.5.1</span> Repérer les valeurs manquantes</h3>
<p>Avec la méthode <code>isnull()</code>, un masque de booléens est retournée, indiquant <code>True</code> pour les observations dont la valeur est <code>NaN</code> ou <code>None</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(s.isnull())</code></pre></div>
<pre><code>## 0    False
## 1     True
## 2    False
## 3     True
## dtype: bool</code></pre>
<p>Pour savoir si une valeur n’est pas nulle, on dispose de la méthode <code>notnull()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(s.notnull())</code></pre></div>
<pre><code>## 0     True
## 1    False
## 2     True
## 3    False
## dtype: bool</code></pre>
</div>
<div id="retirer-les-observations-avec-valeurs-manquantes" class="section level3">
<h3><span class="header-section-number">10.5.2</span> Retirer les observations avec valeurs manquantes</h3>
<p>La méthode <code>dropna()</code> permet quant à elle de retirer les observations disposant de valeurs nulles :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.dropna())</code></pre></div>
<pre><code>##    height  weight   age  taille
## 0    58.0     115  28.0     162
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172</code></pre>
</div>
<div id="retirer-les-valeurs-manquantes-par-dautres-valeurs" class="section level3">
<h3><span class="header-section-number">10.5.3</span> Retirer les valeurs manquantes par d’autres valeurs</h3>
<p>Pour remplacer les valeurs manquantes par d’autres valeurs, <code>pandas</code> propose d’utiliser la méthode <code>fillna()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.fillna(<span class="op">-</span><span class="dv">9999</span>))</code></pre></div>
<pre><code>##    height  weight     age  taille
## 0    58.0     115    28.0     162
## 1    59.0     117    33.0     156
## 2    60.0     120    31.0     172
## 3    61.0     123 -9999.0     160
## 4 -9999.0     126    29.0     158</code></pre>
</div>
</div>
<div id="suppressions" class="section level2">
<h2><span class="header-section-number">10.6</span> Suppressions</h2>
<p>Pour supprimer une valeur sur un des axes d’une série ou d’un dataframe, <code>NumPy</code> propose la méthode <code>drop()</code>.</p>
<div id="suppression-delements-dans-une-serie" class="section level3">
<h3><span class="header-section-number">10.6.1</span> Suppression d’éléments dans une série</h3>
<p>Pour illustrer le fonctionnement de la méthode <code>drop()</code>, créons une série avec un index numérique, une autre avec un index textuel :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>])
s_texte <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>])</code></pre></div>
<p>On peut supprimer un élément d’une série en utilisant son nom :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pour s_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.drop(<span class="dv">5</span>))</code></pre></div>
<pre><code>## pour s_num : 
##  0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">pour s_texte : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.drop(<span class="st">&quot;c&quot;</span>))</code></pre></div>
<pre><code>## 
## pour s_texte : 
##  a    4.0
## b   -1.0
## d    NaN
## dtype: float64</code></pre>
<p>On peut aussi aller récupérer le nom en fonction de la position, en passant par un détour en utilisant la méthode <code>index()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pritn(s.drop(s_num.index[<span class="dv">0</span>]))</code></pre></div>
<pre><code>## NameError: name &#39;pritn&#39; is not defined
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;s_num.index[0] : &quot;</span>, s_num.index[<span class="dv">0</span>])</code></pre></div>
<pre><code>## s_num.index[0] :  5</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;s_texte.index[0] : &quot;</span>, s_texte.index[<span class="dv">0</span>])</code></pre></div>
<pre><code>## s_texte.index[0] :  c</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pour s_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.drop(s_num.index[<span class="dv">0</span>]))</code></pre></div>
<pre><code>## pour s_num : 
##  0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">pour s_texte : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.drop(s_texte.index[<span class="dv">0</span>]))</code></pre></div>
<pre><code>## 
## pour s_texte : 
##  a    4.0
## b   -1.0
## d    NaN
## dtype: float64</code></pre>
<p>Pour supprimer plusieurs éléments, il suffit de fournir plusieurs noms d’indice dans une liste à la méthode <code>drop()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pour s_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.drop([<span class="dv">5</span>, <span class="dv">4</span>]))</code></pre></div>
<pre><code>## pour s_num : 
##  0    4.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">pour s_texte : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.drop([<span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>]))</code></pre></div>
<pre><code>## 
## pour s_texte : 
##  a    4.0
## d    NaN
## dtype: float64</code></pre>
<p>À nouveau, on peut aller récupérer le nom en fonction de la position, en passant par un détour en utilisant la méthode <code>index()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pritn(s.drop(s_num.index[<span class="dv">0</span>]))</code></pre></div>
<pre><code>## NameError: name &#39;pritn&#39; is not defined
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;s_num.index[[0,2]] : &quot;</span>, s_num.index[[<span class="dv">0</span>,<span class="dv">2</span>]])</code></pre></div>
<pre><code>## s_num.index[[0,2]] :  Int64Index([5, 4], dtype=&#39;int64&#39;)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;s_texte.index[[0,2]] : &quot;</span>, s_texte.index[[<span class="dv">0</span>,<span class="dv">2</span>]])</code></pre></div>
<pre><code>## s_texte.index[[0,2]] :  Index([&#39;c&#39;, &#39;b&#39;], dtype=&#39;object&#39;)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pour s_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num.drop(s_num.index[[<span class="dv">0</span>,<span class="dv">2</span>]]))</code></pre></div>
<pre><code>## pour s_num : 
##  0    4.0
## 1    NaN
## dtype: float64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">pour s_texte : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_texte.drop(s_texte.index[[<span class="dv">0</span>,<span class="dv">2</span>]]))</code></pre></div>
<pre><code>## 
## pour s_texte : 
##  a    4.0
## d    NaN
## dtype: float64</code></pre>
<p>Il est possible d’utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Section <a href="pandas.html#decoupage-series">10.2.1.2.3</a>)</p>
</div>
<div id="suppression-delements-dans-un-dataframe" class="section level3">
<h3><span class="header-section-number">10.6.2</span> Suppression d’éléments dans un dataframe</h3>
<p>Pour illustrer le fonctionnement de la méthode <code>drop()</code> sur un dataframe, créons-en un :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>])
s_texte <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>])
dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, np.nan],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, np.nan, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)</code></pre></div>
<div id="suppressions-de-lignes" class="section level4">
<h4><span class="header-section-number">10.6.2.1</span> Suppressions de lignes</h4>
<p>Pour supprimer une ligne d’un dataframe, on peut faire référence à son nom (ici, les noms sont des numéros, mais ce sont bien des labels) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Supprimer la première ligne :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(<span class="dv">0</span>))</code></pre></div>
<pre><code>## Supprimer la première ligne :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158</code></pre>
<p>Si les lignes ont des labels textuels, on peut au préalable aller les récupérer à l’aide de la méthode <code>index()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">label_pos_0 <span class="op">=</span> df.index[<span class="dv">0</span>]
<span class="bu">print</span>(<span class="st">&quot;Supprimer la première ligne :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(label_pos_0))</code></pre></div>
<pre><code>## Supprimer la première ligne :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 3    61.0     123   NaN     160
## 4     NaN     126  29.0     158</code></pre>
<p>Pour supprimer plusieurs lignes, on donne le nom de ces lignes dans une liste à la méthode <code>drop()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Supprimer les 1ère et 4e lignes :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop([<span class="dv">0</span>,<span class="dv">3</span>]))</code></pre></div>
<pre><code>## Supprimer les 1ère et 4e lignes :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 4     NaN     126  29.0     158</code></pre>
<p>Ou encore, en indiquant les positions des lignes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">label_pos <span class="op">=</span> df.index[[<span class="dv">0</span>, <span class="dv">3</span>]]
<span class="bu">print</span>(<span class="st">&quot;Supprimer les 1ère et 4e lignes :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(label_pos))</code></pre></div>
<pre><code>## Supprimer les 1ère et 4e lignes :  
##     height  weight   age  taille
## 1    59.0     117  33.0     156
## 2    60.0     120  31.0     172
## 4     NaN     126  29.0     158</code></pre>
<p>Il est possible d’utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Sections <a href="pandas.html#decoupage-df-lignes">10.2.2.3</a> et <a href="pandas.html#decoupage-df-colonnes">10.2.2.7</a>)</p>
</div>
<div id="suppressions-de-colonnes" class="section level4">
<h4><span class="header-section-number">10.6.2.2</span> Suppressions de colonnes</h4>
<p>Pour supprimer une colonne d’un dataframe, on procède de la même manière que pour les lignes, mais en ajoutant le paramètre <code>axis=1</code> à la méthode <code>drop()</code> pour préciser que l’on s’intéresse aux colonnes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Supprimer la première colonne :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(<span class="st">&quot;height&quot;</span>, axis<span class="op">=</span><span class="dv">1</span>))</code></pre></div>
<pre><code>## Supprimer la première colonne :  
##     weight   age  taille
## 0     115  28.0     162
## 1     117  33.0     156
## 2     120  31.0     172
## 3     123   NaN     160
## 4     126  29.0     158</code></pre>
<p>On peut au préalable aller récupérer les labels des colonnes en fonction de leur position à l’aide de la méthode <code>columns()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">label_pos <span class="op">=</span> df.columns[<span class="dv">0</span>]
<span class="bu">print</span>(<span class="st">&quot;label_pos : &quot;</span>, label_pos)</code></pre></div>
<pre><code>## label_pos :  height</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Supprimer la première colonne :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(label_pos, axis<span class="op">=</span><span class="dv">1</span>))</code></pre></div>
<pre><code>## Supprimer la première colonne :  
##     weight   age  taille
## 0     115  28.0     162
## 1     117  33.0     156
## 2     120  31.0     172
## 3     123   NaN     160
## 4     126  29.0     158</code></pre>
<p>Pour supprimer plusieurs colonnes, on donne le nom de ces colonnes dans une liste à la méthode <code>drop()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;Supprimer les 1ère et 4e colonnes :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop([<span class="st">&quot;height&quot;</span>, <span class="st">&quot;taille&quot;</span>], axis <span class="op">=</span> <span class="dv">1</span>))</code></pre></div>
<pre><code>## Supprimer les 1ère et 4e colonnes :  
##     weight   age
## 0     115  28.0
## 1     117  33.0
## 2     120  31.0
## 3     123   NaN
## 4     126  29.0</code></pre>
<p>Ou encore, en indiquant les positions des colonnes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">label_pos <span class="op">=</span> df.columns[[<span class="dv">0</span>, <span class="dv">3</span>]]
<span class="bu">print</span>(<span class="st">&quot;Supprimer les 1ère et 4e colonnes :  </span><span class="ch">\n</span><span class="st">&quot;</span>, df.drop(label_pos, axis<span class="op">=</span><span class="dv">1</span>))</code></pre></div>
<pre><code>## Supprimer les 1ère et 4e colonnes :  
##     weight   age
## 0     115  28.0
## 1     117  33.0
## 2     120  31.0
## 3     123   NaN
## 4     126  29.0</code></pre>
<p>Il est possible d’utiliser un découpage également pour obtenir la série sans le ou les éléments (c.f. Sections <a href="pandas.html#decoupage-df-lignes">10.2.2.3</a> et <a href="pandas.html#decoupage-df-colonnes">10.2.2.7</a>)</p>
</div>
</div>
</div>
<div id="remplacement-de-valeurs" class="section level2">
<h2><span class="header-section-number">10.7</span> Remplacement de valeurs</h2>
<p>Nous allons à présent regarder comment modifier une ou plusieurs valeurs, dans le cas d’une série puis d’un dataframe.</p>
<div id="pour-une-serie" class="section level3">
<h3><span class="header-section-number">10.7.1</span> Pour une série</h3>
<p>Pour modifier une valeur particulière dans une série ou dans un dataframe, on peut utiliser le symbole égale (<code>=</code>) en ayant au préalable ciblé l’emplacement de la valeur à modifier, à l’aide des techniques d’extraction expliquées dans la Section <a href="pandas.html#pandas-selection">10.2</a>.</p>
<p>Par exemple, considérons la série suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>])
<span class="bu">print</span>(<span class="st">&quot;s_num : &quot;</span>, s_num)</code></pre></div>
<pre><code>## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64</code></pre>
<p>Modifions le deuxième élément élément de <code>s_num</code>, pour lui donner la valeur -3 :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num.iloc[<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">3</span>
<span class="bu">print</span>(<span class="st">&quot;s_num : &quot;</span>, s_num)</code></pre></div>
<pre><code>## s_num :  5    1.0
## 0   -3.0
## 4   -1.0
## 1    NaN
## dtype: float64</code></pre>
<p>Il est évidemment possible de modifier plusieurs valeurs à la fois.</p>
<p>Il suffit à nouveau de cibler les positions (on peu utiliser de nombreuses manières de le faire) et de fournir un objet de dimensions équivalentes pour venir remplacer les valeurs ciblées. Par exemple, dans notre série <code>s_num</code>, allons remplacer les valeurs en position 1 et 3 (2e et 4e valeurs) par -10 et -9 :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num.iloc[[<span class="dv">1</span>,<span class="dv">3</span>]] <span class="op">=</span> [<span class="op">-</span><span class="dv">10</span>, <span class="op">-</span><span class="dv">9</span>]
<span class="bu">print</span>(s_num)</code></pre></div>
<pre><code>## 5     1.0
## 0   -10.0
## 4    -1.0
## 1    -9.0
## dtype: float64</code></pre>
</div>
<div id="pour-un-dataframe" class="section level3">
<h3><span class="header-section-number">10.7.2</span> Pour un dataframe</h3>
<p>Considérons le dataframe suivant :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;ville&quot;</span> : [<span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>,
                   <span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>, <span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Paris&quot;</span>],
        <span class="st">&quot;annee&quot;</span>: [<span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2018</span>, <span class="dv">2018</span>,<span class="dv">2019</span>, <span class="dv">2019</span>],
        <span class="st">&quot;x&quot;</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>],
        <span class="st">&quot;y&quot;</span>: [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4</code></pre>
<div id="modifications-dune-valeur-particuliere" class="section level4">
<h4><span class="header-section-number">10.7.2.1</span> Modifications d’une valeur particulière</h4>
<p>Modifions la valeur de la première ligne de <code>df</code> pour la colonne <code>annee</code>, pour que celle-ci vaille 2020. Dans un premier temps, récupérons la position de la colonne <code>annee</code> dans le dataframe, à l’aide de la méthode <code>get_loc()</code> appliquée à l’attribut <code>colnames</code> du dataframe :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pos_annee <span class="op">=</span> df.columns.get_loc(<span class="st">&quot;annee&quot;</span>)
<span class="bu">print</span>(<span class="st">&quot;pos_annee : &quot;</span>, pos_annee)</code></pre></div>
<pre><code>## pos_annee :  1</code></pre>
<p>Ensuite, effectuons la modification :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.iloc[<span class="dv">0</span>,pos_annee] <span class="op">=</span> <span class="dv">2020</span>
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4</code></pre>
</div>
<div id="modifications-sur-une-ou-plusieurs-colonnes" class="section level4">
<h4><span class="header-section-number">10.7.2.2</span> Modifications sur une ou plusieurs colonnes</h4>
<p>Pour modifier toutes les valeurs d’une colonne pour y placer une valeur particulière, par exemple un 2 dans la colonne <code>x</code> de <code>df</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.x <span class="op">=</span> <span class="dv">2</span>
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  2  4
## 5      Paris   2019  2  4</code></pre>
<p>On peut également modifier les valeurs de la colonne en fournissant une liste de valeurs :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.x <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  3
## 1        Aix   2019  3  3
## 2  Marseille   2018  4  2
## 3        Aix   2018  2  1
## 4      Paris   2019  1  4
## 5      Paris   2019  0  4</code></pre>
<p>On peut donc imaginer modifier les valeurs d’une colonne en fonction des valeurs que l’on lit dans une autre colonne. Par exemple, admettons le code suivant : si la valeur de <code>y</code> vaut 2, alors celle de x vaut “a”, si la valeur de <code>y</code> vaut 1, lors celle de <code>x</code> vaut “b”, sinon, elle vaut <code>NaN</code>. Dans un premier temps, construisons une liste contenant les valeurs à insérer (que nous nommerons <code>nv_val</code>), à l’aide d’une boucle. Nous allons parcourir tous les éléments de la colonne <code>y</code>, et à chaque itération ajouter à <code>nv_val</code> la valeur obtenue en effectuant nos comparaisons :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nv_val <span class="op">=</span> []
<span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="bu">len</span>(df.index)):
        <span class="cf">if</span> df.y[i] <span class="op">==</span> <span class="dv">2</span>:
            nv_val.append(<span class="st">&quot;a&quot;</span>)
        <span class="cf">elif</span> df.y[i] <span class="op">==</span> <span class="dv">1</span>:
            nv_val.append(<span class="st">&quot;b&quot;</span>)
        <span class="cf">else</span>:
            nv_val.append(np.nan)
<span class="bu">print</span>(<span class="st">&quot;nv_val : &quot;</span>, nv_val)</code></pre></div>
<pre><code>## nv_val :  [nan, nan, &#39;a&#39;, &#39;b&#39;, nan, nan]</code></pre>
<p>Nous sommes prêts à modifier le contenu de la colonne <code>x</code> de <code>df</code> pour le remplacer par <code>nv_val</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.x <span class="op">=</span> nv_val
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee    x  y
## 0  Marseille   2020  NaN  3
## 1        Aix   2019  NaN  3
## 2  Marseille   2018    a  2
## 3        Aix   2018    b  1
## 4      Paris   2019  NaN  4
## 5      Paris   2019  NaN  4</code></pre>
<p>Pour remplacer plusieurs colonnes en même temps :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df[[<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>]] <span class="op">=</span> [[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>], <span class="dv">1</span>]
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1        Aix   2019  3  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1</code></pre>
<p>Dans l’instruction précédente, nous avons remplacé le contenu des colonnes <code>x</code> et <code>y</code> par une vecteur de valeurs écrites à la main pour <code>x</code> et par la valeur 1 pour toutes les observations pour <code>y</code>.</p>
</div>
<div id="modifications-sur-une-ou-plusieurs-lignes" class="section level4">
<h4><span class="header-section-number">10.7.2.3</span> Modifications sur une ou plusieurs lignes</h4>
<p>Pour remplacer une ligne par une valeur constante (peu d’intérêt ici) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.iloc[<span class="dv">1</span>,:] <span class="op">=</span> <span class="dv">1</span>
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1          1      1  1  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1</code></pre>
<p>Il peut être plus intéressant de remplacer une observation comme suit :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.iloc[<span class="dv">1</span>,:] <span class="op">=</span> [<span class="st">&quot;Aix&quot;</span>, <span class="dv">2018</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<pre><code>## ValueError: Must have equal len keys and value when setting with an iterable
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/indexing.py&quot;, line 189, in __setitem__
##     self._setitem_with_indexer(indexer, value)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/indexing.py&quot;, line 606, in _setitem_with_indexer
##     raise ValueError(&#39;Must have equal len keys and value &#39;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1          1      1  1  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1</code></pre>
<p>Pour remplacer plusieurs lignes, la méthode est identique :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.iloc[[<span class="dv">1</span>,<span class="dv">3</span>],:] <span class="op">=</span> [
    [<span class="st">&quot;Aix&quot;</span>, <span class="dv">2018</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],
    [<span class="st">&quot;Aix&quot;</span>, <span class="dv">2018</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]
]</code></pre></div>
<pre><code>## ValueError: Must have equal len keys and value when setting with an ndarray
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 3, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/indexing.py&quot;, line 189, in __setitem__
##     self._setitem_with_indexer(indexer, value)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/indexing.py&quot;, line 590, in _setitem_with_indexer
##     raise ValueError(&#39;Must have equal len keys and value &#39;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2020  2  1
## 1          1      1  1  1
## 2  Marseille   2018  4  1
## 3        Aix   2018  2  1
## 4      Paris   2019  1  1
## 5      Paris   2019  0  1</code></pre>
</div>
</div>
</div>
<div id="pandas-ajout-valeurs" class="section level2">
<h2><span class="header-section-number">10.8</span> Ajout de valeurs</h2>
<p>Regardons à présent comment ajouter des valeurs, dans une série d’abord, puis dans un dataframe.</p>
<div id="pour-une-serie-1" class="section level3">
<h3><span class="header-section-number">10.8.1</span> Pour une série</h3>
<p>Considérons la série suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, np.nan],
             index <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>])
<span class="bu">print</span>(<span class="st">&quot;s_num : &quot;</span>, s_num)</code></pre></div>
<pre><code>## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## dtype: float64</code></pre>
<div id="ajout-dune-seule-valeur-dans-une-serie" class="section level4">
<h4><span class="header-section-number">10.8.1.1</span> Ajout d’une seule valeur dans une série</h4>
<p>Pour ajouter une valeur, on utlise la méthode <code>append()</code>. Ici, avec <code>s_num</code>, comme l’index est manuel, nous sommes obligé de fournir une série avec une valeur pour l’index également :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num_2 <span class="op">=</span> pd.Series([<span class="dv">1</span>], index <span class="op">=</span> [<span class="dv">2</span>])
<span class="bu">print</span>(<span class="st">&quot;s_num_2 : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num_2)</code></pre></div>
<pre><code>## s_num_2 : 
##  2    1
## dtype: int64</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num <span class="op">=</span> s_num.append(s_num_2)
<span class="bu">print</span>(<span class="st">&quot;s_num : </span><span class="ch">\n</span><span class="st">&quot;</span>, s_num)</code></pre></div>
<pre><code>## s_num : 
##  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## 2    1.0
## dtype: float64</code></pre>
<p>On note que la méthode <code>append()</code> retourne une vue, et que pour répercuter l’ajout, il est nécessaire d’effectuer une nouvelle assignation.</p>
<p>En ayant une série avec un index numérique généré automatiquement, on peut préciser la valeur <code>True</code> pour le paramètre <code>ignore_index</code> de la méthode <code>append()</code> pour indiquer de ne pas tenir compte de la valeur de l’index de l’objet que l’on ajoute :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">10</span>, <span class="dv">2</span>, <span class="dv">4</span>])
s <span class="op">=</span> s.append(pd.Series([<span class="dv">2</span>]), ignore_index<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span>(<span class="st">&quot;s : </span><span class="ch">\n</span><span class="st">&quot;</span>, s)</code></pre></div>
<pre><code>## s : 
##  0    10
## 1     2
## 2     4
## 3     2
## dtype: int64</code></pre>
</div>
<div id="ajout-de-plusieurs-valeurs-dans-une-serie" class="section level4">
<h4><span class="header-section-number">10.8.1.2</span> Ajout de plusieurs valeurs dans une série</h4>
<p>Pour ajouter plusieurs valeurs, on utlise la méthode <code>append()</code>. Ici, avec <code>s_num</code>, comme l’index est manuel, nous sommes obligé de fournir une série avec une valeur pour l’index également :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s_num_2 <span class="op">=</span> pd.Series([<span class="dv">1</span>], index <span class="op">=</span> [<span class="dv">2</span>])
s_num.append(s_num_2)
<span class="bu">print</span>(<span class="st">&quot;s_num : &quot;</span>, s_num)</code></pre></div>
<pre><code>## s_num :  5    1.0
## 0    4.0
## 4   -1.0
## 1    NaN
## 2    1.0
## dtype: float64</code></pre>
<p>En ayant une série avec un index numérique généré automatiquement :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> pd.Series([<span class="dv">10</span>, <span class="dv">2</span>, <span class="dv">4</span>])
s.append(pd.Series([<span class="dv">2</span>]), ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
</div>
</div>
<div id="pour-un-dataframe-1" class="section level3">
<h3><span class="header-section-number">10.8.2</span> Pour un dataframe</h3>
<p>Reprenons notre dataframe :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;ville&quot;</span> : [<span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>,
                   <span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>, <span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Paris&quot;</span>],
        <span class="st">&quot;annee&quot;</span>: [<span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2018</span>, <span class="dv">2018</span>,<span class="dv">2019</span>, <span class="dv">2019</span>],
        <span class="st">&quot;x&quot;</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>],
        <span class="st">&quot;y&quot;</span>: [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4</code></pre>
<div id="pandas-ajout-ligne-df" class="section level4">
<h4><span class="header-section-number">10.8.2.1</span> Ajout d’une ligne dans un dataframe</h4>
<p>Comme pour une série, pour ajouter une ligne, on utlise la méthode <code>append()</code>. Dans un premier temps, créons un nouveau dataframe avec la ligne à ajouter :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nv_ligne <span class="op">=</span> pd.DataFrame([[<span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;2021&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>]],
                       columns <span class="op">=</span> df.columns)
<span class="bu">print</span>(<span class="st">&quot;nv_ligne : </span><span class="ch">\n</span><span class="st">&quot;</span>, nv_ligne)</code></pre></div>
<pre><code>## nv_ligne : 
##         ville annee  x  y
## 0  Marseille  2021  2  4</code></pre>
<p>On s’est assuré d’avoir le même nom de colonnes ici, en indiquant au paramètre <code>columns</code> de la méthode <code>pd.DataFrame</code> le nom des colonnes de <code>df</code>, c’est-à-dire <code>df.columns</code>.</p>
<p>Ajoutons la nouvelle ligne à <code>df</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df.append(nv_ligne, ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p>À nouveau,la méthode <code>append()</code> appliquée à un dataframe, retourne une vue et n’affecte pas l’objet.</p>
<p>On peut noter que lors de l’ajout d’une ligne, si le nom des colonnes n’est pas indiqué dans le même ordre que dans le dataframe dans lequel est effectué l’ajout, il faut rajouter une indication au paramètre <code>sort</code> de la méthode <code>append()</code> :</p>
<ul>
<li>si <code>sort=True</code>, l’ordre des colonnes de la ligne ajoutée sera appliqué au dataframe de destination ;</li>
<li>si <code>sort=False</code>, l’odre des colonnes du dataframe de destination ne sera pas modifié.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nv_ligne <span class="op">=</span> pd.DataFrame([[<span class="st">&quot;2021&quot;</span>, <span class="st">&quot;Marseille&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>]],
                       columns <span class="op">=</span> [<span class="st">&quot;annee&quot;</span>, <span class="st">&quot;ville&quot;</span>, <span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;nv_ligne : </span><span class="ch">\n</span><span class="st">&quot;</span>, nv_ligne)</code></pre></div>
<pre><code>## nv_ligne : 
##    annee      ville  x  y
## 0  2021  Marseille  2  4</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;avec sort=True : </span><span class="ch">\n</span><span class="st">&quot;</span>, 
  df.append(nv_ligne, ignore_index<span class="op">=</span><span class="va">True</span>, sort <span class="op">=</span> <span class="va">True</span>))</code></pre></div>
<pre><code>## avec sort=True : 
##    annee      ville  x  y
## 0  2019  Marseille  1  3
## 1  2019        Aix  2  3
## 2  2018  Marseille  2  2
## 3  2018        Aix  2  1
## 4  2019      Paris  0  4
## 5  2019      Paris  0  4
## 6  2021  Marseille  2  4
## 7  2021  Marseille  2  4</code></pre>
</div>
<div id="ajout-de-plusieurs-lignes-dans-un-dataframe" class="section level4">
<h4><span class="header-section-number">10.8.2.2</span> Ajout de plusieurs lignes dans un dataframe</h4>
<p>Pour ajouter plusieurs lignes, c’est exactement le même principe qu’avec une seule, il suffit juste d’ajouter un dataframe de plusieurs lignes, avec encore une fois les mêmes noms.</p>
<p>Les lignes à insérer :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nv_lignes <span class="op">=</span> pd.DataFrame([
    [<span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;2022&quot;</span>, <span class="dv">2</span>, <span class="dv">4</span>],
    [<span class="st">&quot;Aix&quot;</span>, <span class="st">&quot;2022&quot;</span>, <span class="dv">3</span>, <span class="dv">3</span>]],
    columns <span class="op">=</span> df.columns)
<span class="bu">print</span>(<span class="st">&quot;nv_ligne : </span><span class="ch">\n</span><span class="st">&quot;</span>, nv_lignes)</code></pre></div>
<pre><code>## nv_ligne : 
##         ville annee  x  y
## 0  Marseille  2022  2  4
## 1        Aix  2022  3  3</code></pre>
<p>Puis l’insertion :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df.append(nv_lignes, ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
</div>
<div id="ajout-dune-colonne-dans-un-dataframe" class="section level4">
<h4><span class="header-section-number">10.8.2.3</span> Ajout d’une colonne dans un dataframe</h4>
<p>Pour ajouter une colonne dans un dataframe, on utilise la méthode <code>assign()</code>, en indiquant le nom et les valeurs.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> numpy <span class="im">import</span> random
df <span class="op">=</span> df.assign(z <span class="op">=</span> random.rand(<span class="bu">len</span>(df.index)))
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville annee  x  y         z
## 0  Marseille  2019  1  3  0.117443
## 1        Aix  2019  2  3  0.393782
## 2  Marseille  2018  2  2  0.452730
## 3        Aix  2018  2  1  0.538148
## 4      Paris  2019  0  4  0.790622
## 5      Paris  2019  0  4  0.465836
## 6  Marseille  2021  2  4  0.435332
## 7  Marseille  2022  2  4  0.569479
## 8        Aix  2022  3  3  0.969259</code></pre>
</div>
<div id="ajout-de-plusieurs-colonnes-dans-un-dataframe" class="section level4">
<h4><span class="header-section-number">10.8.2.4</span> Ajout de plusieurs colonnes dans un dataframe</h4>
<p>Pour ajouter plusieurs colonnes, le même principe s’applique :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df.assign(a <span class="op">=</span> random.rand(<span class="bu">len</span>(df.index)),
          b <span class="op">=</span> random.rand(<span class="bu">len</span>(df.index)))
<span class="bu">print</span>(<span class="st">&quot;df : </span><span class="ch">\n</span><span class="st">&quot;</span>, df)</code></pre></div>
<pre><code>## df : 
##         ville annee  x  y         z         a         b
## 0  Marseille  2019  1  3  0.117443  0.040556  0.689236
## 1        Aix  2019  2  3  0.393782  0.548120  0.929546
## 2  Marseille  2018  2  2  0.452730  0.462577  0.918117
## 3        Aix  2018  2  1  0.538148  0.376472  0.975302
## 4      Paris  2019  0  4  0.790622  0.327912  0.397002
## 5      Paris  2019  0  4  0.465836  0.813529  0.262626
## 6  Marseille  2021  2  4  0.435332  0.646552  0.430151
## 7  Marseille  2022  2  4  0.569479  0.047426  0.764531
## 8        Aix  2022  3  3  0.969259  0.994958  0.599731</code></pre>
</div>
</div>
</div>
<div id="retrait-des-valeurs-dupliquees" class="section level2">
<h2><span class="header-section-number">10.9</span> Retrait des valeurs dupliquées</h2>
<p>Pour retirer les valeurs dupliquées dans un dataframe, <code>NumPy</code> propose la méthode <code>drop_duplicates()</code>, qui prend plusieurs paramètres optionnels :</p>
<ul>
<li><code>subset</code> : en indiquant un ou plusieurs noms de colonnes, la recherche de doublons se fait uniquement sur ces colonnes ;</li>
<li><p><code>keep</code> : permet d’indiquer quelle observation garder en cas de doublons identifies :</p></li>
<li>si <code>keep='first'</code>, tous les doublons sont retirés sauf la première occurrence,</li>
<li><p>si <code>keep='last'</code>, tous les doublons sont retirés sauf la dernière occurrence, -si <code>keep='False'</code>, tous les doublons sont retirés ;</p></li>
<li><p><code>inplace</code> : booléen (défaut : <code>False</code>) pour indiquer si le retrait des doublons doit s’effectuer sur le dataframe ou bien si une copie doit être retournée (par défaut).</p></li>
</ul>
<p>Donnons quelques exemples à l’aide de ce dataframe qui compose deux doublons quand on considère sa totalité. Si on se concentre uniquement sur les années ou les villes, ou les deux, d’autres doublons peuvent être identifiés.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;ville&quot;</span> : [<span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>,
                   <span class="st">&quot;Marseille&quot;</span>, <span class="st">&quot;Aix&quot;</span>, <span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Paris&quot;</span>],
        <span class="st">&quot;annee&quot;</span>: [<span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2018</span>, <span class="dv">2018</span>,<span class="dv">2019</span>, <span class="dv">2019</span>],
        <span class="st">&quot;x&quot;</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>],
        <span class="st">&quot;y&quot;</span>: [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>],
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4
## 5      Paris   2019  0  4</code></pre>
<p>Pour retirer les doublons :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.drop_duplicates())</code></pre></div>
<pre><code>##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4</code></pre>
<p>Retirer les doublons en gardant la dernière valeur des doublons identifiés :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.drop_duplicates(keep<span class="op">=</span><span class="st">&#39;last&#39;</span>)</code></pre></div>
<p>Pour retirer les doublons identifiés quand on se concentre sur le nom des villes, et en conservant uniquement la première valeur :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.drop_duplicates(subset <span class="op">=</span> [<span class="st">&quot;ville&quot;</span>], keep <span class="op">=</span> <span class="st">&#39;first&#39;</span>))</code></pre></div>
<pre><code>##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 4      Paris   2019  0  4</code></pre>
<p>Idem mais en se concentrant sur les couples (ville, annee)</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.drop_duplicates(subset <span class="op">=</span> [<span class="st">&quot;ville&quot;</span>, <span class="st">&quot;annee&quot;</span>], keep <span class="op">=</span> <span class="st">&#39;first&#39;</span>))</code></pre></div>
<pre><code>##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4</code></pre>
<p>On note que le dataframe original n’a pas été impacté, puisque nous n’avons pas touché au paramètre <code>inplace</code>. Si à présent, nous demandons à ce que les changement soient opérés sur le dataframe plutôt que de récupérer une copie :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.drop_duplicates(subset <span class="op">=</span> [<span class="st">&quot;ville&quot;</span>, <span class="st">&quot;annee&quot;</span>], keep <span class="op">=</span> <span class="st">&#39;first&#39;</span>, inplace <span class="op">=</span> <span class="va">True</span>)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##        ville  annee  x  y
## 0  Marseille   2019  1  3
## 1        Aix   2019  2  3
## 2  Marseille   2018  2  2
## 3        Aix   2018  2  1
## 4      Paris   2019  0  4</code></pre>
<p>Pour savoir si une valeur est dupliquée dans un dataframe, <code>NumPy</code> propose la méthode <code>duplicated()</code>, qui retourne un masque indiquant pour chaque observation, si elle est dupliquée ou non. Son fonctionnement est similaire à <code>df.drop_duplicates()</code>, hormis pour le paramètre <code>inplace</code> qui n’est pas présent.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.duplicated(subset <span class="op">=</span> [<span class="st">&quot;ville&quot;</span>], keep <span class="op">=</span> <span class="st">&#39;first&#39;</span>))</code></pre></div>
<pre><code>## 0    False
## 1    False
## 2     True
## 3     True
## 4    False
## dtype: bool</code></pre>
<p>On peut utiliser la méthode <code>any()</code> par la suite pour savoir s’il existe des doublons :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.duplicated(subset <span class="op">=</span> [<span class="st">&quot;ville&quot;</span>], keep <span class="op">=</span> <span class="st">&#39;first&#39;</span>).<span class="bu">any</span>())</code></pre></div>
<pre><code>## True</code></pre>
</div>
<div id="operations" class="section level2">
<h2><span class="header-section-number">10.10</span> Opérations</h2>
<p>Il est souvent nécessaire de devoir effectuer des opérations sur les colonnes d’un dataframe, notamment lorsqu’il s’agit de créer une nouvelle variable.</p>
<p>En reprenant les principes de modification de colonnes (c.f. Section @ref(#pandas-ajout-valeurs)), on imagine assez facilement qu’il est possible d’appliquer les fonctions et méthodes de <code>NumPy</code> (c.f. Section <a href="numpy.html#numpy-tableaux">9.1</a>) sur les valeurs des colonnes.</p>
<p>Par exemple, considérons le dataframe suivant :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : 
               [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>,
                <span class="dv">63</span>, <span class="dv">64</span>, <span class="dv">65</span>, <span class="dv">66</span>, <span class="dv">67</span>,
                <span class="dv">68</span>, <span class="dv">69</span>, <span class="dv">70</span>, <span class="dv">71</span>, <span class="dv">72</span>],
        <span class="st">&quot;weight&quot;</span>: 
               [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>,
                <span class="dv">129</span>, <span class="dv">132</span>, <span class="dv">135</span>, <span class="dv">139</span>, <span class="dv">142</span>,
                <span class="dv">146</span>, <span class="dv">150</span>, <span class="dv">154</span>, <span class="dv">159</span>, <span class="dv">164</span>]
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##     height  weight
## 0       58     115
## 1       59     117
## 2       60     120
## 3       61     123
## 4       62     126
## 5       63     129
## 6       64     132
## 7       65     135
## 8       66     139
## 9       67     142
## 10      68     146
## 11      69     150
## 12      70     154
## 13      71     159
## 14      72     164</code></pre>
<p>Ajoutons la colonne <code>height_2</code>, élevant les valeurs de la colonne <code>height</code> au carré :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df.assign(height_2 <span class="op">=</span> df.height<span class="op">**</span><span class="dv">2</span>)
<span class="bu">print</span>(df.head(<span class="dv">3</span>))</code></pre></div>
<pre><code>##    height  weight  height_2
## 0      58     115      3364
## 1      59     117      3481
## 2      60     120      3600</code></pre>
<p>À présent, ajoutons la colonne <code>imc</code>, fournissant les valeurs de l’indicateur de masse corporelle pour les individus du dataframe (<span class="math inline">\(\text{IMC} = \frac{\text{weight}}{\text{height}^2}\)</span>) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df.assign(imc <span class="op">=</span> df.weight <span class="op">/</span> df.height_2)
<span class="bu">print</span>(df.head(<span class="dv">3</span>))</code></pre></div>
<pre><code>##    height  weight  height_2       imc
## 0      58     115      3364  0.034185
## 1      59     117      3481  0.033611
## 2      60     120      3600  0.033333</code></pre>
<div id="statistiques-pandas-statistiques-df" class="section level3">
<h3><span class="header-section-number">10.10.1</span> Statistiques {pandas-statistiques-df}</h3>
<p><code>pandas</code> propose quelques méthodes pour effectuer des statistiques descriptives pour chaque colonne ou par ligne. Pour cela, la syntaxe est la suivante (tous les paramètres ont une valeur par défaut, la liste est simplifiée ici) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dataframe.fonction_stat(axis, skipna)</code></pre></div>
<ul>
<li><code>axis</code> : 0 pour les lignes, 1 pour les colonnes ;</li>
<li><code>skipna</code> : si <code>True</code>, exclue les valeurs manquantes pour effectuer les calculs.</li>
</ul>
<p>Parmi les méthodes disponibles : - <code>mean()</code> : moyenne ; - <code>mode()</code> : mode ; - <code>median()</code> : médiane ; - <code>std()</code> : écart-type ; - <code>min()</code> : minimum ; - <code>max()</code> : maximum - <code>mad()</code> : écart absolu à la moyenne ; - <code>sum()</code> : somme des valeurs ; - <code>prod()</code> : produit de tous les éléments ; - <code>count()</code> : comptage du nombre d’éléments.</p>
<p>Par exemple, pour calculer la moyenne des valeurs pour chaque colonne :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, <span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
        <span class="st">&quot;married&quot;</span>: [<span class="va">True</span>, <span class="va">True</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>],
        <span class="st">&quot;city&quot;</span>: [<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span>]
       } 
df <span class="op">=</span> pd.DataFrame(dico)
<span class="bu">print</span>(df.mean())</code></pre></div>
<pre><code>## height      60.0
## weight     120.2
## age         30.4
## taille     161.6
## married      0.6
## dtype: float64</code></pre>
<p>Si on le souhaite, on peut faire la moyenne des valeurs en colonne (sans aucun sens ici) :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.mean(axis<span class="op">=</span><span class="dv">1</span>))</code></pre></div>
<pre><code>## 0    72.8
## 1    73.2
## 2    76.6
## 3    75.0
## 4    75.2
## dtype: float64</code></pre>
<p>Ces fonctions peuvent s’appliquer sur une seule colonne. Par exemple, pour afficher la valeur minimum :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;min : &quot;</span>, df.height.<span class="bu">min</span>())</code></pre></div>
<pre><code>## min :  58</code></pre>
<p>Il est aussi utile de pouvoir obtenir la position des valeurs min et max ; ce qu’on peut obtenir avec les méthodes <code>idxmin()</code> et <code>idxmax()</code>, respectivement.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pos min : &quot;</span>, df.height.idxmin())</code></pre></div>
<pre><code>## pos min :  0</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;pos min : &quot;</span>, df.height.idxmax())</code></pre></div>
<pre><code>## pos min :  4</code></pre>
<p>Une méthode très pratique est <code>describe()</code>, elle permet de retourner des statistiques descriptives sur l’ensemble des colonnes numériques :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.describe())</code></pre></div>
<pre><code>##           height      weight        age      taille
## count   5.000000    5.000000   5.000000    5.000000
## mean   60.000000  120.200000  30.400000  161.600000
## std     1.581139    4.438468   1.949359    6.228965
## min    58.000000  115.000000  28.000000  156.000000
## 25%    59.000000  117.000000  29.000000  158.000000
## 50%    60.000000  120.000000  31.000000  160.000000
## 75%    61.000000  123.000000  31.000000  162.000000
## max    62.000000  126.000000  33.000000  172.000000</code></pre>
</div>
</div>
<div id="tri-2" class="section level2">
<h2><span class="header-section-number">10.11</span> Tri</h2>
<p>Il est aisé de trier un dataframe par ordre croissant ou décroissant d’une ou plusieurs de ses colonnes. Pour ce faire, on utilise la méthode <code>sort_values()</code>. La syntaxe est la suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">DataFrame.sort_values(by, axis<span class="op">=</span><span class="dv">0</span>, ascending<span class="op">=</span><span class="va">True</span>,
                      inplace<span class="op">=</span><span class="va">False</span>, kind<span class="op">=</span><span class="st">&quot;quicksort&quot;</span>,
                      na_position<span class="op">=</span><span class="st">&quot;last&quot;</span>)</code></pre></div>
<pre><code>## NameError: name &#39;DataFrame&#39; is not defined
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<ul>
<li><code>by</code> : nom ou liste de nom de la ou les colonnes utilisées pour effectuer le tri ;</li>
<li><code>axis</code> : <code>0</code> pour l’index (par défaut), <code>1</code> pour les colonnes</li>
<li><code>ascending</code> : booléen ou liste de booléens, quand <code>True</code> le tri est fait par valeurs croissantes (par défaut), quand <code>False</code> il est effectué par valeurs décroissantes</li>
<li><code>inplace</code> : si <code>True</code>, le tri affecte le dataframe, sinon il retourne une vue ;</li>
<li><code>kind</code> : choix de l’algorithme de tri (<code>quicksort</code> (par défaut), <code>mergesort</code>, <code>heapsort</code>) ;</li>
<li><code>na_position</code> : si <code>first</code>, les valeurs manquantes sont placées au début ; si <code>last</code> (par défaut), à la fin.</li>
</ul>
<p>Donnons quelques exemples :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">dico <span class="op">=</span> {<span class="st">&quot;height&quot;</span> : [<span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">62</span>],
        <span class="st">&quot;weight&quot;</span>: [<span class="dv">115</span>, np.nan, <span class="dv">120</span>, <span class="dv">123</span>, <span class="dv">126</span>],
        <span class="st">&quot;age&quot;</span>: [<span class="dv">28</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">29</span>],
        <span class="st">&quot;taille&quot;</span>: [<span class="dv">162</span>, <span class="dv">156</span>, <span class="dv">172</span>, <span class="dv">160</span>, <span class="dv">158</span>],
        <span class="st">&quot;married&quot;</span>: [<span class="va">True</span>, <span class="va">True</span>, np.nan, <span class="va">False</span>, <span class="va">True</span>],
        <span class="st">&quot;city&quot;</span>: [<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span>]
       } 
df <span class="op">=</span> pd.DataFrame(dico)</code></pre></div>
<p>Si on trie les valeurs par ordre décroissant des valeurs de la colonne <code>height</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.sort_values(by<span class="op">=</span><span class="st">&quot;height&quot;</span>, ascending<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<p>Pour effectuer un tri par ordre croissant des valeurs de <code>married</code> (rappel, <code>True</code> est interprété comme 1 et <code>False</code> comme 0), puis décoissant de <code>weight</code>, en plaçant les valeurs <code>NaN</code> en premier :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.sort_values(by<span class="op">=</span>[<span class="st">&quot;married&quot;</span>, <span class="st">&quot;weight&quot;</span>],
               ascending<span class="op">=</span>[<span class="va">True</span>, <span class="va">False</span>],
               na_position<span class="op">=</span><span class="st">&quot;first&quot;</span>)</code></pre></div>
<p>On note que les valeurs <code>NaN</code> sont remontées en avant pour les sous-groupes composés en fonction des valeurs de <code>married</code>.</p>
</div>
<div id="concatenation" class="section level2">
<h2><span class="header-section-number">10.12</span> Concaténation</h2>
<p>Il est fréquent d’avoir des données en provenance de plusieurs sources lorsque l’on réalise une analyse. Il est alors nécessaire de pouvoir combiner les différentes sources dans une seule. Dans cette section, nous allons nous contenter de concaténer différents dataframes entre-eux, dans des cas simples dans lesquels on sait <em>a priori</em> qu’il suffit de coller deux dataframes côte-à-côte ou l’un en-dessous de l’aure. Le cas des jointures un peu plus élaborées avec appariement en fonction d’une ou plusieurs colonnes est abordé dans la Section <a href="pandas.html#pandas-jointures">10.13</a>.</p>
<p>Dans un premier temps, créons deux dataframes avec le même nombre de lignes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x_1 <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">5</span>, <span class="dv">4</span>),
                   columns<span class="op">=</span>[<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>])
x_2 <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">5</span>, <span class="dv">2</span>),
                   columns <span class="op">=</span> [<span class="st">&quot;e&quot;</span>, <span class="st">&quot;f&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;x_1 : </span><span class="ch">\n</span><span class="st">&quot;</span>, x_1)</code></pre></div>
<pre><code>## x_1 : 
##            a         b         c         d
## 0  0.231711 -0.474710 -0.309147 -2.032396
## 1 -0.174468 -0.642475 -0.625023  1.325887
## 2  0.531255  1.275284 -0.682826 -0.948186
## 3  0.777362  0.325113 -1.203486  1.209543
## 4  0.157622 -0.293555  0.111560  0.597679</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">x_2 : </span><span class="ch">\n</span><span class="st">&quot;</span>, x_2)</code></pre></div>
<pre><code>## 
## x_2 : 
##            e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318</code></pre>
<p>Pour “coller” le dataframe <code>x_2</code> à droite de <code>x_1</code>, on peut utiliser la méthode <code>concat()</code> de <code>pandas</code>. Pour indiquer que la concaténation s’effectue sur les colonnes, on précise la valeur <code>1</code> pour le paramètre <code>axix</code> comme suit :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.concat([x_1, x_2], axis <span class="op">=</span> <span class="dv">1</span>))</code></pre></div>
<pre><code>##           a         b         c         d         e         f
## 0  0.231711 -0.474710 -0.309147 -2.032396 -1.270093  0.120949
## 1 -0.174468 -0.642475 -0.625023  1.325887 -0.193898  1.804172
## 2  0.531255  1.275284 -0.682826 -0.948186 -0.234694  0.939908
## 3  0.777362  0.325113 -1.203486  1.209543 -0.171520 -0.153055
## 4  0.157622 -0.293555  0.111560  0.597679 -0.363095 -0.067318</code></pre>
<p>Pour coller les dataframes les uns en-dessous des autres, on peut utiliser la méthode <code>append()</code>, comme indiqué dans la Section <a href="pandas.html#pandas-ajout-ligne-df">10.8.2.1</a>, ou on peut aussi utiliser la méthode <code>concat()</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x_3 <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">5</span>, <span class="dv">2</span>),
                   columns <span class="op">=</span> [<span class="st">&quot;e&quot;</span>, <span class="st">&quot;f&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;x_3 : </span><span class="ch">\n</span><span class="st">&quot;</span>, x_3)</code></pre></div>
<pre><code>## x_3 : 
##            e         f
## 0  1.444721  0.325771
## 1 -0.855732 -0.697595
## 2 -0.276134 -1.258759
## 3  0.478094 -0.859764
## 4  0.571988 -0.173965</code></pre>
<p>Rajoutons les observations de <code>x_3</code> en-dessous de celles de <code>x_2</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.concat([x_2, x_3], axis <span class="op">=</span> <span class="dv">0</span>))</code></pre></div>
<pre><code>##           e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318
## 0  1.444721  0.325771
## 1 -0.855732 -0.697595
## 2 -0.276134 -1.258759
## 3  0.478094 -0.859764
## 4  0.571988 -0.173965</code></pre>
<p>Comme on peut le voir, l’indice des lignes de <code>x_2</code> n’a pas été modifié. Si on souhaite qu’il le soit, on peut le préciser via le paramètre <code>ignore_index</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.concat([x_2, x_3], axis <span class="op">=</span> <span class="dv">0</span>, ignore_index<span class="op">=</span><span class="va">True</span>))</code></pre></div>
<pre><code>##           e         f
## 0 -1.270093  0.120949
## 1 -0.193898  1.804172
## 2 -0.234694  0.939908
## 3 -0.171520 -0.153055
## 4 -0.363095 -0.067318
## 5  1.444721  0.325771
## 6 -0.855732 -0.697595
## 7 -0.276134 -1.258759
## 8  0.478094 -0.859764
## 9  0.571988 -0.173965</code></pre>
<p>Si le nom des colonnes n’est pas ientique, des valeurs <code>NaN</code> seront introduites :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x_4 <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">5</span>, <span class="dv">2</span>),
                   columns <span class="op">=</span> [<span class="st">&quot;e&quot;</span>, <span class="st">&quot;g&quot;</span>])
<span class="bu">print</span>(<span class="st">&quot;x_4 : </span><span class="ch">\n</span><span class="st">&quot;</span>, x_4)</code></pre></div>
<pre><code>## x_4 : 
##            e         g
## 0  1.534900  0.872856
## 1  1.856835  0.025914
## 2  0.171984 -0.191163
## 3 -0.292936  1.655677
## 4 -0.207182 -0.686884</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pd.concat([x_2, x_4], axis <span class="op">=</span> <span class="dv">0</span>, sort<span class="op">=</span><span class="va">False</span>, ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
</div>
<div id="pandas-jointures" class="section level2">
<h2><span class="header-section-number">10.13</span> Jointures</h2>
<p>Il est plus fréquent d’avoir recours à des jointures un peu plus élaborées pour rassembler les différentes sources de données en une seule. <code>pandas</code> offre un moyen performant pour rassembler les données, la fonction <code>merge()</code>.</p>
<p>Pour illustrer les différentes jointures de cette section, créons quelques dataframes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">exportations_fr <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;country&quot;</span> : <span class="st">&quot;France&quot;</span>,
     <span class="st">&quot;year&quot;</span> : np.arange(<span class="dv">2014</span>, <span class="dv">2017</span>),
     <span class="st">&quot;exportations&quot;</span> : [<span class="fl">816.8192172</span>, <span class="fl">851.6632573</span>, <span class="fl">867.4014253</span>]
    })
importations_fr <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;country&quot;</span> : <span class="st">&quot;France&quot;</span>,
     <span class="st">&quot;year&quot;</span> : np.arange(<span class="dv">2015</span>, <span class="dv">2018</span>),
     <span class="st">&quot;importations&quot;</span> : [<span class="fl">898.5242962</span>, <span class="fl">936.3691166</span>, <span class="fl">973.8762149</span>]
    })
exportations_us <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;country&quot;</span> : <span class="st">&quot;USA&quot;</span>,
     <span class="st">&quot;year&quot;</span> : np.arange(<span class="dv">2014</span>, <span class="dv">2017</span>),
     <span class="st">&quot;exportations&quot;</span> : [<span class="fl">2208.678084</span>, <span class="fl">2217.733347</span>, <span class="fl">2210.442218</span>]
    })
importations_us <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;country&quot;</span> : <span class="st">&quot;USA&quot;</span>,
     <span class="st">&quot;year&quot;</span> : np.arange(<span class="dv">2015</span>, <span class="dv">2018</span>),
     <span class="st">&quot;importations&quot;</span> : [<span class="fl">2827.336251</span>, <span class="fl">2863.264745</span>, np.nan]
    })
importations_maroc <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;pays&quot;</span> : <span class="st">&quot;Maroc&quot;</span>,
     <span class="st">&quot;annee&quot;</span> : np.arange(<span class="dv">2015</span>, <span class="dv">2018</span>),
     <span class="st">&quot;importations&quot;</span> : [<span class="fl">46.39884177</span>, <span class="fl">53.52375588</span>, <span class="fl">56.68165748</span>]
    })
exportations_maroc <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;country&quot;</span> : <span class="st">&quot;Maroc&quot;</span>,
     <span class="st">&quot;year&quot;</span> : np.arange(<span class="dv">2014</span>, <span class="dv">2017</span>),
     <span class="st">&quot;exportations&quot;</span> : [<span class="fl">35.50207915</span>, <span class="fl">37.45996653</span>, <span class="fl">39.38228396</span>]
    })
exportations <span class="op">=</span> pd.concat([exportations_fr, exportations_us], ignore_index<span class="op">=</span><span class="va">True</span>)
importations <span class="op">=</span> pd.concat([importations_fr, importations_us], ignore_index<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span>(<span class="st">&quot;exportations : </span><span class="ch">\n</span><span class="st">&quot;</span>, exportations)</code></pre></div>
<pre><code>## exportations : 
##    country  year  exportations
## 0  France  2014    816.819217
## 1  France  2015    851.663257
## 2  France  2016    867.401425
## 3     USA  2014   2208.678084
## 4     USA  2015   2217.733347
## 5     USA  2016   2210.442218</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">importations : </span><span class="ch">\n</span><span class="st">&quot;</span>, importations)</code></pre></div>
<pre><code>## 
## importations : 
##    country  year  importations
## 0  France  2015    898.524296
## 1  France  2016    936.369117
## 2  France  2017    973.876215
## 3     USA  2015   2827.336251
## 4     USA  2016   2863.264745
## 5     USA  2017           NaN</code></pre>
<p>La fonction <code>merge()</code> de <code>pandas</code> nécessite de préciser la table de gauche (que l’on appellera ici <code>x</code>) via le paramètre <code>left</code> sur qui viendra s’effectuer la jointure de la table de droite (que l’on appellera ici <code>y</code>) via le paramètre <code>right</code>.</p>
<p>Par défaut, la fonction <code>merge()</code> réalise une jointure de type <code>inner</code>, c’est-à-dire que toutes les toutes les lignes de <code>x</code> qui trouvent une correspondance dans <code>y</code>, et toutes les colonnes de <code>x</code> et <code>y</code> seront dans le résultat de la jointure :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations))</code></pre></div>
<pre><code>##   country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2     USA  2015   2827.336251   2217.733347
## 3     USA  2016   2863.264745   2210.442218</code></pre>
<p>Si on désire changer le type de jointure, on peut modifier la valeur du paramètre <code>how</code> de la fonction <code>merge()</code>, pour lui donner une des valeurs suivantes :</p>
<ul>
<li><code>left</code> : toutes les lignes de <code>x</code>, et toutes les colonnes de <code>x</code> et <code>y</code>. Les lignes dans <code>x</code> pour lesquelles il n’y a pas de correspondance dans <code>y</code> auront des valeurs <code>NaN</code> dans les nouvelles colonnes. S’il y a plusieurs correspondances dans les noms entre <code>x</code> et <code>y</code>, toutes les combinaisons sont retournées ;</li>
<li><code>inner</code> : toutes les lignes de <code>x</code> pour lesquelles il y a des valeurs correspondantes dans <code>y</code>, et toutes les colonnes de <code>x</code> et <code>y</code>. S’il y a plusieurs correspondances dans les noms entre <code>x</code> et <code>y</code>, toutes les combinaisons possibles sont retournées ;</li>
<li><code>right</code> : toutes les lignes de <code>y</code>, et toutes les colonnes de <code>y</code> et <code>x</code>. Les lignes dans <code>y</code> pour lesquelles il n’y a pas de correspondance dans <code>x</code> auront des valeurs <code>NaN</code> dans les nouvelles colonnes. S’il y a plusieurs correspondances dans les noms entre <code>y</code> et <code>x</code>, toutes les combinaisons sont retournées ;</li>
<li><code>outer</code>: toutes les lignes de <code>x</code> et de <code>y</code>, et toutes les colonnes de <code>x</code> et <code>y</code>. Les lignes de <code>x</code> pour lesquelles il n’y a pas de correspondance dabs <code>y</code> et celles de <code>y</code> pour lesquelles il n’y a pas de correspondance dans <code>x</code> auront des valeurs <code>NaN</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;left : </span><span class="ch">\n</span><span class="st">&quot;</span>, pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations, how<span class="op">=</span><span class="st">&quot;left&quot;</span>))</code></pre></div>
<pre><code>## left : 
##    country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2  France  2017    973.876215           NaN
## 3     USA  2015   2827.336251   2217.733347
## 4     USA  2016   2863.264745   2210.442218
## 5     USA  2017           NaN           NaN</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">right : </span><span class="ch">\n</span><span class="st">&quot;</span>, pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations, how<span class="op">=</span><span class="st">&quot;right&quot;</span>))</code></pre></div>
<pre><code>## 
## right : 
##    country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2     USA  2015   2827.336251   2217.733347
## 3     USA  2016   2863.264745   2210.442218
## 4  France  2014           NaN    816.819217
## 5     USA  2014           NaN   2208.678084</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">outer : </span><span class="ch">\n</span><span class="st">&quot;</span>, pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations, how<span class="op">=</span><span class="st">&quot;outer&quot;</span>))</code></pre></div>
<pre><code>## 
## outer : 
##    country  year  importations  exportations
## 0  France  2015    898.524296    851.663257
## 1  France  2016    936.369117    867.401425
## 2  France  2017    973.876215           NaN
## 3     USA  2015   2827.336251   2217.733347
## 4     USA  2016   2863.264745   2210.442218
## 5     USA  2017           NaN           NaN
## 6  France  2014           NaN    816.819217
## 7     USA  2014           NaN   2208.678084</code></pre>
<p>Le paramètre <code>on</code>, qui attend un nom de colonne ou une liste de noms sert à désigner les colonnes permettant de faire la jointure. Les noms de colonnes doivent être identiques dans les deux dataframes.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations, on <span class="op">=</span> <span class="st">&quot;country&quot;</span>))</code></pre></div>
<pre><code>##    country  year_x  importations  year_y  exportations
## 0   France    2015    898.524296    2014    816.819217
## 1   France    2015    898.524296    2015    851.663257
## 2   France    2015    898.524296    2016    867.401425
## 3   France    2016    936.369117    2014    816.819217
## 4   France    2016    936.369117    2015    851.663257
## 5   France    2016    936.369117    2016    867.401425
## 6   France    2017    973.876215    2014    816.819217
## 7   France    2017    973.876215    2015    851.663257
## 8   France    2017    973.876215    2016    867.401425
## 9      USA    2015   2827.336251    2014   2208.678084
## 10     USA    2015   2827.336251    2015   2217.733347
## 11     USA    2015   2827.336251    2016   2210.442218
## 12     USA    2016   2863.264745    2014   2208.678084
## 13     USA    2016   2863.264745    2015   2217.733347
## 14     USA    2016   2863.264745    2016   2210.442218
## 15     USA    2017           NaN    2014   2208.678084
## 16     USA    2017           NaN    2015   2217.733347
## 17     USA    2017           NaN    2016   2210.442218</code></pre>
<p>Si le nom des colonnes devant servir à réaliser la jointure sont différents entre le dataframe de gauche et celui de droite, on indique au paramètre <code>left_on</code> le ou les noms de colonnes du dataframe de gauche à utiliser pour la jointure ; et au paramètre <code>right_on</code>, le ou les noms correspondants dans le dataframe de doite :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pd.merge(left <span class="op">=</span> importations_maroc, right <span class="op">=</span> exportations_maroc,
         left_on<span class="op">=</span> [<span class="st">&quot;pays&quot;</span>, <span class="st">&quot;annee&quot;</span>], right_on <span class="op">=</span> [<span class="st">&quot;country&quot;</span>, <span class="st">&quot;year&quot;</span>] )</code></pre></div>
<p>Avec le paramètre <code>suffixes</code>, on peut définir des suffixes à ajouter aux noms des colonnes lorsqu’il existe des colonnes dans <code>x</code> et dans <code>y</code> portant le même nom mais ne servant pas à la jointure. Par défaut, les suffixes (<code>_x</code> et <code>_y</code>) sont rajoutés.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(pd.merge(left <span class="op">=</span> importations, right <span class="op">=</span> exportations,
               on <span class="op">=</span> <span class="st">&quot;country&quot;</span>,
               suffixes<span class="op">=</span>(<span class="st">&quot;_gauche&quot;</span>, <span class="st">&quot;_droite&quot;</span>)).head(<span class="dv">3</span>))</code></pre></div>
<pre><code>##   country  year_gauche  importations  year_droite  exportations
## 0  France         2015    898.524296         2014    816.819217
## 1  France         2015    898.524296         2015    851.663257
## 2  France         2015    898.524296         2016    867.401425</code></pre>
</div>
<div id="agregation" class="section level2">
<h2><span class="header-section-number">10.14</span> Agrégation</h2>
<p>Il arrive de vouloir agréger les valeurs d’une variable, pour passer par exemple d’une dimension trimestrielle à annuelle. Avec des observations spatiales, cela peut aussi être le cas, comme par exemple lorsque l’on dispose de données à l’échelle des départements et que l’on souhaite connaître les valeurs agrégées à l’échelle des régions.</p>
<p>Pour illustrer les différentes opérations d’agrégation, créons un dataframe avec des des données de chômage dans différentes régions, départements et années :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chomage <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;region&quot;</span> : ([<span class="st">&quot;Bretagne&quot;</span>]<span class="op">*</span><span class="dv">4</span> <span class="op">+</span> [<span class="st">&quot;Corse&quot;</span>]<span class="op">*</span><span class="dv">2</span>)<span class="op">*</span><span class="dv">2</span>,
     <span class="st">&quot;departement&quot;</span> : [<span class="st">&quot;Cotes-d&#39;Armor&quot;</span>, <span class="st">&quot;Finistere&quot;</span>,
                      <span class="st">&quot;Ille-et-Vilaine&quot;</span>, <span class="st">&quot;Morbihan&quot;</span>,
                      <span class="st">&quot;Corse-du-Sud&quot;</span>, <span class="st">&quot;Haute-Corse&quot;</span>]<span class="op">*</span><span class="dv">2</span>,
     <span class="st">&quot;annee&quot;</span> : np.repeat([<span class="dv">2011</span>, <span class="dv">2010</span>], <span class="dv">6</span>),
     <span class="st">&quot;ouvriers&quot;</span> : [<span class="dv">8738</span>, <span class="dv">12701</span>, <span class="dv">11390</span>, <span class="dv">10228</span>, <span class="dv">975</span>, <span class="dv">1297</span>,
                   <span class="dv">8113</span>, <span class="dv">12258</span>, <span class="dv">10897</span>, <span class="dv">9617</span>, <span class="dv">936</span>, <span class="dv">1220</span>],
     <span class="st">&quot;ingenieurs&quot;</span> : [<span class="dv">1420</span>, <span class="dv">2530</span>, <span class="dv">3986</span>, <span class="dv">2025</span>, <span class="dv">259</span>, <span class="dv">254</span>,
                     <span class="dv">1334</span>, <span class="dv">2401</span>, <span class="dv">3776</span>, <span class="dv">1979</span>, <span class="dv">253</span>, <span class="dv">241</span>]
    })
<span class="bu">print</span>(chomage)</code></pre></div>
<pre><code>##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d&#39;Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d&#39;Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241</code></pre>
<p>Comme nous l’avons vu précédemment (c.f. Section <a href="#pandas-statistiques-df"><strong>??</strong></a>), on peut utiliser des méthodes permettant de calculer des statistiques simples sur l’ensemble des données. Par exemple, pour afficher la moyenne de chacune des colonnes numériques :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(chomage.mean())</code></pre></div>
<pre><code>## annee         2010.500000
## ouvriers      7364.166667
## ingenieurs    1704.833333
## dtype: float64</code></pre>
<p>Ce qui nous intéresse dans cette section, est d’effectuer des calculs sur des sous-groupes de données. Le principe est simple : dans un premier temps, on sépare les données en fonction de groupes identifiés (<em>split</em>), puis on applique une opération sur chacun des groupes (<em>apply</em>), et enfin on rassemble les résultats (<em>combine</em>). Pour effectuer le regroupement, en fonction de facteurs avant d’effectuer les calculs d’agrégation, <code>pandas</code> propose la méthode <code>groupby()</code>. On lui fournit en paramètre le ou les noms de colonnes servant à effectuer les groupes.</p>
<div id="agregation-selon-les-valeurs-dune-seule-colonne" class="section level3">
<h3><span class="header-section-number">10.14.1</span> Agrégation selon les valeurs d’une seule colonne</h3>
<p>Par exemple, admettons que nous souhaitons obtenir le nombre total de chomeurs ouvriers par année. Dans un premier temps, on utilise la méthode <code>groupby()</code> sur notre dataframe en indiquant que les groupes doivent être créés selon les valeurs de la colonne <code>annee</code></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(chomage.groupby(<span class="st">&quot;annee&quot;</span>))</code></pre></div>
<pre><code>## &lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x1271660b8&gt;</code></pre>
<p>Ensuite, on récupère la variable <code>ouvriers</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(chomage.groupby(<span class="st">&quot;annee&quot;</span>).annee)
<span class="co"># Ou bien</span></code></pre></div>
<pre><code>## &lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x127166f60&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(chomage.groupby(<span class="st">&quot;annee&quot;</span>)[<span class="st">&quot;annee&quot;</span>])</code></pre></div>
<pre><code>## &lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x127166780&gt;</code></pre>
<p>Et enfin, on peut effectuer le calcul sur chaque sous-groupe et afficher le résultat :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(chomage.groupby(<span class="st">&quot;annee&quot;</span>)[<span class="st">&quot;ouvriers&quot;</span>].<span class="bu">sum</span>())</code></pre></div>
<pre><code>## annee
## 2010    43041
## 2011    45329
## Name: ouvriers, dtype: int64</code></pre>
<p>Si on veut effectuer ce calcul pour plusieurs colonnes, par exemple <code>ouvriers</code> et <code>ingenieurs</code>, il suffit de sélectionner <em>a priori</em> la variale de regroupement et les variables pour lesquelles on désire effectuer le calcul :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chomage.loc[:,[<span class="st">&quot;annee&quot;</span>, <span class="st">&quot;ouvriers&quot;</span>, <span class="st">&quot;ingenieurs&quot;</span>]].groupby(<span class="st">&quot;annee&quot;</span>).<span class="bu">sum</span>()</code></pre></div>
</div>
<div id="agregation-selon-les-valeurs-de-plusieurs-colonnes" class="section level3">
<h3><span class="header-section-number">10.14.2</span> Agrégation selon les valeurs de plusieurs colonnes</h3>
<p>À présent, admettons que l’on souhaite effectuer une agrégation en fonction de l’année et de la région. Il s’agit simplement de donner une liste contenant les noms des colonnes utilisées pour créer les différents groupes :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chomage.loc[:,[<span class="st">&quot;annee&quot;</span>, <span class="st">&quot;region&quot;</span>,
               <span class="st">&quot;ouvriers&quot;</span>, <span class="st">&quot;ingenieurs&quot;</span>]].groupby([<span class="st">&quot;annee&quot;</span>,
                                                   <span class="st">&quot;region&quot;</span>]).<span class="bu">sum</span>()</code></pre></div>
</div>
</div>
<div id="stacking-et-unstacking" class="section level2">
<h2><span class="header-section-number">10.15</span> Stacking et unstacking</h2>
<p>À compléter</p>
</div>
<div id="exportation-et-importation-de-donnees" class="section level2">
<h2><span class="header-section-number">10.16</span> Exportation et importation de données</h2>
<p><code>pandas</code> offre de nombreuses fonctions pour importer et exporter des données dans différents formats.</p>
<div id="exportation-des-donnees" class="section level3">
<h3><span class="header-section-number">10.16.1</span> Exportation des données</h3>
<div id="exportation-de-donnees-tabulaires" class="section level4">
<h4><span class="header-section-number">10.16.1.1</span> Exportation de données tabulaires</h4>
<div id="vers-un-fichier-csv-pandas-export_csv" class="section level5">
<h5><span class="header-section-number">10.16.1.1.1</span> Vers un fichier CSV {pandas-export_csv}</h5>
<p>Pour exporter des données tabulaires, comme celles contenues dans un dataframe, <code>NumPy</code> propose la méthode <code>to_csv()</code>, qui accepte de nombreuses spécifications. Regardons quelques-unes d’entre-elles qui me semblent les plus courantes :</p>
<table style="width:94%;">
<caption><span id="tab:pandasto-csv">Table 10.1: </span> Paramètres principaux de la fonction <code>to_csv</code></caption>
<colgroup>
<col width="23%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th align="right">Paramètre</th>
<th align="right">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><code>path_or_buf</code></td>
<td align="right">chemin vers le fichier</td>
</tr>
<tr class="even">
<td align="right"><code>sep</code></td>
<td align="right">caractère de séparation des champs</td>
</tr>
<tr class="odd">
<td align="right"><code>decimal</code></td>
<td align="right">Caractère à utiliser pour le séparateur de décimales</td>
</tr>
<tr class="even">
<td align="right"><code>na_rep</code></td>
<td align="right">représentation à utiliser pour les valeurs manquantes</td>
</tr>
<tr class="odd">
<td align="right"><code>header</code></td>
<td align="right">indique si le nom des colonnes doit être exporté (<code>True</code> par défaut)</td>
</tr>
<tr class="even">
<td align="right"><code>index</code></td>
<td align="right">indique si le nom des lignes doit être exporté (<code>True</code> par défaut)</td>
</tr>
<tr class="odd">
<td align="right"><code>mode</code></td>
<td align="right">mode d’écriture python (c.f. Tableau <a href="chargement-et-sauvegarde-de-donnees.html#tab:open-mode-ouverture">5.1</a>, par défaut <code>w</code>)</td>
</tr>
<tr class="even">
<td align="right"><code>encoding</code></td>
<td align="right">encodage des caractères (<code>utf-8</code> par défaut)</td>
</tr>
<tr class="odd">
<td align="right"><code>compression</code></td>
<td align="right">compression à utiliser pour le fichier de destination (<code>gzip</code>, <code>bz2</code>, <code>zip</code>, <code>xz</code>)</td>
</tr>
<tr class="even">
<td align="right"><code>line_terminator</code></td>
<td align="right">caractère de fin de ligne</td>
</tr>
<tr class="odd">
<td align="right"><code>quotechar</code></td>
<td align="right">Caractère utilisé pour mettre les champs entre <em>quotes</em></td>
</tr>
<tr class="even">
<td align="right"><code>chunksize</code></td>
<td align="right">(entier) nombre de lignes à écrire à la fois</td>
</tr>
<tr class="odd">
<td align="right"><code>date_format</code></td>
<td align="right">format de dates pour les objets <code>datetime</code></td>
</tr>
</tbody>
</table>
<p>Admettons que nous souhaitons exporter le contenu du dataframe <code>chomage</code> vers un fichier CSV dont les champs sont séparés par des points-virgules, et en n’exportant pas l’index :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chomage <span class="op">=</span> pd.DataFrame(
    {<span class="st">&quot;region&quot;</span> : ([<span class="st">&quot;Bretagne&quot;</span>]<span class="op">*</span><span class="dv">4</span> <span class="op">+</span> [<span class="st">&quot;Corse&quot;</span>]<span class="op">*</span><span class="dv">2</span>)<span class="op">*</span><span class="dv">2</span>,
     <span class="st">&quot;departement&quot;</span> : [<span class="st">&quot;Cotes-d&#39;Armor&quot;</span>, <span class="st">&quot;Finistere&quot;</span>,
                      <span class="st">&quot;Ille-et-Vilaine&quot;</span>, <span class="st">&quot;Morbihan&quot;</span>,
                      <span class="st">&quot;Corse-du-Sud&quot;</span>, <span class="st">&quot;Haute-Corse&quot;</span>]<span class="op">*</span><span class="dv">2</span>,
     <span class="st">&quot;annee&quot;</span> : np.repeat([<span class="dv">2011</span>, <span class="dv">2010</span>], <span class="dv">6</span>),
     <span class="st">&quot;ouvriers&quot;</span> : [<span class="dv">8738</span>, <span class="dv">12701</span>, <span class="dv">11390</span>, <span class="dv">10228</span>, <span class="dv">975</span>, <span class="dv">1297</span>,
                   <span class="dv">8113</span>, <span class="dv">12258</span>, <span class="dv">10897</span>, <span class="dv">9617</span>, <span class="dv">936</span>, <span class="dv">1220</span>],
     <span class="st">&quot;ingenieurs&quot;</span> : [<span class="dv">1420</span>, <span class="dv">2530</span>, <span class="dv">3986</span>, <span class="dv">2025</span>, <span class="dv">259</span>, <span class="dv">254</span>,
                     <span class="dv">1334</span>, <span class="dv">2401</span>, <span class="dv">3776</span>, <span class="dv">1979</span>, <span class="dv">253</span>, <span class="dv">241</span>]
    })
<span class="bu">print</span>(chomage)</code></pre></div>
<pre><code>##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d&#39;Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d&#39;Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241</code></pre>
<p>Pour l’exportation :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./fichiers_exemples/chomage.csv&quot;</span>
chomage.to_csv(chemin, decimal<span class="op">=</span><span class="st">&quot;;&quot;</span>, index<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<p>Si on désire que le fichier CSV soit compressé dans un fichier <code>gzip</code>, on le nomme avec l’extention <code>.csv.gz</code> et on ajoute la valeur <code>gzip</code> au paramètre <code>compression</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./Python_pour_economistes/fichiers_exemples/chomage.csv.gz&quot;</span>
chomage.to_csv(chemin, decimal<span class="op">=</span><span class="st">&quot;;&quot;</span>, index<span class="op">=</span><span class="va">False</span>, compression<span class="op">=</span><span class="st">&quot;gzip&quot;</span>)</code></pre></div>
<pre><code>## FileNotFoundError: [Errno 2] No such file or directory: &#39;./Python_pour_economistes/fichiers_exemples/chomage.csv.gz&#39;
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/core/frame.py&quot;, line 1745, in to_csv
##     formatter.save()
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/io/formats/csvs.py&quot;, line 136, in save
##     compression=None)
##   File &quot;/anaconda3/lib/python3.6/site-packages/pandas/io/common.py&quot;, line 400, in _get_handle
##     f = open(path_or_buf, mode, encoding=encoding)</code></pre>
</div>
<div id="vers-un-fichier-hdf5" class="section level5">
<h5><span class="header-section-number">10.16.1.1.2</span> Vers un fichier HDF5</h5>
<p>Pour enregistrer les données d’un dataframe dans un fichier HDF5 utilisant HDFStore, <code>pandas</code> propose la méthode <code>to_hdf()</code> qui fonctionne de la même manière que la fonction <code>to_csv()</code> (cf. Section @ref(pandas-export_csv)).</p>
<p>Il est nécessaire de spécifier le paramètre <code>path_or_buf</code> pour indiquer le chemin et le paramètre <code>key</code> pour identifier l’objet à enregistrer dans le fichier.</p>
<p>La syntaxe est la suivante :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./fichiers_exemples/chomage.h5&quot;</span>
chomage.to_hdf(chemin, <span class="st">&quot;base_chomage&quot;</span>, decimal<span class="op">=</span><span class="st">&quot;;&quot;</span>, index<span class="op">=</span><span class="va">False</span>)</code></pre></div>
</div>
</div>
</div>
</div>
<div id="importation-des-donnees" class="section level2">
<h2><span class="header-section-number">10.17</span> Importation des données</h2>
<p><code>pandas</code> propose de nombreuses fonctions pour importer des données. Dans cette version des notes de cours, nous allons en aborder 3 : <code>read_csv()</code>, pour lire des fichiers CSV ; <code>read_excel()</code>, pour lire des fichiers Excel ; et <code>read_hdf()</code> pour lire des fichiers HDF5.</p>
<p>Dans la prochaine version, des ajouts sur <code>read_html()</code>, <code>read_fwf()</code>, <code>read_stata()</code>, <code>read_json()</code>.</p>
<div id="pandas-importation-csv" class="section level3">
<h3><span class="header-section-number">10.17.1</span> Fichiers CSV</h3>
<p>Pour importer des données depuis un fichier CSV, <code>pandas</code> propose la fonction <code>read_csv()</code> :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./fichiers_exemples/chomage.csv&quot;</span>
chomage <span class="op">=</span> pd.read_csv(chemin, decimal<span class="op">=</span><span class="st">&quot;;&quot;</span>, index<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<pre><code>## TypeError: parser_f() got an unexpected keyword argument &#39;index&#39;
## 
## Detailed traceback: 
##   File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</code></pre>
<p>Il est possible de fournir une URL pointant vers un fichier CSV comme chemin, la fonction <code>read_csv()</code>.</p>
<p>Parmi les paramètres que l’on utilise fréquemment :</p>
<ul>
<li><code>sep</code>, <code>delimiter</code> : séparateur de champs ;</li>
<li><code>decimal</code> : séparateur de décimales ;</li>
<li><code>header</code> : numéro(s) de ligne(s) à utiliser comme en-tête des données ;</li>
<li><code>skiprows</code> : numéro(s) de ligne(s) à sauter au début ;</li>
<li><code>skipfooter</code> : numéro(s) de ligne(s) à sauter à la fin ;</li>
<li><code>nrows</code> : nombre de ligne à lire ;</li>
<li><code>na_values</code> : chaînes de caractères supplémentaires à considérer comme valeurs manquantes (en plus de <code>#N/A</code>, <code>#N/A N/A</code>, <code>#NA</code>, <code>-1.#IND</code>, <code>-1.#QNAN</code>, <code>-NaN</code>, <code>-nan</code>, <code>1.#IND</code>, <code>1.#QNAN</code>, <code>N/A</code>, <code>NA</code>, <code>NULL</code>, <code>NaN</code>, <code>n/a</code>, <code>nan</code>, <code>null</code>) ;</li>
<li><code>quotechar</code> : caractère de <em>quote</em> ;</li>
<li><code>encoding</code> : encodage des caractères (défaut <code>utf-8</code>).</li>
</ul>
</div>
<div id="pandas-importation-excel" class="section level3">
<h3><span class="header-section-number">10.17.2</span> Fichiers Excel</h3>
<p>Pour importer des fichiers Excel, <code>pandas</code> propose la fonction <code>read_excel()</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./fichiers_exemples/chomage.xlsx&quot;</span>
chomage <span class="op">=</span> pd.read_excel(chemin, skiprows<span class="op">=</span><span class="dv">2</span>, header<span class="op">=</span><span class="dv">1</span>, sheet <span class="op">=</span> <span class="dv">1</span>)
<span class="bu">print</span>(chomage)</code></pre></div>
<pre><code>##     Bretagne    Cotes-d&#39;Armor  2011   8738  1420
## 0   Bretagne        Finistere  2011  12701  2530
## 1   Bretagne  Ille-et-Vilaine  2011  11390  3986
## 2   Bretagne         Morbihan  2011  10228  2025
## 3      Corse     Corse-du-Sud  2011    975   259
## 4      Corse      Haute-Corse  2011   1297   254
## 5   Bretagne    Cotes-d&#39;Armor  2010   8113  1334
## 6   Bretagne        Finistere  2010  12258  2401
## 7   Bretagne  Ille-et-Vilaine  2010  10897  3776
## 8   Bretagne         Morbihan  2010   9617  1979
## 9      Corse     Corse-du-Sud  2010    936   253
## 10     Corse      Haute-Corse  2010   1220   241</code></pre>
<p>Parmi les paramètres fréquemment utilisés :</p>
<ul>
<li><code>header</code> : numéro de ligne à utiliser comme en-tête ;</li>
<li><code>sheet</code> : nom ou numéro de feuille ;</li>
<li><code>skiprows</code> : nombre de lignes à sauter au début ;</li>
<li><code>thousands</code> : séparateur de milliers.</li>
</ul>
</div>
<div id="pandas-importation-hdf" class="section level3">
<h3><span class="header-section-number">10.17.3</span> Fichiers HDF5</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">chemin <span class="op">=</span> <span class="st">&quot;./fichiers_exemples/chomage.h5&quot;</span>
<span class="bu">print</span>(pd.read_hdf(chemin, <span class="st">&quot;base_chomage&quot;</span>))</code></pre></div>
<pre><code>##       region      departement  annee  ouvriers  ingenieurs
## 0   Bretagne    Cotes-d&#39;Armor   2011      8738        1420
## 1   Bretagne        Finistere   2011     12701        2530
## 2   Bretagne  Ille-et-Vilaine   2011     11390        3986
## 3   Bretagne         Morbihan   2011     10228        2025
## 4      Corse     Corse-du-Sud   2011       975         259
## 5      Corse      Haute-Corse   2011      1297         254
## 6   Bretagne    Cotes-d&#39;Armor   2010      8113        1334
## 7   Bretagne        Finistere   2010     12258        2401
## 8   Bretagne  Ille-et-Vilaine   2010     10897        3776
## 9   Bretagne         Morbihan   2010      9617        1979
## 10     Corse     Corse-du-Sud   2010       936         253
## 11     Corse      Haute-Corse   2010      1220         241</code></pre>
</div>
</div>
<div id="exercice-8" class="section level2">
<h2><span class="header-section-number">10.18</span> Exercice</h2>

<div class="exframe">
<p><strong>Exercice 1 : Importation et exportation</strong></p>
<ol style="list-style-type: decimal">
<li>Télécharger à la main le fichier csv à l’adresse suivante : <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.csv" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.csv</a> et le placer dans le répertoire courant. Importer son contenu dans Python.</li>
<li>Importer à nouveau les données dans Python, mais en fournissant cette fois le l’url directement à la fonction d’importation.</li>
<li>À présent, importer le contenu du fichier disponible à l’adresse <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_decim.csv" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_decim.csv</a>. Le séparateur de champs est un point virgule et le séparateur décimal est une virgule.</li>
<li>Importer le contenu du fichier <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h.csv" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h.csv</a>. Le nom des colonnes n’est pas présent.</li>
<li>Importer le contenu du fichier <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h_s.csv" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_h_s.csv</a>. La première ligne n’est pas à importer.</li>
<li>Importer le contenu de la première feuille du fichier Excel <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx</a>.</li>
<li>Importer le contenu de la seconde feuille (<code>notes_h_s</code>) du fichier Excel disponible ici : <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes.xlsx</a>. La première ligne est un commentaire à ne pas considérer durant l’importaiton.</li>
<li>Exporter le contenu de l’objet contenant les notes de la question précédente au format csv (virgule en séparateur de champs, point en séparateur décimal, ne pas conserver le numéro des lignes).</li>
</ol>
<p><strong>Exercice 2 : Manipulation de tableaux de données</strong></p>
<ol style="list-style-type: decimal">
<li>À l’aide de la fonction <code>read_excel()</code> de la librairie <code>pandas</code>, importer le contenu de la feuille intitulée <code>notes_2012</code> du fichier Excel disponible à l’adresse suivante : <a href="http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_etudiants.xlsx" class="uri">http://egallic.fr/Enseignement/Python/Exercices/donnees/notes_etudiants.xlsx</a> et le stocker dans une variable que l’on nommera notes_2012.</li>
<li>Afficher les 6 premières lignes du jeu de données, puis les dimensions du tableau.</li>
<li>Conserver uniquement la colonne <code>note_stat</code> du tableau de données <code>notes_2012</code> dans un objet que l’on appellera <code>tmp</code>.</li>
<li>Conserver uniquement les colonnes <code>num_etudiant</code>, <code>note_stat</code> et <code>note_macro</code> dans un objet nommé <code>tmp</code>.</li>
<li>Remplacer le contenu de <code>tmp</code> par les observations de <code>notes_2012</code> pour lesquelles l’individu a obtenu une note de stat supérieure (strictement) à 10.</li>
<li>Remplacer le contenu de tmp par les observations de <code>notes_2012</code> pour lesquelles l’individu a obtenu une note de stats comprise dans l’intervalle (10, 15).</li>
<li>Regarder s’il y a des doublons dans le tableau de données <code>notees_2012</code> ; le cas échéant, les retirer du tableau.</li>
<li>Afficher le type des données de la colonne <code>num_etudiant</code>, puis afficher le type de toutes les colonnes de notes_2012.</li>
<li>Ajouter au tableau <code>notes_2012</code> les colonnes suivantes :</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li><code>note_stat_maj</code> : la note de stat (<code>note_stat</code>) majorée d’un point,</li>
<li><code>note_macro_maj</code> : la note de macro (<code>note_macro</code>) majorée de trois points (le faire en deux étapes : d’abord deux points en plus, puis un point).</li>
</ol>
<ol start="10" style="list-style-type: decimal">
<li>Renommer la colonne year en annee.</li>
<li>Depuis le fichier <code>notes_etudiants.xlsx</code> (c.f. question 1), importer le contenu des feuilles <code>notes_2013</code>, <code>notes_2014</code> et <code>prenoms</code> et le stocker dans les objets <code>notes_2013</code>, <code>notes_2014</code> et <code>prenoms</code>, respectivement.</li>
<li>Empiler le contenu des tableaux de données <code>notes_2012</code>, <code>notes_2013</code> et <code>notes_2014</code> dans un objet que l’on nommera <code>notes</code>.</li>
<li>Fusionner les tableaux <code>notes</code> et <code>prenoms</code> à l’aide d’une jointure gauche, de manière à rajouter les informations contenues dans le tableau prenoms aux observations de notes. La jointure doit se faire par le numéro d’étudiant et l’année, l’objet final viendra remplacer le contenu de notes.</li>
<li>Trier le tableau notes par années croissantes et notes de macro décroissantes.</li>
<li>Créer une colonne <code>apres_2012</code> qui prend la valeur <code>True</code> si l’observation concerne une note attribuée après 2012.</li>
<li>En effectuant des regroupements sur le dataframe <code>notes</code> calculer :</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>la moyenne et l’écart-type annuels des notes pour chacune des deux matières,</li>
<li>la moyenne et l’écart-type annuels et par sexe des notes pour chacune des deux matières.</li>
</ol>
</div>

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-vanderplas2016python">
<p>VanderPlas, Jake. 2016. <em>Python Data Science Handbook: Essential Tools for Working with Data</em>. “ O’Reilly Media, Inc.”</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="numpy.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="visualisation-de-donnees.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/3wen/Python_pour_economistes/edit/master/python_for_economists.Rmd",
"text": "Edit"
},
"download": ["_main.pdf", "_main.epub"],
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toc_depth": 4,
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
